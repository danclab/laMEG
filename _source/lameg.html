

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>lameg package &#8212; laMEG 0.0.5 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_source/lameg';</script>
    <link rel="canonical" href="https://danclab.github.io/laMEG/_source/lameg.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
    <p class="title logo__title">lameg</p>
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../auto_tutorials/index.html">
                        Tutorials gallery
                      </a>
                    </li>
                

                <li class="nav-item">
                  <a class="nav-link nav-external" href="https://github.com/danclab/laMEG">
                    GitHub
                  </a>
                </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/danclab/laMEG" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/danc_labo" title="Twitter" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../auto_tutorials/index.html">
                        Tutorials gallery
                      </a>
                    </li>
                

                <li class="nav-item">
                  <a class="nav-link nav-external" href="https://github.com/danclab/laMEG">
                    GitHub
                  </a>
                </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/danclab/laMEG" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/danc_labo" title="Twitter" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">lameg package</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="lameg-package">
<h1>lameg package<a class="headerlink" href="#lameg-package" title="Permalink to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">#</a></h2>
</section>
<section id="module-lameg.invert">
<span id="lameg-invert-module"></span><h2>lameg.invert module<a class="headerlink" href="#module-lameg.invert" title="Permalink to this heading">#</a></h2>
<p>This module provides tools for the coregistration, and source reconstruction of MEG data
using SPM (Statistical Parametric Mapping).
Key operations include:</p>
<ul class="simple">
<li><p>Coregistration of MRI and surface meshes with MEG data.</p></li>
<li><p>Empirical Bayesian Beamformer (EBB) and Multiple Sparse Priors (MSP) source reconstruction
algorithms.</p></li>
<li><p>Sliding time window source reconstruction using MSP</p></li>
<li><p>Utility function for loading source data after source reconstruction.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.coregister">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">coregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mri_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('nas',</span> <span class="pre">'lpa',</span> <span class="pre">'rpa')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#lameg.invert.coregister" title="Permalink to this definition">#</a></dt>
<dd><p>Run head coregistration.</p>
<p>This function performs head coregistration on MEG data using an MRI and mesh, and computes
a forward model using the Nolte single shell model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nas</strong> (<em>list</em>) – NASion fiducial coordinates.</p></li>
<li><p><strong>lpa</strong> (<em>list</em>) – Left PreAuricular fiducial coordinates.</p></li>
<li><p><strong>rpa</strong> (<em>list</em>) – Right PreAuricular fiducial coordinates.</p></li>
<li><p><strong>mri_fname</strong> (<em>str</em>) – Filename of the MRI data.</p></li>
<li><p><strong>mesh_fname</strong> (<em>str</em>) – Filename of the mesh data.</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the MEG data.</p></li>
<li><p><strong>fid_labels</strong> (<em>list</em><em>, </em><em>optional</em>) – Fiducial coordinate labels. Default is [‘nas’, ‘lpa’, ‘rpa’].</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to show SPM visualization. Default is True.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.
The function will automatically close the standalone SPM instance if it was started
within the function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_ebb">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_ebb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_folds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ideal_pc_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.invert_ebb" title="Permalink to this definition">#</a></dt>
<dd><p>Run the Empirical Bayesian Beamformer (EBB) source reconstruction algorithm.</p>
<p>This function performs EBB source reconstruction on MEG data. It involves mesh smoothing
and running the EBB algorithm. The MEG data must already be coregistered with the given mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh_fname</strong> (<em>str</em>) – Filename of the mesh data.</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the MEG data.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of layers in the mesh.</p></li>
<li><p><strong>patch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – Patch size for mesh smoothing. Default is 5.</p></li>
<li><p><strong>n_temp_modes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of temporal modes for the beamformer. Default is 4.</p></li>
<li><p><strong>foi</strong> (<em>list</em><em>, </em><em>optional</em>) – Frequency of interest range as [low, high]. Default is [0, 256].</p></li>
<li><p><strong>woi</strong> (<em>list</em><em>, </em><em>optional</em>) – Window of interest as [start, end]. Default is [-np.inf, np.inf].</p></li>
<li><p><strong>hann_windowing</strong> (<em>int</em><em>, </em><em>optional</em>) – Whether or not to perform Hann windowing. Default is False.</p></li>
<li><p><strong>n_folds</strong> (<em>int</em>) – Number of cross-validation folds. Must be &gt;1 for cross-validation error.</p></li>
<li><p><strong>ideal_pc_test</strong> (<em>float</em>) – Percentage of channels to leave out (ideal because it needs an integer number of channels).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to show SPM visualization. Default is True.</p></li>
<li><p><strong>return_mu_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to return the matrix needed to reconstruct source activity. Default is False.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the free energy, cross-validation error (cv_err), and the matrix needed
to reconstruct source activity (mu_matrix; if return_mu_matrix is True).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_msp">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_msp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_folds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ideal_pc_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.invert_msp" title="Permalink to this definition">#</a></dt>
<dd><p>Run the Multiple Sparse Priors (MSP) source reconstruction algorithm.</p>
<p>This function performs MSP source reconstruction on MEG data. It involves mesh smoothing and
running the MSP algorithm. The MEG data must already be coregistered with the given mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh_fname</strong> (<em>str</em>) – Filename of the mesh data.</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the MEG data.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of layers in the mesh.</p></li>
<li><p><strong>priors</strong> (<em>list</em><em>, </em><em>optional</em>) – Indices of vertices to be used as priors. Default is an empty list.</p></li>
<li><p><strong>patch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – Patch size for mesh smoothing. Default is 5.</p></li>
<li><p><strong>n_temp_modes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of temporal modes for the beamformer. Default is 4.</p></li>
<li><p><strong>foi</strong> (<em>list</em><em>, </em><em>optional</em>) – Frequency of interest range as [low, high]. Default is [0, 256].</p></li>
<li><p><strong>woi</strong> (<em>list</em><em>, </em><em>optional</em>) – Window of interest as [start, end]. Default is [-np.inf, np.inf].</p></li>
<li><p><strong>hann_windowing</strong> (<em>int</em><em>, </em><em>optional</em>) – Whether or not to perform Hann windowing. Default is False.</p></li>
<li><p><strong>n_folds</strong> (<em>int</em>) – Number of cross-validation folds. Must be &gt;1 for cross-validation error.</p></li>
<li><p><strong>ideal_pc_test</strong> (<em>float</em>) – Percentage of channels to leave out (ideal because it needs an integer number of channels).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to show SPM visualization. Default is True.</p></li>
<li><p><strong>return_mu_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to return the matrix needed to reconstruct source activity. Default is False.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the free energy, cross-validation error (cv_err), and the matrix
needed to reconstruct source activity (mu_matrix; if return_mu_matrix is True).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>Priors are adjusted by adding 1 to each index to align with MATLAB’s 1-based indexing.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_sliding_window">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_sliding_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.invert_sliding_window" title="Permalink to this definition">#</a></dt>
<dd><p>Run the Multiple Sparse Priors (MSP) source reconstruction algorithm in a sliding time window.</p>
<p>This function performs MSP source reconstruction on MEG data within sliding time windows. It
involves mesh smoothing and running the MSP algorithm. The MEG data must already be
coregistered with the given mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<em>float</em>) – Index of the vertex to be used as a prior.</p></li>
<li><p><strong>mesh_fname</strong> (<em>str</em>) – Filename of the mesh data.</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the MEG data.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of layers in the mesh.</p></li>
<li><p><strong>patch_size</strong> (<em>int</em><em>, </em><em>optional</em>) – Patch size for mesh smoothing. Default is 5.</p></li>
<li><p><strong>n_temp_modes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of temporal modes for the beamformer. Default is 1.</p></li>
<li><p><strong>win_size</strong> (<em>float</em><em>, </em><em>optional</em>) – Size of the sliding window in ms. Default is 50. If you increase <cite>win_size</cite>, you may need
to increase <cite>n_temp_modes</cite>.</p></li>
<li><p><strong>win_overlap</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the windows should overlap. Default is True.</p></li>
<li><p><strong>foi</strong> (<em>list</em><em>, </em><em>optional</em>) – Frequency of interest range as [low, high]. Default is [0, 256].</p></li>
<li><p><strong>hann_windowing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to use Hann windowing. Default is True.</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to show SPM visualization. Default is True.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the free energy time series (free_energy), and the windows of interest
(wois).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>The prior index is adjusted by adding 1 to align with MATLAB’s 1-based indexing.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.load_source_time_series">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">load_source_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.load_source_time_series" title="Permalink to this definition">#</a></dt>
<dd><p>Load source time series data from specified vertices using precomputed inverse solutions or a
lead field matrix.</p>
<p>This function extracts time series data from specific vertices, based on precomputed inverse
solutions, or computes the source time series using a provided lead field matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename or path of the MEG data file.</p></li>
<li><p><strong>mu_matrix</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – Lead field matrix (source x sensor). Default is None.</p></li>
<li><p><strong>inv_fname</strong> (<em>str</em><em>, </em><em>optional</em>) – Filename or path of the file containing the inverse solutions. Default is None.</p></li>
<li><p><strong>vertices</strong> (<em>list</em><em> of </em><em>int</em><em>, </em><em>optional</em>) – List of vertex indices from which to extract time series data. Default is None, which
implies all vertices will be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>source_ts</strong> (<em>np.array</em>) – An array containing the extracted source time series data (sources x time x trial).</p></li>
<li><p><strong>time</strong> (<em>np.array</em>) – An array containing the timestamps.</p></li>
<li><p><strong>mu_matrix</strong> (<em>np.array</em>) – The matrix needed to reconstruct source activity from sensor signals.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>inv_fname</cite> is not provided, and <cite>mu_matrix</cite> is None, the inverse solution from the
MEG data file specified by <cite>data_fname</cite> will be used.</p></li>
<li><p>If <cite>mu_matrix</cite> is provided, the function will compute the source time series directly using
the lead field matrix, without the need for precomputed inverse solutions.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.laminar">
<span id="lameg-laminar-module"></span><h2>lameg.laminar module<a class="headerlink" href="#module-lameg.laminar" title="Permalink to this heading">#</a></h2>
<p>This module provides tools for performing laminar analysis of MEG signals.
It integrates functionalities for performing source reconstruction using different methods
(Empirical Bayesian Beamformer and Multiple Sparse Priors), and assessing model fit via free
energy and cross validation error. It also includes capabilities for analyzing laminar current
source density and comparing regional brain activity across different conditions or layers.</p>
<p>Key functionalities include:
- Source reconstruction with options to choose between different methods and evaluate model fits.
- Calculation of current source density from laminar neural signals.
- Comparison of power changes across different regions and layers to identify areas of interest.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.compute_csd">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">compute_csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sfreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.compute_csd" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the laminar Current Source Density (CSD) from a given signal.</p>
<p>This function calculates CSD using the Standard CSD method. It takes a multi-layered neural
signal, and computes the CSD. An optional smoothing step can be applied to the CSD output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>numpy.ndarray</em>) – The neural signal matrix, where rows correspond to different layers and columns to time
points.</p></li>
<li><p><strong>thickness</strong> (<em>float</em>) – The laminar thickness of the cortex from which the signal was recorded, in millimeters.</p></li>
<li><p><strong>sfreq</strong> (<em>float</em>) – Sampling frequency of the signal in Hertz.</p></li>
<li><p><strong>smoothing</strong> (<em>str</em><em>, </em><em>optional</em>) – Specifies the kind of smoothing to apply to the CSD. Acceptable values are those compatible
with <cite>scipy.interpolate.interp1d</cite>, such as ‘linear’, ‘nearest’, ‘zero’, ‘slinear’,
‘quadratic’, ‘cubic’, etc. If None, no smoothing is applied. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret_vals</strong> – A list containing the CSD matrix as the first element. If smoothing is applied, the second
element is the smoothed CSD matrix. The CSD matrix dimensions are layers x time points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function requires the ‘neo’, ‘quantities’ (pq), ‘numpy’ (np), ‘elephant’, and
‘scipy.interpolate.interp1d’ libraries.</p></li>
<li><p>The CSD is calculated using the Standard CSD method provided by the ‘elephant’ package.</p></li>
<li><p>Smoothing is applied across layers and is independent for each time point.</p></li>
<li><p>The returned CSD matrix has the same number of time points as the input signal but can have a
different number of layers if smoothing is applied.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.model_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">model_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mri_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fnames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'EBB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coregister_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.model_comparison" title="Permalink to this definition">#</a></dt>
<dd><p>Compare model fits using different meshes by computing the free energy.</p>
<p>This function runs source reconstruction algorithms (either Empirical Bayesian Beamformer or
Multiple Sparse Priors) on a set of meshes and compares their model fits using the free energy
and cross-validation error metrics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nas</strong> (<em>list</em>) – NASion fiducial coordinates.</p></li>
<li><p><strong>lpa</strong> (<em>list</em>) – Left PreAuricular fiducial coordinates.</p></li>
<li><p><strong>rpa</strong> (<em>list</em>) – Right PreAuricular fiducial coordinates.</p></li>
<li><p><strong>mri_fname</strong> (<em>str</em>) – Filename of the MRI data.</p></li>
<li><p><strong>mesh_fnames</strong> (<em>list</em>) – List of filenames for different meshes.</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the MEG data.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Source reconstruction method, either ‘EBB’ or ‘MSP’. Default is ‘EBB’.</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM visualizations. Default is True.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM software. Default is None.</p></li>
<li><p><strong>coregister_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments specifically for the <cite>coregister</cite> function.</p></li>
<li><p><strong>invert_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments specifically for the <cite>invert</cite> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f_vals</strong> (<em>np.array</em>) – Free energy values for each mesh.</p></li>
<li><p><strong>cv_errs</strong> (<em>np.array</em>) – The cross-validation error for each mesh.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>Free energy is used as a measure of model fit, with higher values indicating better fit.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.roi_power_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">roi_power_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_woi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc_thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.roi_power_comparison" title="Permalink to this definition">#</a></dt>
<dd><p>Computes and compares power changes in pial and white matter layers to define
regions of interest (ROI) based on significant power shifts.</p>
<p>This function calculates power changes in the pial and white matter layers during a specified
window of interest (WOI) and a baseline window. It identifies ROIs by comparing these changes
against a percentile threshold and performs a relative comparison of power changes between
the layers to assess laminar differences.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the data file containing source time series.</p></li>
<li><p><strong>woi</strong> (<em>tuple</em>) – Window of interest, specified as a start and end time (in milliseconds).</p></li>
<li><p><strong>baseline_woi</strong> (<em>tuple</em>) – Baseline window of interest for comparison, specified as start and end time (in
milliseconds).</p></li>
<li><p><strong>mesh</strong> (<em>nibabel.gifti.GiftiImage</em>) – Gifti surface mesh.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of layers in the cortical model.</p></li>
<li><p><strong>perc_thresh</strong> (<em>float</em>) – Percentile threshold for determining significant changes in power.</p></li>
<li><p><strong>mu_matrix</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – Lead field matrix (source x sensor). Default is None.</p></li>
<li><p><strong>chunk_size</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of vertices to load source time series from at once. If None, will load all at the
same time. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>laminar_t_statistic</strong> (<em>float</em>) – The t-statistic for laminar power comparison.</p></li>
<li><p><strong>laminar_p_value</strong> (<em>float</em>) – The p-value associated with the laminar power comparison.</p></li>
<li><p><strong>deg_of_freedom</strong> (<em>int</em>) – Degrees of freedom for the statistical test.</p></li>
<li><p><strong>roi_idx</strong> (<em>list of int</em>) – Indices of vertices considered as ROIs.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.sliding_window_model_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">sliding_window_model_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mri_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fnames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coregister_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.sliding_window_model_comparison" title="Permalink to this definition">#</a></dt>
<dd><p>Compare model fits across different meshes using a sliding window approach.</p>
<p>This function runs source reconstruction using the Multiple Sparse Priors (MSP) method in
sliding time windows on a set of meshes. It compares the model fits for each mesh by computing
the free energy in each window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<em>float</em>) – Index of the vertex to be used as a prior.</p></li>
<li><p><strong>nas</strong> (<em>list</em>) – NASion fiducial coordinates.</p></li>
<li><p><strong>lpa</strong> (<em>list</em>) – Left PreAuricular fiducial coordinates.</p></li>
<li><p><strong>rpa</strong> (<em>list</em>) – Right PreAuricular fiducial coordinates.</p></li>
<li><p><strong>mri_fname</strong> (<em>str</em>) – Filename of the MRI data.</p></li>
<li><p><strong>mesh_fnames</strong> (<em>list</em>) – List of filenames for different meshes.</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Filename of the MEG data.</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to show SPM visualization. Default is True.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
<li><p><strong>coregister_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments specifically for the <cite>coregister</cite> function.</p></li>
<li><p><strong>invert_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Keyword arguments specifically for the <cite>invert_sliding_window</cite> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f_vals</strong> (<em>list</em>) – Free energy values for each mesh.</p></li>
<li><p><strong>wois</strong> (<em>list</em>) – Windows of interest.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>Free energy is used as a measure of model fit, with higher values indicating better fit.</p></li>
<li><p>The prior index is adjusted by adding 1 to align with MATLAB’s 1-based indexing.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.simulate">
<span id="lameg-simulate-module"></span><h2>lameg.simulate module<a class="headerlink" href="#module-lameg.simulate" title="Permalink to this heading">#</a></h2>
<p>This module facilitates the simulation of MEG data using the Statistical Parametric Mapping (SPM)
toolbox. It provides functionalities to simulate both current density and dipole-based MEG data
under varying conditions and configurations.</p>
<p>Key Features:</p>
<ul class="simple">
<li><p>Current Density Simulation: Allows for the simulation of current density data based on
user-defined parameters such as vertices, signals, dipole moments, and patch sizes. Includes the
ability to specify the signal-to-noise ratio and window of interest for the simulations.</p></li>
<li><p>Dipole Simulation: Facilitates the simulation of dipole-based data, providing options to
configure dipole orientations, moments, and noise levels. It supports the simulation of unique
signals per trial and can average data across trials if needed.</p></li>
</ul>
<p>Examples of use:</p>
<ul class="simple">
<li><p>Simulating data with specific noise levels and analyzing the impact of noise on signal processing
algorithms.</p></li>
<li><p>Generating datasets with known properties to test the efficacy of dipole fitting routines or
source localization methods.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.check_inversion_exists">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">check_inversion_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.simulate.check_inversion_exists" title="Permalink to this definition">#</a></dt>
<dd><p>Check if inversion data exists in the loaded HDF5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<em>h5py.File</em>) – The loaded HDF5 file object. The expected structure is file[‘D’][‘other’][‘inv’].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns True if inversion data exists in the file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the inversion data is missing or not found in the expected structure.</p></li>
<li><p><strong>KeyError</strong> – If the required keys are missing from the file structure.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.load_vertices">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">load_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.simulate.load_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>Load vertices from the HDF5 file based on the file version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<em>h5py.File</em>) – The loaded HDF5 file object. The function expects the structure
file[‘D’][‘other’][‘inv’][0][0][‘mesh’][‘tess_mni’][‘vert’].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A NumPy array containing the vertices loaded from the file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the file is not saved in a format compatible with MATLAB v7.3 or later.</p></li>
<li><p><strong>KeyError</strong> – If the required keys are missing from the file structure.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.run_current_density_simulation">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">run_current_density_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_signals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_moments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_patch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_trials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.simulate.run_current_density_simulation" title="Permalink to this definition">#</a></dt>
<dd><p>Simulate current density data based on specified parameters.</p>
<p>This function generates simulated MEG data based on specified vertices, signals, dipole
moments, and patch sizes, incorporating a defined signal-to-noise ratio (SNR). White noise is
added at the sensor level to yield the given SNR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_file</strong> (<em>str</em>) – Filename or path of the MEG data file used as a template for simulation.</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – Prefix for the output simulated data filename.</p></li>
<li><p><strong>sim_vertices</strong> (<em>list</em><em> or </em><em>int</em>) – Indices of vertices where simulations are centered. Can be a single integer or a list.</p></li>
<li><p><strong>sim_signals</strong> (<em>ndarray</em>) – Array of simulated signals.</p></li>
<li><p><strong>dipole_moments</strong> (<em>list</em><em> or </em><em>float</em>) – Dipole moments for the simulation. Can be a single float or a list.</p></li>
<li><p><strong>sim_patch_sizes</strong> (<em>list</em><em> or </em><em>int</em>) – Sizes of patches around each vertex for the simulation. Can be a single integer or a list.</p></li>
<li><p><strong>snr</strong> (<em>float</em>) – Signal-to-noise ratio for the simulation.</p></li>
<li><p><strong>sim_woi</strong> (<em>list</em><em>, </em><em>optional</em>) – Window of interest for the simulation as [start, end]. Default is [-np.inf, np.inf].</p></li>
<li><p><strong>average_trials</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to average the simulated data over trials. Default is False.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sim_fname</strong> – Filename of the generated simulated data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.run_dipole_simulation">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">run_dipole_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_signals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_orientations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_moments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_patch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_trials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.simulate.run_dipole_simulation" title="Permalink to this definition">#</a></dt>
<dd><p>Simulate dipole-based MEG data based on specified parameters.</p>
<p>This function generates simulated MEG data with specific dipole configurations. It creates
simulations based on specified vertices, signals, dipole orientations, moments, and patch
sizes, incorporating a defined signal-to-noise ratio (SNR). White noise is added at the sensor
level to yield the given SNR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_file</strong> (<em>str</em>) – Filename or path of the MEG data file used as a template for simulation.</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – Prefix for the output simulated data filename.</p></li>
<li><p><strong>sim_vertices</strong> (<em>list</em><em> or </em><em>int</em>) – Indices of vertices where simulations are centered. Can be a single integer or a list.</p></li>
<li><p><strong>sim_signals</strong> (<em>ndarray</em>) – Array of simulated signals. Either dipoles x time (signal will be used for each trial), or
dipoles x time x trials (unique signal for each trial).</p></li>
<li><p><strong>dipole_orientations</strong> (<em>ndarray</em>) – Array of dipole orientations for the simulation.</p></li>
<li><p><strong>dipole_moments</strong> (<em>list</em><em> or </em><em>float</em>) – Dipole moments for the simulation. Can be a single float or a list.</p></li>
<li><p><strong>sim_patch_sizes</strong> (<em>list</em><em> or </em><em>int</em>) – Sizes of patches around each vertex for the simulation. Can be a single integer or a list.</p></li>
<li><p><strong>snr</strong> (<em>float</em>) – Signal-to-noise ratio for the simulation.</p></li>
<li><p><strong>sim_woi</strong> (<em>list</em><em>, </em><em>optional</em>) – Window of interest for the simulation as [start, end]. Default is [-np.inf, np.inf].</p></li>
<li><p><strong>average_trials</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to average the simulated data over trials. Default is False.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sim_fname</strong> – Filename of the generated simulated data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.surf">
<span id="lameg-surf-module"></span><h2>lameg.surf module<a class="headerlink" href="#module-lameg.surf" title="Permalink to this heading">#</a></h2>
<p>This module provides a set of tools for handling and manipulating surface mesh data. The
functionalities include computing mesh normals, interpolating mesh data, handling non-manifold
edges, creating and manipulating GIFTI surface files, and downsampling meshes using the VTK
library.</p>
<p>Key functionalities include:
- Normalization of vectors to unit length.
- Calculation of normals for mesh surfaces using both Delaunay triangulation and custom methods.
- Creation of GIFTI images from mesh data.
- Removal of specified vertices from a mesh and updating the mesh topology accordingly.
- Identification and handling of non-manifold edges to ensure mesh manifoldness.
- Interpolation of data from a downsampled mesh back to its original high-resolution mesh.
- Downsampling of meshes using VTK’s decimation algorithms.
- Combination and adjustment of multiple surface meshes into a single mesh.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.combine_surfaces">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">combine_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surfaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.combine_surfaces" title="Permalink to this definition">#</a></dt>
<dd><p>Combine multiple surface meshes into a single surface mesh.</p>
<p>This function takes a list of Gifti surface meshes and combines them into a single surface
mesh. It concatenates the vertices, faces, and normals (if present) from each surface. The
faces are re-indexed appropriately to maintain the correct references to the combined vertex
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>surfaces</strong> (<em>list</em><em> of </em><em>nibabel.gifti.GiftiImage</em>) – List of Gifti surface meshes to be combined.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>combined_surf</strong> – A single combined Gifti surface mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nibabel.gifti.GiftiImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The vertices, faces, and normals (if present) from each surface are concatenated.</p></li>
<li><p>The faces are re-indexed to reference the correct vertices in the combined vertex array.</p></li>
<li><p>If normals are present in any of the input surfaces, they are also combined.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the vertex or face arrays do not have the expected dimensions.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surfaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;path/to/surface1.gii&#39;</span><span class="p">),</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;path/to/surface2.gii&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combined_surf</span> <span class="o">=</span> <span class="n">combine_surfaces</span><span class="p">(</span><span class="n">surfaces</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">combined_surf</span><span class="p">,</span> <span class="s1">&#39;path/to/combined_surface.gii&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.compute_dipole_orientations">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">compute_dipole_orientations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.compute_dipole_orientations" title="Permalink to this definition">#</a></dt>
<dd><p>Compute dipole orientations for cortical layers using different methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>str</em>) – Method for computing dipole orientations (‘link_vector’, ‘ds_surf_norm’, ‘orig_surf_norm’,
or ‘cps’).
link_vector: Vectors connecting pial vertices to corresponding white matter vertices.
ds_surf_norm: Surface normal vectors computed from the downsampled surface.
orig_surf_norm: Surface normal vectors computed from the original (non-downsampled) surface.
cps: Cortical patch statistics - mean surface normal vectors from connected vertices in the
original (non-downsampled) surface.</p></li>
<li><p><strong>layer_names</strong> (<em>list</em>) – Names of the cortical layers.</p></li>
<li><p><strong>surf_dir</strong> (<em>str</em>) – Directory where the surface files are stored.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to ensure that orientation of corresponding vertices across layers is the same (True
by default). If True, for ‘ds_surf_norm’, ‘orig_surf_norm’, and ‘cps’, orientations
computed from the pial surface are used for all layers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>orientations</strong> – An array of dipole orientations for each vertex in each layer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of vertices in pial and white matter surfaces do not match.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.create_layer_mesh">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">create_layer_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemispheres</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs_subject_dir</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#lameg.surf.create_layer_mesh" title="Permalink to this definition">#</a></dt>
<dd><p>Create or retrieve a specified cortical layer mesh file name or path based on the provided
layer proportional thickness or identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer</strong> (<em>float</em><em> or </em><em>int</em>) – Specifies the cortical layer. The value 1 corresponds to the ‘pial’ surface, values between
0 and 1 (exclusive) correspond to intermediate layers (specified as a decimal), and the
value 0 corresponds to the ‘white matter’ surface.</p></li>
<li><p><strong>hemispheres</strong> (<em>list</em><em> of </em><em>str</em>) – A list of hemisphere identifiers (e.g., [‘lh’, ‘rh’]) for which meshes should be created or
retrieved.</p></li>
<li><p><strong>fs_subject_dir</strong> (<em>str</em>) – Path to the subject directory within the FreeSurfer environment. This directory should
include a ‘surf’ directory where mesh files are stored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>layer_name</strong> – Returns a string representing the mesh layer (‘pial’, ‘white’, or a specific intermediate
layer as a formatted string). Returns None if the input layer does not match any recognized
pattern (e.g., a negative number or a number greater than 1).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str or None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For intermediate layers (0 &lt; layer &lt; 1), the function will check for the existence of the mesh
file corresponding to each hemisphere. If it does not exist, it uses ‘mris_expand’ to generate
it using the white matter surface file. If the layer exactly matches 0 or 1, it returns the
corresponding standard FreeSurfer mesh identifier (‘white’ or ‘pial’).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.create_surf_gifti">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">create_surf_gifti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.create_surf_gifti" title="Permalink to this definition">#</a></dt>
<dd><p>Create a Gifti image object from surface mesh data.</p>
<p>This function creates a GiftiImage object from the provided vertices, faces, and optional
normals. The vertices and faces are required, while normals are optional. If normals are
provided, they are added to the Gifti image. The function returns the GiftiImage object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>numpy.ndarray</em>) – Array of vertices. Each row represents a vertex with its x, y, z coordinates.</p></li>
<li><p><strong>faces</strong> (<em>numpy.ndarray</em>) – Array of faces. Each row represents a face with three integers corresponding to vertex
indices.</p></li>
<li><p><strong>normals</strong> (<em>numpy.ndarray</em><em>, </em><em>optional</em>) – Array of vertex normals. Each row represents a normal vector corresponding to a vertex.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_gifti</strong> – The GiftiImage object created from the provided mesh data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nibabel.gifti.GiftiImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Vertex, face, and normal arrays should be NumPy arrays.</p></li>
<li><p>Vertices and normals should be in float32 format, and faces should be in int32 format.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gifti_img</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.downsample_multiple_surfaces">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">downsample_multiple_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_surfs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.downsample_multiple_surfaces" title="Permalink to this definition">#</a></dt>
<dd><p>Downsample multiple surface meshes using the VTK decimation algorithm.</p>
<p>This function takes a list of input surface meshes (in Gifti format) and applies a downsampling
process to each surface. The downsampling is performed using VTK’s <cite>vtkDecimatePro</cite> algorithm.
The first surface in the list is downsampled, and its vertex mapping is then applied to all
other surfaces in the list. The function returns a list of downsampled surface meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_surfs</strong> (<em>list</em><em> of </em><em>nibabel.gifti.GiftiImage</em>) – Input Gifti surface meshes to be downsampled.</p></li>
<li><p><strong>ratio</strong> (<em>float</em>) – The reduction ratio for the downsampling process. For example, a ratio of 0.1
implies that the mesh will be reduced to 90% of its original size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>out_surfs</strong> – List of downsampled Gifti surface meshes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of nibabel.gifti.GiftiImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function prints the percentage of vertices retained in the first surface after
downsampling.</p></li>
<li><p>If normals are present in the input surfaces, they are also downsampled and mapped to the
new surfaces.</p></li>
<li><p>The resulting surfaces maintain the original topology and are suitable for visualization and
further processing.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_surfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;path/to/input_surf1.gii&#39;</span><span class="p">),</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;path/to/input_surf2.gii&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out_surfs</span> <span class="o">=</span> <span class="n">downsample_multiple_surfaces</span><span class="p">(</span><span class="n">in_surfs</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ds_surf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_surfs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">ds_surf</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;path/to/output_surf</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.downsample_single_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">downsample_single_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.downsample_single_surface" title="Permalink to this definition">#</a></dt>
<dd><p>Downsample a Gifti surface using the VTK library.</p>
<p>This function takes a Gifti surface defined by its vertices and faces, and downsamples it using
VTK’s <cite>vtkDecimatePro</cite> algorithm. The reduction ratio determines the degree of downsampling.
The function returns the downsampled Gifti surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gifti_surf</strong> (<em>nibabel.gifti.GiftiImage</em>) – The Gifti surface object to be downsampled.</p></li>
<li><p><strong>reduction_ratio</strong> (<em>float</em>) – The proportion of the mesh to remove. For example, a reduction ratio of 0.1 retains 90% of
the original mesh.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_gifti_surf</strong> – A new GiftiImage object with the downsampled surface.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nibabel.gifti.GiftiImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input faces array should be triangulated, i.e., each face should consist of exactly three
vertex indices.</p></li>
<li><p>The VTK library is used for mesh decimation, which must be installed and properly configured.</p></li>
<li><p>The returned GiftiImage object is a new object; the original <cite>gifti_surf</cite> object is not
modified in place.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gifti_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;path_to_gifti_file.gii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_gifti_surf</span> <span class="o">=</span> <span class="n">downsample_single_surface</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.find_non_manifold_edges">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">find_non_manifold_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.find_non_manifold_edges" title="Permalink to this definition">#</a></dt>
<dd><p>Identify non-manifold edges in a given mesh represented by its faces.</p>
<p>A non-manifold edge is defined as an edge that is shared by more than two faces. This function
processes an array of faces, each face represented by a tuple of vertex indices, and identifies
edges that meet the non-manifold criteria.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>faces</strong> (<em>np.ndarray</em>) – An array where each row represents a face as a tuple of three vertex indices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>non_manifold_edges</strong> – A dictionary where keys are tuples representing non-manifold edges (vertex indices are
sorted), and values are lists of face indices that share the edge.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function uses a <cite>defaultdict</cite> to collect face indices for each edge encountered in the mesh.
It then filters out edges that are associated with more than two faces, identifying them as
non-manifold.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.fix_non_manifold_edges">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">fix_non_manifold_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.fix_non_manifold_edges" title="Permalink to this definition">#</a></dt>
<dd><p>Remove faces associated with non-manifold edges from a mesh defined by vertices and faces.</p>
<p>Non-manifold edges are edges that are shared by more than two faces, which can cause issues
in various mesh processing tasks such as mesh simplification, smoothing, or 3D printing. This
function identifies such edges and removes all faces associated with them to ensure
manifoldness of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> (<em>np.ndarray</em>) – An array of vertices, where each row represents a vertex as [x, y, z] coordinates.</p></li>
<li><p><strong>faces</strong> (<em>np.ndarray</em>) – An array of faces, where each row represents a face as indices into the vertices array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vertices</strong> (<em>np.ndarray</em>) – The unchanged array of vertices.</p></li>
<li><p><strong>new_faces</strong> (<em>np.ndarray</em>) – The modified array of faces, with faces associated with non-manifold edges removed.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_faces</span> <span class="o">=</span> <span class="n">fix_non_manifold_edges</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_faces</span>
<span class="go">array([[0, 1, 2], [0, 2, 3]])  # Assuming face [1, 2, 3] was associated with a non-manifold</span>
<span class="go">edge.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.interpolate_data">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">interpolate_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsampled_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsampled_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.interpolate_data" title="Permalink to this definition">#</a></dt>
<dd><p>Interpolate vertex data from a downsampled mesh back to the original mesh using nearest
neighbor matching and optional smoothing based on an adjacency matrix. Both meshes are
expected to be nibabel Gifti objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_mesh</strong> (<em>nibabel.gifti.GiftiImage</em>) – The original high-resolution mesh as a nibabel Gifti object from which ‘downsampled_mesh’
is derived.</p></li>
<li><p><strong>downsampled_mesh</strong> (<em>nibabel.gifti.GiftiImage</em>) – The downsampled version of the original mesh as a nibabel Gifti object.</p></li>
<li><p><strong>downsampled_data</strong> (<em>array</em>) – Data associated with the vertices of ‘downsampled_mesh’.</p></li>
<li><p><strong>adjacency_matrix</strong> (<em>sparse matrix</em><em>, </em><em>optional</em>) – A vertex-by-vertex adjacency matrix of the original mesh. If None, it will be computed from
the ‘original_mesh’.</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of iterations to perform for smoothing the interpolated data.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vertex_data</strong> – An array of interpolated data for each vertex in the ‘original_mesh’. The data is initially
interpolated using nearest neighbors and can be further refined through iterative smoothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function first finds the nearest vertex in the ‘downsampled_mesh’ for each vertex in the
‘original_mesh’ using a KD-tree. It directly assigns corresponding data values where a close
match is found. The function iteratively adjusts data values at vertices without direct matches
by averaging over neighbors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.iterative_downsample_single_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">iterative_downsample_single_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.iterative_downsample_single_surface" title="Permalink to this definition">#</a></dt>
<dd><p>Iteratively downsample a single surface mesh to a target number of vertices.</p>
<p>This function reduces the number of vertices in a surface mesh (in GIFTI format) to a specified
fraction of its original size. Downsampling is performed iteratively until the target number of
vertices is reached or closely approximated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gifti_surf</strong> (<em>nibabel.gifti.GiftiImage</em>) – The surface mesh to be downsampled, provided as a GIFTI image object.</p></li>
<li><p><strong>ds_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – The downsampling factor representing the target fraction of the original number of vertices.
Default is 0.1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>current_surf</strong> – The downsampled surface mesh as a GIFTI image object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nibabel.gifti.GiftiImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The downsampling process is iterative. In each iteration, the mesh is downsampled by a factor
calculated to approach the target number of vertices.</p></li>
<li><p>If the calculated downsampling factor in an iteration equals or exceeds 1, the process is
terminated to prevent upsampling or infinite loops.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.mesh_adjacency">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">mesh_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.mesh_adjacency" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the adjacency matrix of a triangle mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>faces</strong> (<em>np.array</em><em>, </em><em>shape</em><em> (</em><em>f</em><em>, </em><em>3</em><em>)</em>) – The mesh faces, where <cite>f</cite> is the number of faces, and each face is represented by a tuple of
three vertex indices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>adjacency</strong> – The adjacency matrix of the mesh, where <cite>v</cite> is the number of vertices. Each entry (i, j)
indicates whether vertices i and j are connected by an edge.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array, shape (v, v)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.mesh_normals">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">mesh_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.mesh_normals" title="Permalink to this definition">#</a></dt>
<dd><p>Normalize a numpy array of vectors.</p>
<p>This function normalizes each row in the array of vectors to have unit length. If the length of
a vector is below a certain threshold (machine epsilon), it is set to 1 to avoid division by
zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vectors</strong> (<em>ndarray</em>) – Array of vectors to be normalized. Each row represents a vector.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized array of vectors where each row has unit length.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.postprocess_freesurfer_surfaces">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">postprocess_freesurfer_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_surfaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.postprocess_freesurfer_surfaces" title="Permalink to this definition">#</a></dt>
<dd><p>Process and combine FreeSurfer surface meshes for a subject.</p>
<p>This function processes FreeSurfer surface meshes for a given subject by creating intermediate
surfaces, adjusting for RAS offset, removing deep vertices, combining hemispheres,
downsampling, and computing link vectors. The resulting surfaces are combined and saved to a
specified output file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – Subject ID corresponding to the FreeSurfer subject directory.</p></li>
<li><p><strong>out_dir</strong> (<em>str</em>) – Output directory where the processed files will be saved.</p></li>
<li><p><strong>out_fname</strong> (<em>str</em>) – Filename for the final combined surface mesh.</p></li>
<li><p><strong>n_surfaces</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of intermediate surfaces to create between white and pial surfaces.</p></li>
<li><p><strong>ds_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Downsampling factor for surface decimation.</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Method to compute orientation vectors (‘link_vector’ for pial-white link, ‘ds_surf_norm’
for downsampled surface normals, ‘orig_surf_norm’ for original surface normals, and ‘cps’
for cortical patch statistics).</p></li>
<li><p><strong>fix_orientation</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to ensure that orientation of corresponding vertices across layers is the same (True
by default).</p></li>
<li><p><strong>remove_deep</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to remove vertices located in deep regions (labeled as ‘unknown’).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of parallel processes to run. -1 for all available cores (default is -1).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function assumes the FreeSurfer ‘SUBJECTS_DIR’ environment variable is set.</p></li>
<li><p>Surfaces are processed in Gifti format and combined into a single surface mesh.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">postprocess_freesurfer_surfaces</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/output&#39;</span><span class="p">,</span> <span class="s1">&#39;combined_surface.gii&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.remove_unconnected_vertices">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">remove_unconnected_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.remove_unconnected_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>Remove vertices that are not connected to any faces from a Gifti surface object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>gifti_surf</strong> (<em>nibabel.gifti.GiftiImage</em>) – The Gifti surface object to be processed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cleaned_gifti_surf</strong> – A new GiftiImage object with unconnected vertices removed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nibabel.gifti.GiftiImage</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.remove_vertices">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">remove_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices_to_remove</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.remove_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>Remove specified vertices from a Gifti surface and update the faces accordingly.</p>
<p>This function modifies a Gifti surface by removing the specified vertices. It also updates
the faces of the surface so that they only reference the remaining vertices. If normals
are present in the surface, they are also updated to correspond to the new set of vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gifti_surf</strong> (<em>nibabel.gifti.GiftiImage</em>) – The Gifti surface object from which vertices will be removed.</p></li>
<li><p><strong>vertices_to_remove</strong> (<em>array_like</em>) – An array of vertex indices to be removed from the surface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_gifti</strong> – A new GiftiImage object with the specified vertices removed and faces updated.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nibabel.gifti.GiftiImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assumes that the GiftiImage object contains at least two data arrays: one for
vertices and one for faces. If normals are present, they are also updated.</p></li>
<li><p>Vertex indices in <cite>vertices_to_remove</cite> should be zero-based (following Python’s indexing
convention).</p></li>
<li><p>The returned GiftiImage object is a new object; the original <cite>gifti_surf</cite> object is not
modified in place.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gifti_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;path_to_gifti_file.gii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>  <span class="c1"># Indices of vertices to remove</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_gifti_surf</span> <span class="o">=</span> <span class="n">remove_vertices</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">,</span> <span class="n">vertices_to_remove</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.split_fv">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">split_fv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.split_fv" title="Permalink to this definition">#</a></dt>
<dd><p>Split faces and vertices into connected pieces based on the connectivity of the faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>faces</strong> (<em>np.ndarray</em>) – A 2D numpy array of faces, where each row represents a face and each element is an index to
a vertex in <cite>vertices</cite>.</p></li>
<li><p><strong>vertices</strong> (<em>np.ndarray</em>) – A 2D numpy array of vertices, where each row represents a vertex.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fv_out</strong> – A list where each element is a dictionary with keys ‘faces’ and ‘vertices’. Each dictionary
represents a separately connected patch of the mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dict</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                     <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_patches</span> <span class="o">=</span> <span class="n">split_fv</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Faces and vertices should be defined such that faces sharing a vertex reference the same vertex
number. This function does not explicitly test for duplicate vertices at the same location.</p>
</dd></dl>

</section>
<section id="module-lameg.util">
<span id="lameg-util-module"></span><h2>lameg.util module<a class="headerlink" href="#module-lameg.util" title="Permalink to this heading">#</a></h2>
<p>This module provides tools for interfacing with SPM (Statistical Parametric Mapping) software,
managing MEG sensor data, and working with neuroimaging data in various formats such as NIfTI,
GIFTI, and MATLAB files. It includes functions for batch processing in SPM, converting data
formats, loading and processing sensor data, and working with anatomical structures through
cortical mesh analysis.</p>
<p>Key functionalities:</p>
<ul class="simple">
<li><p>Context management for SPM operations.</p></li>
<li><p>Batch processing for neuroimaging tasks.</p></li>
<li><p>Loading MEG sensor data and managing related file operations.</p></li>
<li><p>Utility functions for anatomical and spatial data transformations.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.batch">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#lameg.util.batch" title="Permalink to this definition">#</a></dt>
<dd><p>Execute a batch processing job in SPM (Statistical Parametric Mapping) using MATLAB.</p>
<p>This function prepares a configuration for an SPM batch job, saves it to a temporary MATLAB
file, and executes it within an SPM instance. The function is capable of running any batch
configuration passed to it, as long as it adheres to SPM’s batch configuration structure.
After processing, it cleans up by deleting the temporary file used for the job.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cfg</strong> (<em>dict</em>) – A dictionary containing the configuration settings for the SPM job. The dictionary should
follow the structure required by SPM’s <cite>matlabbatch</cite> system.</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the SPM GUI will display progress and results, allowing user interaction. If
False, the process runs entirely in the background. Defaults to True.</p></li>
<li><p><strong>spm_instance</strong> (<em>optional</em>) – An instance of an SPM session. If None, a new SPM session is created and used for the job.
Defaults to None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To run an SPM job with a given configuration, you might call the function as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;spm.stats.fmri_spec.dir&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/path/to/output&#39;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;spm.stats.fmri_spec.timing.units&#39;</span><span class="p">:</span> <span class="s1">&#39;secs&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;spm.stats.fmri_spec.sess&#39;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="s1">&#39;scans&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;scan1.nii&#39;</span><span class="p">,</span> <span class="s1">&#39;scan2.nii&#39;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="s1">&#39;cond&#39;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ExampleCondition&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="s1">&#39;onset&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="p">},</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="s1">&#39;multi&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;regress&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;movement&#39;</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]}}</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">viz</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The temporary MATLAB file is created in the system’s default temp directory.</p></li>
<li><p>This function assumes that an SPM and MATLAB environment is properly set up and accessible
through the provided <cite>spm_instance</cite> or through a default SPM environment.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.big_brain_proportional_layer_boundaries">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">big_brain_proportional_layer_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.big_brain_proportional_layer_boundaries" title="Permalink to this definition">#</a></dt>
<dd><p>Get the proportional layer boundaries (6 values between 0 and 1) from the fsaverage-converted
Big Brain atlas included in laMEG.</p>
<p>This function uses the fsaverage-converted Big Brain cortical thickness atlas to calculate
normalized distances between cortical layer boundaries (from layer 1 to layer 6) with values
between 0 and 1. To speed up computation, the results are stored in a NumPy dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>overwrite</strong> (<em>bool</em>) – Whether to overwrite the existing file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>bb_data</strong> – Dictionary with keys “lh” (left hemisphere) and “rh” (right hemisphere) containing arrays
with layer boundaries for each vertex in the hemisphere.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.calc_prop">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">calc_prop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.calc_prop" title="Permalink to this definition">#</a></dt>
<dd><p>Convert independent thickness values to cumulative proportions, while respecting zeros.</p>
<p>This function calculates the cumulative sum of the input vector and normalizes it by the total
sum of the vector. If the total sum is zero, the original vector is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vec</strong> (<em>array-like</em>) – Input array of thickness values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vec</strong> – The cumulative proportion of the input values, normalized by the total sum. If the sum of
the input values is zero, the original vector is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.check_many">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">check_many</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multiple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.check_many" title="Permalink to this definition">#</a></dt>
<dd><p>Check for the presence of strings in a target string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>multiple</strong> (<em>list</em>) – List of strings to be found in the target string.</p></li>
<li><p><strong>target</strong> (<em>str</em>) – The target string in which to search for the specified strings.</p></li>
<li><p><strong>func</strong> (<em>str</em>) – Specifies the search mode: “all” to check if all strings are present, or “any” to check if
any string is present.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function works well with <cite>if</cite> statements in list comprehensions.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.convert_fsaverage_to_native">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">convert_fsaverage_to_native</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.convert_fsaverage_to_native" title="Permalink to this definition">#</a></dt>
<dd><p>Convert a vertex index from fsaverage to a subject’s native surface space.</p>
<p>This function takes a vertex index from the fsaverage template surface and finds the
corresponding vertex index in a subject’s native surface space. It loads the fsaverage
spherical surface, identifies the coordinates of the given vertex index, and then finds the
nearest corresponding vertex on the subject’s registered spherical surface. If the hemisphere
is right, it adjusts the index by adding the number of vertices in the left hemisphere pial
surface so that it matches the combined hemisphere mesh. It returns the adjusted vertex index in
the subject’s native space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – The subject identifier for which the conversion is being performed.</p></li>
<li><p><strong>hemi</strong> (<em>str</em>) – Hemisphere specifier (‘lh’ for left hemisphere, ‘rh’ for right hemisphere).</p></li>
<li><p><strong>vert_idx</strong> (<em>int</em>) – Index of the vertex in the fsaverage surface to be converted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>subj_v_idx</strong> – Index of the vertex on the subject’s native surface that corresponds to the input vertex
index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.convert_native_to_fsaverage">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">convert_native_to_fsaverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_surf_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.convert_native_to_fsaverage" title="Permalink to this definition">#</a></dt>
<dd><p>Convert coordinates from a subject’s native surface space to the fsaverage surface space.</p>
<p>This function maps a vertex coordinate from a subject’s native combined pial surface to the
corresponding vertex index in the fsaverage template space. It determines which hemisphere the
vertex belongs to based on the closest match in the left and right hemispheres’ pial surfaces.
It then finds the nearest vertex in the subject’s registered spherical surface, maps this to
the nearest vertex in the fsaverage spherical surface, and returns the index of this fsaverage
vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – The subject identifier for which the conversion is being performed.</p></li>
<li><p><strong>subj_surf_dir</strong> (<em>str</em>) – The path containing the laMEG-processed subject surfaces.</p></li>
<li><p><strong>subj_coord</strong> (<em>array-like</em>) – The x, y, z coordinates on the subject’s combined hemisphere pial surface to be converted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hemi</strong> (<em>str</em>) – The hemisphere the vertex is found in (‘lh’ for left hemisphere, ‘rh’ for right
hemisphere).</p></li>
<li><p><strong>fsave_v_idx</strong> (<em>int</em>) – Index of the vertex on the fsaverage spherical surface that corresponds to the input
coordinates.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.ctf_fif_spm_conversion">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">ctf_fif_spm_conversion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mne_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res4_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoched</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spm_'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.ctf_fif_spm_conversion" title="Permalink to this definition">#</a></dt>
<dd><p>Convert a *.fif file containing data from a CTF scanner to SPM data format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mne_file</strong> (<em>str</em><em> or </em><em>pathlib.Path</em><em> or </em><em>os.Path</em>) – Path to the “*-raw.fif” or “*-epo.fif” file.</p></li>
<li><p><strong>res4_file</strong> (<em>str</em><em> or </em><em>pathlib.Path</em><em> or </em><em>os.Path</em>) – Location of the sensor position data (*.res4 for CTF).</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em><em> or </em><em>os.Path</em>) – Location of the converted file.</p></li>
<li><p><strong>epoched</strong> (<em>bool</em>) – Specify if the data is epoched (True) or not (False).</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – A string appended to the output file name after conversion. Default: <code class="docutils literal notranslate"><span class="pre">&quot;spm_&quot;</span></code>.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Instance of standalone SPM. Default is None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">spm_instance</span></code> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_bigbrain_layer_boundaries">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_bigbrain_layer_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_surf_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_bigbrain_layer_boundaries" title="Permalink to this definition">#</a></dt>
<dd><p>Get the cortical layer boundaries based on Big Brain atlas for a specified coordinate in the
subject’s downsampled combined space.</p>
<p>This function maps a vertex coordinate from a subject’s native combined pial surface to the
corresponding vertex index in the fsaverage template space for a specific hemisphere. Then,
the proportional layer boundaries (6 values between 0 and 1) from the fsaverage-converted Big
Brain atlas are returned (from layer 1 to layer 6). To get the subject’s proportional values,
these values must be multiplied by the observed cortical thickness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – The subject identifier for which the conversion is being performed.</p></li>
<li><p><strong>subj_surf_dir</strong> (<em>str</em>) – The path containing the laMEG-processed subject surfaces.</p></li>
<li><p><strong>subj_coord</strong> (<em>array-like</em>) – The x, y, z coordinates on the subject’s combined hemisphere pial surface to be converted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vert_bb_prop</strong> – Proportional layer boundaries (6 values between 0 and 1) from the fsaverage-converted Big
Brain atlas.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_directories">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_directories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_directories" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of directories in the path (or all subdirectories) containing specified strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em><em> or </em><em>os.Path</em>) – The most shallow searched directory.</p></li>
<li><p><strong>depth</strong> (<em>str</em>) – Specifies the depth of the search: “all” for recursive search, “one” for shallow search.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>subdirs</strong> – List of pathlib.Path objects representing the found directories.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_fiducial_coords">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_fiducial_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\t'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'subj_id'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nas_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nas'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lpa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rpa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_fiducial_coords" title="Permalink to this definition">#</a></dt>
<dd><p>Fetch fiducial coordinates from a tab-separated values (TSV) file for a given subject ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – The subject ID to search for in the TSV file.</p></li>
<li><p><strong>fname</strong> (<em>str</em>) – Path to the TSV file.</p></li>
<li><p><strong>col_delimiter</strong> (<em>str</em><em>, </em><em>optional</em>) – Column delimiter when reading file. Default is  .</p></li>
<li><p><strong>subject_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for subject. Default is subj_id.</p></li>
<li><p><strong>nas_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for nas coordinate. Default is nas.</p></li>
<li><p><strong>lpa_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for lpa coordinate. Default is lpa.</p></li>
<li><p><strong>rpa_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for rpa coordinate. Default is rpa.</p></li>
<li><p><strong>val_delimiter</strong> (<em>str</em><em>, </em><em>optional</em>) – Value delimiter when reading file. Default is ,.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>NAS</strong> (<em>list</em>) – List of floats representing the NASion fiducial coordinates.</p></li>
<li><p><strong>LPA</strong> (<em>list</em>) – List of floats representing the Left Preauricular fiducial coordinates.</p></li>
<li><p><strong>RPA</strong> (<em>list</em>) – List of floats representing the Right Preauricular fiducial coordinates.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_files">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_files" title="Permalink to this definition">#</a></dt>
<dd><p>Return a list of files with a specific extension, prefix, and name containing specific strings.</p>
<p>Searches either all files in the target directory or within a specified directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em><em> or </em><em>os.Path</em>) – The most shallow searched directory.</p></li>
<li><p><strong>suffix</strong> (<em>str</em>) – File extension in “*.ext” format.</p></li>
<li><p><strong>strings</strong> (<em>list</em><em> of </em><em>str</em>) – List of strings to search for in the file name.</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – Limits the output list to file names starting with this prefix.</p></li>
<li><p><strong>check</strong> (<em>str</em>) – Specifies the search mode: “all” to check if all strings are present, or “any” to check if
any string is present.</p></li>
<li><p><strong>depth</strong> (<em>str</em>) – Specifies the depth of the search: “all” for recursive search, “one” for shallow search.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>subdirs</strong> – List of pathlib.Path objects representing the found files.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_surface_names">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_surface_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_surface_names" title="Permalink to this definition">#</a></dt>
<dd><p>Generate a list of filenames for each mesh layer in a multi-layer mesh setup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_layers</strong> (<em>int</em>) – The number of layers in the mesh.</p></li>
<li><p><strong>surf_path</strong> (<em>str</em>) – The file path where the mesh files are located.</p></li>
<li><p><strong>orientation_method</strong> (<em>str</em>) – The method used for orientation in the naming of mesh files.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>layer_fnames</strong> – A list of strings, where each string is the full file path to a mesh layer file. The list
order corresponds to the layers’ order, starting from the outermost layer (pial surface)
to the innermost layer (white matter surface).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function assumes a specific naming convention for the mesh files. The outermost layer is
named as ‘pial’, the innermost as ‘white’, and the intermediate layers are named based on their
relative position between 1 (pial) and 0 (white), with the position formatted to three decimal
places. Each filename also includes an orientation method specifier.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.load_meg_sensor_data">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">load_meg_sensor_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.load_meg_sensor_data" title="Permalink to this definition">#</a></dt>
<dd><p>Load sensor data from a MEG dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_fname</strong> (<em>str</em>) – Filename or path of the MEG data file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sensor_data</strong> (<em>ndarray</em>) – An array containing the MEG sensor data (channels x time x trial).</p></li>
<li><p><strong>time</strong> (<em>ndarray</em>) – An array containing the MEG data timestamps.</p></li>
<li><p><strong>ch_names</strong> (<em>list</em>) – A list of channel names.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.make_directory">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">make_directory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extended_dir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.make_directory" title="Permalink to this definition">#</a></dt>
<dd><p>Create a directory along with intermediate directories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em><em> or </em><em>os.Path</em>) – The root directory.</p></li>
<li><p><strong>extended_dir</strong> (<em>str</em><em> or </em><em>list</em>) – Directory or directories to create within <cite>root_path</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>root_path</strong> – The updated root directory.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str or pathlib.Path or os.Path</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.spm_context">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">spm_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.spm_context" title="Permalink to this definition">#</a></dt>
<dd><p>Context manager for handling standalone SPM instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spm</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – An existing standalone instance. Default is None.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – A number of workers in a MATLAB parpool. Default is 4.</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>spm</strong> (<em>spm_standalone</em>) – A standalone SPM instance for use within the context.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm</cite> is None, the function starts a new standalone SPM instance.</p></li>
<li><p>The new standalone SPM instance will be closed automatically upon exiting the context.</p></li>
<li><p>If <cite>spm</cite> is provided, it will be used as is and not closed automatically.</p></li>
<li><p>This function is intended for use in a <cite>with</cite> statement to ensure proper management of
standalone SPM resources.</p></li>
<li><p>Default <cite>n_jobs=4</cite> is suitable for a workstation. Increasing the amount of available workers
is a good choice for deploying with HPC.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.ttest_rel_corrected">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">ttest_rel_corrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.ttest_rel_corrected" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a corrected paired t-test on a sample of data.</p>
<p>This function handles missing data (NaNs) and applies a variance correction to the t-test
calculation. It computes the t-statistic and corresponding p-value for the hypothesis test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em>) – A 2-D array containing the sample data. NaN values are allowed and are handled
appropriately.</p></li>
<li><p><strong>correction</strong> (<em>float</em><em>, </em><em>optional</em>) – The correction value to be added to the variance to avoid division by zero issues. If set
to 0 (default), an automatic correction of 0.01 * max(variance) is applied.</p></li>
<li><p><strong>tail</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies the type of t-test to be performed:
- 0 for a two-tailed test (default),
- 1 for a right one-tailed test,
- -1 for a left one-tailed test.</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em>) – Axis along which to perform the t-test. Default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>t-statistic</strong> (<em>float</em>) – The computed t-statistic for the test.</p></li>
<li><p><strong>degrees_of_freedom</strong> (<em>int</em>) – The degrees of freedom for the t-test.</p></li>
<li><p><strong>p-value</strong> (<em>float</em>) – The p-value for the test.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function handles NaNs by computing the sample size, mean, and variance while ignoring
NaNs.</p></li>
<li><p>The degrees of freedom for the t-test are computed as <cite>max(sample size - 1, 0)</cite>.</p></li>
<li><p>The standard error of the mean is adjusted with the variance correction.</p></li>
<li><p>The p-value is computed based on the specified tail type of the t-test.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.viz">
<span id="lameg-viz-module"></span><h2>lameg.viz module<a class="headerlink" href="#module-lameg.viz" title="Permalink to this heading">#</a></h2>
<p>This module provides tools for converting and visualizing data. It includes functions for mapping
data to RGB and hexadecimal color values, performing color normalization, and rendering 3D surface
visualizations using K3D. Additional utilities are included for plotting Current Source Density
(CSD) data and handling color transformations.</p>
<section id="functions">
<h3>Functions:<a class="headerlink" href="#functions" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>data_to_rgb: Converts numerical data into RGB or RGBA color arrays based on a specified colormap
and normalization.</p></li>
<li><p>rgbtoint: Converts RGB color lists to a single 32-bit integer color representation.</p></li>
<li><p>color_map: Maps numerical data to hexadecimal color values suitable for use in visualizations.</p></li>
<li><p>show_surface: Renders 3D surfaces with optional vertex coloring and interactive features using
K3D.</p></li>
<li><p>plot_csd: Plots Current Source Density (CSD) data as a 2D image over a specified time range.</p></li>
</ul>
</section>
<section id="utilities">
<h3>Utilities:<a class="headerlink" href="#utilities" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>The module supports various color normalizations including linear, logarithmic, and diverging
scales.</p></li>
<li><p>Includes handling of edge cases and data-specific adjustments to enhance the quality of visual
outputs.</p></li>
</ul>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.color_map">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">color_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.color_map" title="Permalink to this definition">#</a></dt>
<dd><p>Return data mapped to the colormap in hexadecimal format, and a colormap for use, e.g., with
a colorbar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>iterable</em>) – 1D numerical data.</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – Number of bins in the histogram.</p></li>
<li><p><strong>vmin</strong> (<em>float</em>) – Lowest value on the histogram range.</p></li>
<li><p><strong>vmax</strong> (<em>float</em>) – Highest value on the histogram range.</p></li>
<li><p><strong>vcenter</strong> (<em>float</em><em>, </em><em>optional</em>) – Center of the histogram range (default is 0 for zero-centered color mapping).</p></li>
<li><p><strong>norm</strong> (<em>str</em>) – Type of normalization (“TS”, “N”, “LOG”).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>map_colors</strong> (<em>array-like</em>) – Data mapped to the colormap in hexadecimal format.</p></li>
<li><p><strong>cmap</strong> (<em>matplotlib.colors.Colormap</em>) – The colormap object for use with visualizations like colorbars.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function creates normalization based on the “norm” argument.</p></li>
<li><p>It generates a suitable colormap and maps data values based on histogram bins.</p></li>
<li><p>Returns RGB values for each data point, converts percent-based RGB to decimal, and then
converts RGB to hexadecimal in a format appropriate for visualization functions.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.data_to_rgb">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">data_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.data_to_rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Return RGB values of data mapped to the normalized matplotlib colormap. Optionally, return a
colormap for use, e.g., with a colorbar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>iterable</em>) – 1D numerical data.</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – Number of bins in the histogram.</p></li>
<li><p><strong>vmin</strong> (<em>float</em>) – Lowest value on the histogram range.</p></li>
<li><p><strong>vmax</strong> (<em>float</em>) – Highest value on the histogram range.</p></li>
<li><p><strong>vcenter</strong> (<em>float</em><em>, </em><em>optional</em>) – Center of the histogram range (default is 0 for zero-centered color mapping).</p></li>
<li><p><strong>ret_map</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return a colormap object.</p></li>
<li><p><strong>norm</strong> (<em>str</em>) – Type of normalization (“TS”, “N”, “LOG”).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>color_mapped</strong> (<em>array-like</em>) – RGB values mapped to the colormap for each data point.</p></li>
<li><p><strong>scalar_map</strong> (<em>matplotlib.colors.ScalarMappable, optional</em>) – The colormap object if <cite>ret_map</cite> is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function creates normalization based on the “norm” argument.</p></li>
<li><p>It generates a suitable colormap and maps data values based on histogram bins.</p></li>
<li><p>It returns RGB values for each data point.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.plot_csd">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">plot_csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RdBu_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin_vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.plot_csd" title="Permalink to this definition">#</a></dt>
<dd><p>Plot the computed Current Source Density (CSD) data.</p>
<p>This function takes a CSD matrix and plots it over a specified time range. It offers options
for color normalization, colormap selection, and including a colorbar. Optionally, it can
return plot details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>csd</strong> (<em>numpy.ndarray</em>) – The CSD matrix to be plotted, with dimensions corresponding to layers x time points.</p></li>
<li><p><strong>times</strong> (<em>numpy.ndarray</em>) – A 1D array of time points corresponding to the columns of the CSD matrix.</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em>) – The matplotlib axes object where the CSD data will be plotted.</p></li>
<li><p><strong>colorbar</strong> (<em>bool</em><em>, </em><em>optional</em>) – Flag to indicate whether a colorbar should be added to the plot. Default is True.</p></li>
<li><p><strong>cmap</strong> (<em>str</em><em>, </em><em>optional</em>) – The colormap used for plotting the CSD data. Default is “RdBu_r”.</p></li>
<li><p><strong>vmin_vmax</strong> (<em>tuple</em><em> or </em><em>str</em><em>, </em><em>optional</em>) – A tuple specifying the (vmin, vmax) range for color normalization. If “norm”, a standard
normalization is used. If None, the range is set to the maximum absolute value in the CSD
matrix. Default is None.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of layers in the CSD.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>csd_imshow</strong> – The imshow object of the plot.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>matplotlib.image.AxesImage</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function requires the ‘numpy’, ‘matplotlib.colors’, and ‘matplotlib.pyplot’ libraries.</p></li>
<li><p>The ‘TwoSlopeNorm’ from ‘matplotlib.colors’ is used for diverging color normalization.</p></li>
<li><p>The aspect ratio of the plot is automatically set to ‘auto’ for appropriate time-layer
representation.</p></li>
<li><p>Layer labels are set from 1 to n_layers</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.rgbtoint">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">rgbtoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.rgbtoint" title="Permalink to this definition">#</a></dt>
<dd><p>Return a 32-bit representation of the color as an integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rgb</strong> (<em>array-like</em>) – An integer array [R, G, B] representing the red, green, and blue color components.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>color</strong> – The 32-bit integer representation of the color.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function requires integer RGB values (0-255).</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.show_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">show_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">menu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.show_surface" title="Permalink to this definition">#</a></dt>
<dd><p>Render a 3D surface with optional data overlay. The rendering is persistent and does not
require an active kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<em>nibabel.gifti.GiftiImage</em>) – The Gifti surface mesh to be rendered.</p></li>
<li><p><strong>color</strong> (<em>array</em><em>, </em><em>optional</em>) – Basic color of the surface in the absence of data, specified as a decimal RGB array.
Default is [166, 166, 166].</p></li>
<li><p><strong>grid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Toggles the rendering of a grid. Default is False.</p></li>
<li><p><strong>menu</strong> (<em>bool</em><em>, </em><em>optional</em>) – Toggles the display of a menu with options such as lighting adjustments. Default is False.</p></li>
<li><p><strong>vertex_colors</strong> (<em>array</em><em>, </em><em>optional</em>) – An array of vertex colors specified as hexadecimal 32-bit color values. Each color
corresponds to a vertex on the surface. Default is None.</p></li>
<li><p><strong>info</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints information about the surface, such as the number of vertices. Default is
False.</p></li>
<li><p><strong>camera_view</strong> (<em>array</em><em>, </em><em>optional</em>) – Specifies a camera view for the rendering. If None, an automatic camera view is set.
Default is None.</p></li>
<li><p><strong>height</strong> (<em>int</em><em>, </em><em>optional</em>) – Height of the widget in pixels. Default is 512.</p></li>
<li><p><strong>opacity</strong> (<em>float</em><em>, </em><em>optional</em>) – Sets the opacity of the surface, with 1.0 being fully opaque and 0.0 being fully
transparent. Default is 1.0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>plot</strong> – A k3d plot object containing the rendered surface.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>k3d.plot.Plot</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function utilizes the k3d library for rendering the surface. It supports customization of
surface color, opacity, and additional features like grid and menu display. The <cite>vertex_colors</cite>
parameter allows for vertex-level color customization.</p>
</dd></dl>

</section>
<section id="module-lameg">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lameg" title="Permalink to this heading">#</a></h2>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.invert">lameg.invert module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.coregister"><code class="docutils literal notranslate"><span class="pre">coregister()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.invert_ebb"><code class="docutils literal notranslate"><span class="pre">invert_ebb()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.invert_msp"><code class="docutils literal notranslate"><span class="pre">invert_msp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.invert_sliding_window"><code class="docutils literal notranslate"><span class="pre">invert_sliding_window()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.load_source_time_series"><code class="docutils literal notranslate"><span class="pre">load_source_time_series()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.laminar">lameg.laminar module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.compute_csd"><code class="docutils literal notranslate"><span class="pre">compute_csd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.model_comparison"><code class="docutils literal notranslate"><span class="pre">model_comparison()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.roi_power_comparison"><code class="docutils literal notranslate"><span class="pre">roi_power_comparison()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.sliding_window_model_comparison"><code class="docutils literal notranslate"><span class="pre">sliding_window_model_comparison()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.simulate">lameg.simulate module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.simulate.check_inversion_exists"><code class="docutils literal notranslate"><span class="pre">check_inversion_exists()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.simulate.load_vertices"><code class="docutils literal notranslate"><span class="pre">load_vertices()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.simulate.run_current_density_simulation"><code class="docutils literal notranslate"><span class="pre">run_current_density_simulation()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.simulate.run_dipole_simulation"><code class="docutils literal notranslate"><span class="pre">run_dipole_simulation()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.surf">lameg.surf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.combine_surfaces"><code class="docutils literal notranslate"><span class="pre">combine_surfaces()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.compute_dipole_orientations"><code class="docutils literal notranslate"><span class="pre">compute_dipole_orientations()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.create_layer_mesh"><code class="docutils literal notranslate"><span class="pre">create_layer_mesh()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.create_surf_gifti"><code class="docutils literal notranslate"><span class="pre">create_surf_gifti()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.downsample_multiple_surfaces"><code class="docutils literal notranslate"><span class="pre">downsample_multiple_surfaces()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.downsample_single_surface"><code class="docutils literal notranslate"><span class="pre">downsample_single_surface()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.find_non_manifold_edges"><code class="docutils literal notranslate"><span class="pre">find_non_manifold_edges()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.fix_non_manifold_edges"><code class="docutils literal notranslate"><span class="pre">fix_non_manifold_edges()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.interpolate_data"><code class="docutils literal notranslate"><span class="pre">interpolate_data()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.iterative_downsample_single_surface"><code class="docutils literal notranslate"><span class="pre">iterative_downsample_single_surface()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.mesh_adjacency"><code class="docutils literal notranslate"><span class="pre">mesh_adjacency()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.mesh_normals"><code class="docutils literal notranslate"><span class="pre">mesh_normals()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.postprocess_freesurfer_surfaces"><code class="docutils literal notranslate"><span class="pre">postprocess_freesurfer_surfaces()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.remove_unconnected_vertices"><code class="docutils literal notranslate"><span class="pre">remove_unconnected_vertices()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.remove_vertices"><code class="docutils literal notranslate"><span class="pre">remove_vertices()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.split_fv"><code class="docutils literal notranslate"><span class="pre">split_fv()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.util">lameg.util module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.batch"><code class="docutils literal notranslate"><span class="pre">batch()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.big_brain_proportional_layer_boundaries"><code class="docutils literal notranslate"><span class="pre">big_brain_proportional_layer_boundaries()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.calc_prop"><code class="docutils literal notranslate"><span class="pre">calc_prop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.check_many"><code class="docutils literal notranslate"><span class="pre">check_many()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.convert_fsaverage_to_native"><code class="docutils literal notranslate"><span class="pre">convert_fsaverage_to_native()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.convert_native_to_fsaverage"><code class="docutils literal notranslate"><span class="pre">convert_native_to_fsaverage()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.ctf_fif_spm_conversion"><code class="docutils literal notranslate"><span class="pre">ctf_fif_spm_conversion()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_bigbrain_layer_boundaries"><code class="docutils literal notranslate"><span class="pre">get_bigbrain_layer_boundaries()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_directories"><code class="docutils literal notranslate"><span class="pre">get_directories()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_fiducial_coords"><code class="docutils literal notranslate"><span class="pre">get_fiducial_coords()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_files"><code class="docutils literal notranslate"><span class="pre">get_files()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_surface_names"><code class="docutils literal notranslate"><span class="pre">get_surface_names()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.load_meg_sensor_data"><code class="docutils literal notranslate"><span class="pre">load_meg_sensor_data()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.make_directory"><code class="docutils literal notranslate"><span class="pre">make_directory()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.spm_context"><code class="docutils literal notranslate"><span class="pre">spm_context()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.ttest_rel_corrected"><code class="docutils literal notranslate"><span class="pre">ttest_rel_corrected()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.viz">lameg.viz module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#functions">Functions:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#utilities">Utilities:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.color_map"><code class="docutils literal notranslate"><span class="pre">color_map()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.data_to_rgb"><code class="docutils literal notranslate"><span class="pre">data_to_rgb()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.plot_csd"><code class="docutils literal notranslate"><span class="pre">plot_csd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.rgbtoint"><code class="docutils literal notranslate"><span class="pre">rgbtoint()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.show_surface"><code class="docutils literal notranslate"><span class="pre">show_surface()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg">Module contents</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  
  <div class="tocsection editthispage">
    <a href="https://github.com/danclab/laMEG/edit/master/docs/_source/lameg.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

  <div class="sidebar-secondary-item">
  <div class="tocsection sourcelink">
    <a href="../_sources/_source/lameg.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2024, DANC lab.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>