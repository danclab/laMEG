

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>lameg package &#8212; laMEG 0.0.5 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_source/lameg';</script>
    <link rel="canonical" href="https://danclab.github.io/laMEG/_source/lameg.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
    <p class="title logo__title">lameg</p>
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../auto_tutorials/index.html">
                        Tutorials gallery
                      </a>
                    </li>
                

                <li class="nav-item">
                  <a class="nav-link nav-external" href="https://github.com/danclab/laMEG">
                    GitHub
                  </a>
                </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/danclab/laMEG" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/danc_labo" title="Twitter" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../auto_tutorials/index.html">
                        Tutorials gallery
                      </a>
                    </li>
                

                <li class="nav-item">
                  <a class="nav-link nav-external" href="https://github.com/danclab/laMEG">
                    GitHub
                  </a>
                </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/danclab/laMEG" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://twitter.com/danc_labo" title="Twitter" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-twitter"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">lameg package</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="lameg-package">
<h1>lameg package<a class="headerlink" href="#lameg-package" title="Permalink to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">#</a></h2>
</section>
<section id="module-lameg.invert">
<span id="lameg-invert-module"></span><h2>lameg.invert module<a class="headerlink" href="#module-lameg.invert" title="Permalink to this heading">#</a></h2>
<p>Laminar source inversion and MEG-MRI coregistration tools using SPM.</p>
<p>This module provides a high-level Python interface for performing source reconstruction
and forward modeling of MEG data via the SPM standalone engine. It supports both
Empirical Bayesian Beamformer (EBB) and Multiple Sparse Priors (MSP) algorithms,
as well as utilities for working with inversion outputs.</p>
<section id="main-functionalities">
<h3>Main functionalities<a class="headerlink" href="#main-functionalities" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>Coregistration</strong>: Aligns MEG sensor data with anatomical MRI and surface meshes,
and constructs a forward model using the Nolte single-shell approximation.</p></li>
<li><p><strong>Empirical Bayesian Beamformer (EBB)</strong>: Performs source inversion using empirical Bayesian
beamforming with cross-validation.</p></li>
<li><p><strong>Multiple Sparse Priors (MSP)</strong>: Performs sparse Bayesian inversion with optional
vertex-level priors to constrain source localization.</p></li>
<li><p><strong>Sliding-window inversion</strong>: Applies MSP within time windows to obtain time-resolved
estimates of free energy (model evidence).</p></li>
<li><p><strong>Reconstruction utilities</strong>:
- Load source-space time series from precomputed inversions or lead field matrices.
- Verify the existence of inversion structures in SPM data files.
- Extract cortical mesh vertex coordinates from forward models.</p></li>
</ul>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All inversion and coregistration routines depend on a valid SPM standalone
installation accessible via the <cite>spm_context</cite> interface.</p></li>
<li><p>Meshes must be provided through a <cite>LayerSurfaceSet</cite> object, typically containing
pial, white, and intermediate laminar surfaces.</p></li>
<li><p>This module supports both MATLAB v7.3+ (HDF5) and pre-v7.3 file formats for SPM data.</p></li>
</ul>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.check_inversion_exists">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">check_inversion_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.check_inversion_exists" title="Permalink to this definition">#</a></dt>
<dd><p>Verify the presence of source inversion data within an SPM M/EEG dataset file.</p>
<p>This function checks whether an SPM-compatible M/EEG <cite>.mat</cite> file (either v7.3+ HDF5 or
pre-v7.3 MATLAB format) contains the required inversion structure (<cite>D.other.inv</cite>), indicating
that a source reconstruction has been performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_file</strong> (<em>str</em>) – Path to the SPM M/EEG <cite>.mat</cite> file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if an inversion structure is present in the file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>KeyError</strong> – If the inversion structure is missing, indicating that source inversion has not been run
on the dataset.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Supports both MATLAB v7.3+ (HDF5) and older pre-v7.3 formats.</p></li>
<li><p>Used internally by reconstruction utilities such as <cite>load_source_time_series()</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.coregister">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">coregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fid_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('nas',</span> <span class="pre">'lpa',</span> <span class="pre">'rpa')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.coregister" title="Permalink to this definition">#</a></dt>
<dd><p>Perform MEG-MRI coregistration and compute the forward model using the Nolte single-shell
method.</p>
<p>This function uses SPM’s standalone interface to coregister MEG sensor data to the subject’s
anatomy. It constructs a forward model based on a specified laminar surface mesh (from a
LayerSurfaceSet) and fiducial-based alignment between headshape and MRI coordinates. The
laminar surface is selected by layer name, processing stage, and orientation parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fid_coords</strong> (<em>dict</em>) – Dictionary of fiducial landmark coordinates, e.g.:
<code class="docutils literal notranslate"><span class="pre">{'nas':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'lpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'rpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]}</span></code>
Values must be expressed in MEG headspace coordinates (millimeters).</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible format).</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s surface set containing laminar meshes.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Layer surface to use for forward modeling (e.g., ‘pial’, ‘white’, or fractional layer).
If None, the multilayer combined surface is used.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface mesh (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation model used for dipole alignment (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>fid_labels</strong> (<em>sequence</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – Labels for fiducial points, typically (‘nas’, ‘lpa’, ‘rpa’).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM’s coregistration and forward model visualization (default: True).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function constructs and executes an SPM batch job using the provided fiducials and
mesh information.</p></li>
<li><p>The forward model uses the <strong>Nolte single-shell</strong> MEG head model.</p></li>
<li><p>The mesh is derived from the <cite>LayerSurfaceSet</cite> and passed to SPM as a custom cortical
surface.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.get_lead_field_rms_diff">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">get_lead_field_rms_diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.get_lead_field_rms_diff" title="Permalink to this definition">#</a></dt>
<dd><p>Compute vertex-wise RMS difference of lead field vectors across cortical depths
relative to the superficial (pial) layer.</p>
<p>This function loads the forward model (gain matrix) generated by SPM and
quantifies how the lead field topographies change with cortical depth.
For each vertex, it computes the root-mean-square (RMS) difference between the
superficial (layer 1) lead field and the corresponding lead fields at deeper
layers, returning the RMS difference for the deepest layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_file</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Path to the SPM-compatible MEG dataset (.mat) for which the inversion was run.
The corresponding gain matrix file (e.g., <code class="docutils literal notranslate"><span class="pre">SPMgainmatrix_&lt;data_base&gt;_1.mat</span></code>)
is expected in the same directory.</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s laminar surface set used for forward modeling. Provides the
number of layers and vertices per layer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rms_dff</strong> – Vertex-wise RMS difference between the deepest and superficial layer lead fields.
Values reflect how much lead field topography changes with depth.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, shape (n_vertices,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The gain matrix (‘G’) is assumed to be depth-ordered, with all vertices from
layer 1 first, followed by subsequent layers.</p></li>
<li><p>RMSE is computed as the Euclidean distance between lead field vectors, averaged
across sensors.</p></li>
<li><p>The function requires a valid SPM inversion; otherwise, it will not execute.</p></li>
<li><p>Useful for assessing layer-wise forward model sensitivity and laminar
discriminability.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_ebb">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_ebb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_spatial_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_folds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ideal_pc_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.invert_ebb" title="Permalink to this definition">#</a></dt>
<dd><p>Perform Empirical Bayesian Beamformer (EBB) source inversion on MEG data.</p>
<p>This function runs the SPM EBB source reconstruction pipeline on MEG data that has already been
coregistered with an anatomical mesh. It first smooths the specified cortical or laminar mesh,
then prepares spatial and temporal modes, and finally computes source inversion using SPM’s
EBB algorithm. Optionally, it returns the full projection matrix used to reconstruct source
activity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file).</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s surface set containing laminar meshes.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Surface layer to use for inversion (e.g., ‘pial’, ‘white’, or a fractional layer).
If None, the full multilayer surface is used.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface mesh (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation model used for dipoles (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>patch_size</strong> (<em>float</em><em>, </em><em>optional</em>) – Full-width at half-maximum (FWHM) of cortical patch smoothing in millimeters (default: 5).</p></li>
<li><p><strong>n_temp_modes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of temporal modes for dimensionality reduction (default: 4).</p></li>
<li><p><strong>n_spatial_modes</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Number of spatial modes for data reduction. If None, all channels are used.</p></li>
<li><p><strong>foi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Frequency range of interest [low, high] in Hz (default: [0, 256]).</p></li>
<li><p><strong>woi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Time window of interest [start, end] in ms (default: full epoch).</p></li>
<li><p><strong>hann_windowing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Hann windowing to data before inversion (default: False).</p></li>
<li><p><strong>n_folds</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of cross-validation folds for spatial mode testing (default: 1).</p></li>
<li><p><strong>ideal_pc_test</strong> (<em>float</em><em>, </em><em>optional</em>) – Fraction of channels to leave out during cross-validation (default: 0).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM’s inversion progress and diagnostic plots (default: True).</p></li>
<li><p><strong>return_mu_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, return the full source reconstruction matrix (default: False).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – A list containing:
- free_energy : float</p>
<blockquote>
<div><p>Model evidence (free energy) from the inversion.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>cv_err<span class="classifier">float</span></dt><dd><p>Cross-validation error across data folds.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>mu_matrix<span class="classifier">scipy.sparse.csc_matrix, optional</span></dt><dd><p>Source reconstruction matrix (returned only if <cite>return_mu_matrix=True</cite>).</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The forward model must be precomputed via <cite>coregister()</cite> before calling this function.</p></li>
<li><p>Mesh smoothing uses <cite>spm_eeg_smoothmesh_multilayer_mm</cite>.</p></li>
<li><p>Spatial mode preparation and cross-validation use <cite>spm_eeg_inv_prep_modes_xval</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_msp">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_msp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_spatial_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_folds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ideal_pc_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.invert_msp" title="Permalink to this definition">#</a></dt>
<dd><p>Perform Multiple Sparse Priors (MSP) source inversion on MEG data.</p>
<p>This function runs SPM’s MSP source reconstruction pipeline using a specified cortical or
laminar surface mesh. The procedure includes mesh smoothing, spatial mode preparation, and
inversion using MSP. Optional vertex-level priors can be provided to constrain the inversion to
specific cortical patches. The MEG dataset must already be coregistered with the provided
surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file).</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s surface set containing laminar meshes.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Surface layer to use for inversion (e.g., ‘pial’, ‘white’, or a fractional layer).
If None, the full multilayer surface is used.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface mesh (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation model used for dipoles (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>priors</strong> (<em>list</em><em> of </em><em>int</em><em>, </em><em>optional</em>) – List of vertex indices to be used as MSP priors (0-based Python indexing).
If None or empty, random patches are used as priors.</p></li>
<li><p><strong>patch_size</strong> (<em>float</em><em>, </em><em>optional</em>) – Full-width at half-maximum (FWHM) of cortical patch smoothing in millimeters (default: 5).</p></li>
<li><p><strong>n_temp_modes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of temporal modes for dimensionality reduction (default: 4).</p></li>
<li><p><strong>n_spatial_modes</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Number of spatial modes for data reduction. If None, all channels are used.</p></li>
<li><p><strong>foi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Frequency range of interest [low, high] in Hz (default: [0, 256]).</p></li>
<li><p><strong>woi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Time window of interest [start, end] in ms (default: full epoch).</p></li>
<li><p><strong>hann_windowing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Hann windowing to data before inversion (default: False).</p></li>
<li><p><strong>n_folds</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of cross-validation folds for spatial mode testing (default: 1).</p></li>
<li><p><strong>ideal_pc_test</strong> (<em>float</em><em>, </em><em>optional</em>) – Fraction of channels to leave out during cross-validation (default: 0).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM’s inversion progress and diagnostic plots (default: True).</p></li>
<li><p><strong>return_mu_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, return the full source reconstruction matrix (default: False).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – A list containing:
- free_energy : float</p>
<blockquote>
<div><p>Model evidence (free energy) from the inversion.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>cv_err<span class="classifier">float</span></dt><dd><p>Cross-validation error across data folds.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>mu_matrix<span class="classifier">scipy.sparse.csc_matrix, optional</span></dt><dd><p>Source reconstruction matrix (returned only if <cite>return_mu_matrix=True</cite>).</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The forward model must be precomputed via <cite>coregister()</cite> before calling this function.</p></li>
<li><p>If <cite>priors</cite> are provided, they are converted to 1-based indices to match MATLAB conventions.</p></li>
<li><p>Mesh smoothing uses <cite>spm_eeg_smoothmesh_multilayer_mm</cite>.</p></li>
<li><p>Spatial mode preparation and cross-validation use <cite>spm_eeg_inv_prep_modes_xval</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_sliding_window">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_sliding_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_spatial_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.invert_sliding_window" title="Permalink to this definition">#</a></dt>
<dd><p>Perform Multiple Sparse Priors (MSP) source inversion over sliding time windows.</p>
<p>This function applies SPM’s MSP source reconstruction algorithm within successive overlapping
or non-overlapping time windows, enabling time-resolved estimation of source model evidence
(free energy). It smooths the surface mesh, prepares spatial modes, and repeatedly inverts the
MEG data across windows using a fixed spatial prior centered on a specified vertex. The MEG
dataset must already be coregistered with the surface mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<em>int</em>) – Index of the vertex to be used as the MSP prior (0-based Python indexing).</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file).</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s surface set containing laminar meshes.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Surface layer to use for inversion (e.g., ‘pial’, ‘white’, or a fractional layer).
If None, the full multilayer surface is used.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface mesh (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation model used for dipoles (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>patch_size</strong> (<em>float</em><em>, </em><em>optional</em>) – Full-width at half-maximum (FWHM) of cortical patch smoothing in millimeters (default: 5).</p></li>
<li><p><strong>n_temp_modes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of temporal modes for dimensionality reduction (default: 1).</p></li>
<li><p><strong>n_spatial_modes</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Number of spatial modes for data reduction. If None, all channels are used.</p></li>
<li><p><strong>win_size</strong> (<em>float</em><em>, </em><em>optional</em>) – Duration of each sliding window in milliseconds (default: 50).</p></li>
<li><p><strong>win_overlap</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether consecutive windows overlap (default: True).</p></li>
<li><p><strong>foi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Frequency range of interest [low, high] in Hz (default: [0, 256]).</p></li>
<li><p><strong>hann_windowing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to apply Hann windowing to each window before inversion (default: True).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM’s inversion progress and diagnostic plots (default: True).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> – A list containing:
- free_energy : ndarray</p>
<blockquote>
<div><p>Array of model evidence (free energy) values across time windows.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>wois<span class="classifier">ndarray, shape (n_windows, 2)</span></dt><dd><p>Time windows of interest in milliseconds.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The forward model must be precomputed via <cite>coregister()</cite> before calling this function.</p></li>
<li><p>The <cite>prior</cite> index is internally converted to 1-based indexing for MATLAB compatibility.</p></li>
<li><p>Mesh smoothing uses <cite>spm_eeg_smoothmesh_multilayer_mm</cite>.</p></li>
<li><p>Spatial mode preparation uses <cite>spm_eeg_inv_prep_modes_xval</cite>.</p></li>
<li><p>Each windowed inversion uses the <strong>Multiple Sparse Priors (MSP)</strong> algorithm in SPM.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.load_forward_model_vertices">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">load_forward_model_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.load_forward_model_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>Load the vertex coordinates from the forward model stored in an SPM M/EEG dataset.</p>
<p>This function extracts the cortical mesh vertices used in the forward model from an
SPM-compatible <cite>.mat</cite> file, supporting both MATLAB v7.3+ (HDF5) and legacy pre-v7.3 formats.
The returned array contains the vertex coordinates in MNI space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_file</strong> (<em>str</em>) – Path to the SPM M/EEG <cite>.mat</cite> file containing the forward model.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of vertex coordinates (n_vertices × 3) in MNI space.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the file cannot be read as a valid MATLAB file.</p></li>
<li><p><strong>KeyError</strong> – If the forward model or vertex data is missing from the file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>For MATLAB v7.3+ files, the function reads directly from the HDF5 hierarchy:
<cite>D/other/inv/mesh/tess_mni/vert</cite>.</p></li>
<li><p>For older MATLAB formats, it accesses the corresponding nested struct fields.</p></li>
<li><p>Typically used after source inversion to recover the 3D cortical geometry associated
with the lead field model.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.load_source_time_series">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">load_source_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.invert.load_source_time_series" title="Permalink to this definition">#</a></dt>
<dd><p>Load or compute source-space time series from MEG data.</p>
<p>This function reconstructs source-level activity either from precomputed inverse solutions
(stored in the MEG data file or an external inversion file) or directly from a provided
forward/inverse matrix (<cite>mu_matrix</cite>). Optionally, the reconstruction can be restricted to a
subset of vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file).</p></li>
<li><p><strong>mu_matrix</strong> (<em>np.ndarray</em><em> or </em><em>scipy.sparse matrix</em><em>, </em><em>optional</em>) – Precomputed source reconstruction matrix (sources × sensors). If provided, this matrix is
used directly to compute source time series. Default is None.</p></li>
<li><p><strong>inv_fname</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to a file containing the precomputed inverse solution. If None, the inversion stored
within <cite>data_fname</cite> is used. Default is None.</p></li>
<li><p><strong>vertices</strong> (<em>list</em><em> of </em><em>int</em><em>, </em><em>optional</em>) – List of vertex indices to extract source time series from. If None, all vertices are used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>source_ts</strong> (<em>np.ndarray</em>) – Source-space time series (sources × time × trial).</p></li>
<li><p><strong>time</strong> (<em>np.ndarray</em>) – Time vector in milliseconds.</p></li>
<li><p><strong>mu_matrix</strong> (<em>np.ndarray or scipy.sparse matrix</em>) – Matrix used to reconstruct source activity from sensor data.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If both <cite>mu_matrix</cite> and <cite>inv_fname</cite> are None, the function attempts to load the inverse
solution embedded in <cite>data_fname</cite>.</p></li>
<li><p>When <cite>vertices</cite> is specified, only the corresponding subset of the inverse matrix is used.</p></li>
<li><p>Supports both single-trial and multi-trial MEG data structures.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.laminar">
<span id="lameg-laminar-module"></span><h2>lameg.laminar module<a class="headerlink" href="#module-lameg.laminar" title="Permalink to this heading">#</a></h2>
<p>Laminar analysis tools for MEG source reconstruction and depth-resolved model comparison.</p>
<p>This module provides functions for performing and evaluating laminar source reconstructions of MEG
data using SPM. It integrates surface-based forward models, inversion algorithms, and analytical
tools for quantifying laminar-specific neural activity. The main focus is on comparing model
evidence across cortical depths, estimating current source density profiles, and identifying
regions of interest showing laminar modulation in power.</p>
<section id="key-functionalities">
<h3>Key functionalities<a class="headerlink" href="#key-functionalities" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>Model comparison:</strong> Run Empirical Bayesian Beamformer (EBB) or Multiple Sparse Priors (MSP)
inversions across cortical layers and compare model fits using free energy or cross-validation.</p></li>
<li><p><strong>Sliding-window inversions:</strong> Estimate time-resolved laminar model evidence to capture dynamic
changes in cortical processing.</p></li>
<li><p><strong>Current source density (CSD):</strong> Compute laminar CSD profiles using the <em>StandardCSD</em> method
from the <em>elephant</em> library, with optional layer-wise interpolation.</p></li>
<li><p><strong>ROI analysis:</strong> Identify regions of interest based on layer-specific power modulations between
task and baseline periods.</p></li>
</ul>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All inversion routines depend on SPM’s standalone interface for forward modeling and source
reconstruction.</p></li>
<li><p>Surface geometry and layer definitions are handled through <cite>LayerSurfaceSet</cite> objects.</p></li>
</ul>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.compute_csd">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">compute_csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sfreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.compute_csd" title="Permalink to this definition">#</a></dt>
<dd><p>Compute laminar current source density (CSD) from multi-layer neural signals.</p>
<p>This function estimates the CSD profile across cortical depth using the <strong>Standard CSD</strong>
method from the <em>elephant</em> library. It takes a laminar time series (layers × time) and the
cortical thickness, producing a layer-resolved CSD estimate. An optional interpolation step
provides smooth CSD profiles across layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>numpy.ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_layers</em><em>, </em><em>n_times</em><em>)</em>) – Laminar neural signal (e.g., field potential or current) with layers along the first axis
and time along the second.</p></li>
<li><p><strong>thickness</strong> (<em>float</em>) – Cortical thickness in millimeters.</p></li>
<li><p><strong>sfreq</strong> (<em>float</em>) – Sampling frequency of the signal in Hertz.</p></li>
<li><p><strong>smoothing</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Interpolation method for layer-wise smoothing (e.g., ‘linear’, ‘cubic’, ‘quadratic’).
If None, no smoothing is applied. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>ret_vals</strong> – A list containing:
- <cite>csd</cite> : ndarray</p>
<blockquote>
<div><p>The computed current source density (layers × time).</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt><cite>smoothed_csd</cite><span class="classifier">ndarray, optional</span></dt><dd><p>Smoothed CSD (500 interpolated layers × time), returned if <cite>smoothing</cite> is specified.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>CSD is estimated using <cite>elephant.current_source_density.estimate_csd</cite> with the
<em>StandardCSD</em> method.</p></li>
<li><p>The top and bottom two layers are zeroed to reduce boundary artifacts.</p></li>
<li><p>Smoothing is performed independently across layers for each time point using
<cite>scipy.interpolate.interp1d</cite>.</p></li>
<li><p>Input signals should be continuous and aligned across layers (no missing samples).</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.model_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">model_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fid_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'EBB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coregister_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.model_comparison" title="Permalink to this definition">#</a></dt>
<dd><p>Perform laminar model comparison by evaluating free energy and/or cross-validation error across
cortical surfaces.</p>
<p>This function coregisters MEG data to a subject’s anatomical MRI and performs source
reconstruction separately on each layer within a <cite>LayerSurfaceSet</cite>, using either the
Empirical Bayesian Beamformer (EBB) or Multiple Sparse Priors (MSP) algorithm. It returns
the free energy and cross-validation error for each layer, enabling laminar model comparison
based on model evidence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fid_coords</strong> (<em>dict</em>) – Dictionary of fiducial landmark coordinates, e.g.:
<code class="docutils literal notranslate"><span class="pre">{'nas':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'lpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'rpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]}</span></code>
Values must be expressed in MEG headspace coordinates (millimeters).</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file).</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s surface set containing laminar meshes (e.g., pial, white, intermediate).</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Surface mesh processing stage (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Dipole orientation model used for inversion (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>method</strong> (<em>{'EBB'</em><em>, </em><em>'MSP'}</em><em>, </em><em>optional</em>) – Source reconstruction method to use (default: ‘EBB’).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM visualizations during coregistration and inversion (default: True).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
<li><p><strong>coregister_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional keyword arguments passed to the <cite>coregister()</cite> function.</p></li>
<li><p><strong>invert_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional keyword arguments passed to the selected inversion function (<cite>invert_ebb()</cite> or
<cite>invert_msp()</cite>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f_vals</strong> (<em>np.ndarray</em>) – Array of free energy values (one per layer), representing model evidence.</p></li>
<li><p><strong>cv_errs</strong> (<em>np.ndarray</em>) – Array of cross-validation errors corresponding to each layer.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function iterates over all layer surfaces defined in <cite>surf_set</cite>.</p></li>
<li><p>Free energy serves as a quantitative parametric model comparison metric, with higher values
indicating better model evidence.</p></li>
<li><p>Cross-validation serves as a quantitative nonparameteric model comparison metric, with lower
values indicating better model evidence.</p></li>
<li><p>Requires prior generation of laminar surfaces and preprocessing of MEG data into
SPM-compatible format.</p></li>
<li><p>Uses the Nolte single-shell MEG forward model as defined in SPM.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.roi_power_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">roi_power_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_woi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc_thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.roi_power_comparison" title="Permalink to this definition">#</a></dt>
<dd><p>Compute laminar power changes and identify or reuse regions of interest (ROIs) based on
layer-specific modulation.</p>
<p>This function quantifies power changes between a window of interest (WOI) and a baseline
window in both pial and white matter layers. If no ROI indices are provided, it identifies
spatial regions showing significant power modulation relative to baseline by applying a
percentile threshold to vertex-wise t-statistics. If <cite>roi_idx</cite> is provided, only those
vertices are loaded and processed, bypassing ROI computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file) containing source time series.</p></li>
<li><p><strong>woi</strong> (<em>tuple</em><em> of </em><em>float</em>) – Window of interest in milliseconds, specified as (start, end).</p></li>
<li><p><strong>baseline_woi</strong> (<em>tuple</em><em> of </em><em>float</em>) – Baseline window in milliseconds, specified as (start, end), used for power normalization.</p></li>
<li><p><strong>perc_thresh</strong> (<em>float</em>) – Percentile threshold (0-100) for defining significant power changes when <cite>roi_idx</cite> is None.</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – Subject’s laminar surface set containing pial and white matter meshes.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Surface mesh processing stage (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Dipole orientation model used for inversion (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>mu_matrix</strong> (<em>np.ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Precomputed source reconstruction matrix. If None, it is derived automatically from
inversion data (default: None).</p></li>
<li><p><strong>chunk_size</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of vertices processed per iteration to optimize memory usage (default: 1000).</p></li>
<li><p><strong>roi_idx</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Indices of vertices defining a precomputed ROI. If provided, only those vertices are
loaded and analyzed; otherwise, ROIs are computed from all vertices based on <cite>perc_thresh</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>laminar_t_statistic</strong> (<em>np.ndarray</em>) – Paired-sample t-statistic comparing absolute power modulation between pial and white
matter layers within the ROI.</p></li>
<li><p><strong>laminar_p_value</strong> (<em>np.ndarray</em>) – Corresponding p-value of the laminar t-test.</p></li>
<li><p><strong>deg_of_freedom</strong> (<em>int</em>) – Degrees of freedom for the laminar comparison.</p></li>
<li><p><strong>roi_idx</strong> (<em>np.ndarray</em>) – Indices of vertices defining the analyzed ROI (either computed or provided).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Power is computed as the variance of source time series within the specified time windows.</p></li>
<li><p>Relative power change is calculated as (WOI - baseline) / baseline per trial and vertex.</p></li>
<li><p>If <cite>roi_idx</cite> is None, the function computes vertex-wise t-statistics between WOI and
baseline power, then selects vertices exceeding the given percentile threshold.</p></li>
<li><p>If <cite>roi_idx</cite> is provided, only those vertices are loaded and processed, greatly improving
performance for small ROIs.</p></li>
<li><p>The resulting laminar statistics quantify whether activation is preferentially expressed
in superficial (pial) or deep (white matter) layers within the ROI.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.sliding_window_model_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">sliding_window_model_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coregister_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.laminar.sliding_window_model_comparison" title="Permalink to this definition">#</a></dt>
<dd><p>Perform laminar model comparison over time using sliding-window MSP inversions.</p>
<p>This function performs time-resolved source reconstruction across multiple laminar surfaces
using the Multiple Sparse Priors (MSP) algorithm within sliding time windows. For each layer
in a <cite>LayerSurfaceSet</cite>, the function coregisters MEG data to the MRI, performs MSP inversion
over successive windows, and computes the corresponding free energy values. The result is a
layer-by-time representation of model evidence, suitable for laminar model comparison.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<em>int</em>) – Index of the vertex to be used as the MSP prior (0-based Python indexing).</p></li>
<li><p><strong>fid_coords</strong> (<em>dict</em>) – Dictionary of fiducial landmark coordinates, e.g.:
<code class="docutils literal notranslate"><span class="pre">{'nas':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'lpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'rpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]}</span></code>
Values must be expressed in MEG headspace coordinates (millimeters).</p></li>
<li><p><strong>data_fname</strong> (<em>str</em>) – Path to the MEG dataset (SPM-compatible .mat file).</p></li>
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – The subject’s surface set containing laminar meshes (e.g., pial, white, intermediate).</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Surface mesh processing stage (default: ‘ds’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Dipole orientation model used for inversion (default: ‘link_vector’).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use fixed dipole orientations across layers (default: True).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display SPM visualizations during coregistration and inversion (default: True).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
<li><p><strong>coregister_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional keyword arguments passed to the <cite>coregister()</cite> function.</p></li>
<li><p><strong>invert_kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional keyword arguments passed to the <cite>invert_sliding_window()</cite> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>f_vals</strong> (<em>np.ndarray, shape (n_layers, n_windows)</em>) – Free energy values for each layer and time window.</p></li>
<li><p><strong>wois</strong> (<em>np.ndarray, shape (n_windows, 2)</em>) – Time windows of interest in milliseconds.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function applies the <strong>Multiple Sparse Priors (MSP)</strong> algorithm within sliding time
windows, providing dynamic estimates of model evidence.</p></li>
<li><p>Free energy serves as a model comparison metric across both depth and time; higher values
indicate better model evidence.</p></li>
<li><p>The <cite>prior</cite> index is internally adjusted to match MATLAB’s 1-based indexing convention.</p></li>
<li><p>Requires prior MEG-MRI coregistration via <cite>coregister()</cite>.</p></li>
<li><p>Typically used to examine how laminar model evidence evolves during task-related dynamics.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.simulate">
<span id="lameg-simulate-module"></span><h2>lameg.simulate module<a class="headerlink" href="#module-lameg.simulate" title="Permalink to this heading">#</a></h2>
<p>Simulation tools for MEG data generation using SPM.</p>
<p>This module provides functions for generating synthetic MEG datasets based on user-specified
source parameters and an existing SPM forward model. It enables controlled simulations of both
current density fields and discrete dipoles, with configurable spatial, temporal, and noise
properties. These simulations are intended for testing source reconstruction pipelines, validating
laminar inversion methods, and assessing model sensitivity under known ground truth conditions.</p>
<section id="id1">
<h3>Key functionalities<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>Current density simulations:</strong> Generate distributed cortical activity from one or more
vertices with specified dipole moments, patch sizes, and time series, projected through the
SPM forward model.</p></li>
<li><p><strong>Dipole simulations:</strong> Create focal dipolar sources with defined orientations, amplitudes,
and spatial extents, optionally unique across trials.</p></li>
<li><p><strong>Noise control:</strong> Inject Gaussian sensor noise to achieve a user-defined signal-to-noise ratio
(SNR).</p></li>
<li><p><strong>Trial averaging:</strong> Automatically perform trial-level averaging via SPM’s <cite>spm_eeg_averaging</cite>.</p></li>
</ul>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All simulations require a valid SPM M/EEG dataset containing a forward model.</p></li>
<li><p>Both single- and multi-source simulations are supported.</p></li>
<li><p>The generated data can be used to benchmark inversion algorithms (e.g., EBB, MSP),
estimate laminar sensitivity, or evaluate spatial leakage and depth bias.</p></li>
<li><p>Simulations are executed via SPM’s <cite>spm_eeg_simulate</cite> interface, which ensures
biophysically realistic projection of cortical activity to MEG sensors.</p></li>
</ul>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.run_current_density_simulation">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">run_current_density_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_signals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_moments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_patch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_trials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.simulate.run_current_density_simulation" title="Permalink to this definition">#</a></dt>
<dd><p>Simulate laminar current density data using SPM’s MEG forward model.</p>
<p>This function generates synthetic MEG datasets by projecting user-defined source time series
(signals) from specified cortical vertices through an existing SPM forward model. Each
simulated source is defined by its vertex location, dipole moment, and patch extent. Gaussian
noise is added at the sensor level to achieve the desired signal-to-noise ratio (SNR), and the
simulated data can optionally be averaged across trials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_file</strong> (<em>str</em>) – Path to an existing SPM M/EEG <cite>.mat</cite> file containing a valid forward model, used as the
simulation template.</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – Prefix for the output simulated dataset (e.g., ‘<a href="#id5"><span class="problematic" id="id6">sim_</span></a>’).</p></li>
<li><p><strong>sim_vertices</strong> (<em>int</em><em> or </em><em>list</em><em> of </em><em>int</em>) – Indices of source vertices (0-based) defining the locations of simulated current sources.</p></li>
<li><p><strong>sim_signals</strong> (<em>np.ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_sources</em><em>, </em><em>n_times</em><em>)</em>) – Time series of the simulated source activity for each vertex.</p></li>
<li><p><strong>dipole_moments</strong> (<em>float</em><em> or </em><em>list</em><em> of </em><em>float</em>) – Dipole moments (in nA·m) associated with each simulated source.</p></li>
<li><p><strong>sim_patch_sizes</strong> (<em>float</em><em> or </em><em>list</em><em> of </em><em>float</em>) – Patch sizes (in mm) around each vertex that define spatial spread of the simulated sources.</p></li>
<li><p><strong>snr</strong> (<em>float</em>) – Desired signal-to-noise ratio at the sensor level (in dB).</p></li>
<li><p><strong>sim_woi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Window of interest for the simulation, specified as [start, end] in milliseconds.
Default is [-np.inf, np.inf].</p></li>
<li><p><strong>average_trials</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to average across simulated trials (default: False).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sim_fname</strong> – Full path to the generated simulated MEG dataset (<cite>.mat</cite> file).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Uses SPM’s <cite>spm_eeg_simulate</cite> function to project source-level activity through the forward
model and add Gaussian noise.</p></li>
<li><p>Supports both single and multiple simulated sources with different dipole moments or spatial
extents.</p></li>
<li><p>The forward model (lead field) must be precomputed and stored within <cite>data_file</cite>.</p></li>
<li><p>If <cite>average_trials=True</cite>, the simulated data are averaged using SPM’s <cite>spm_eeg_averaging</cite>
routine and saved with prefix <cite>‘m’</cite>.</p></li>
<li><p>This function is useful for validating inversion methods, testing model recovery, and
quantifying depth sensitivity under controlled SNR conditions.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.run_dipole_simulation">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">run_dipole_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_signals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_orientations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_moments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_patch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_trials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.simulate.run_dipole_simulation" title="Permalink to this definition">#</a></dt>
<dd><p>Simulate dipole-level MEG data using SPM’s forward model.</p>
<p>This function generates synthetic MEG datasets by projecting source-level dipole activity
through an existing SPM forward model. Each dipole is defined by its cortical vertex location,
orientation, moment, and patch extent. The resulting MEG data are corrupted with Gaussian
noise at the sensor level to achieve a specified signal-to-noise ratio (SNR), and can
optionally be averaged across trials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_file</strong> (<em>str</em>) – Path to an existing SPM M/EEG <cite>.mat</cite> file containing a valid forward model, used as the
simulation template.</p></li>
<li><p><strong>prefix</strong> (<em>str</em>) – Prefix for the output simulated dataset (e.g., <cite>‘sim_’</cite>).</p></li>
<li><p><strong>sim_vertices</strong> (<em>int</em><em> or </em><em>list</em><em> of </em><em>int</em>) – Indices of source vertices (0-based) where dipoles are positioned.</p></li>
<li><p><strong>sim_signals</strong> (<em>np.ndarray</em>) – Array of simulated dipole time courses, either shaped (n_dipoles × n_times) or
(n_dipoles × n_times × n_trials).</p></li>
<li><p><strong>dipole_orientations</strong> (<em>np.ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_dipoles</em><em>, </em><em>3</em><em>)</em>) – Array specifying the 3D orientation vector for each dipole in head coordinates.</p></li>
<li><p><strong>dipole_moments</strong> (<em>float</em><em> or </em><em>list</em><em> of </em><em>float</em>) – Dipole moments (in nA·m) for each simulated source.</p></li>
<li><p><strong>sim_patch_sizes</strong> (<em>float</em><em> or </em><em>list</em><em> of </em><em>float</em>) – Spatial extent of the simulated dipole patch (in mm).</p></li>
<li><p><strong>snr</strong> (<em>float</em>) – Desired signal-to-noise ratio at the sensor level (in dB).</p></li>
<li><p><strong>sim_woi</strong> (<em>list</em><em> of </em><em>float</em><em>, </em><em>optional</em>) – Simulation window of interest, specified as [start, end] in milliseconds.
Default is [-np.inf, np.inf].</p></li>
<li><p><strong>average_trials</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to average the simulated data over trials (default: False).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>sim_fname</strong> – Full path to the generated simulated MEG dataset (<cite>.mat</cite> file).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Uses SPM’s <cite>spm_eeg_simulate</cite> function to generate sensor-level data from specified dipole
configurations.</p></li>
<li><p>Supports multiple dipoles with distinct orientations, moments, or spatial extents.</p></li>
<li><p>The forward model (<cite>lead field</cite>) must already exist in <cite>data_file</cite>.</p></li>
<li><p>If <cite>average_trials=True</cite>, trial-averaged data are computed via SPM’s
<cite>spm_eeg_averaging</cite> and saved with the <cite>‘m’</cite> prefix.</p></li>
<li><p>This function is primarily used for testing inversion accuracy, source localization
performance, and evaluating laminar sensitivity under controlled SNR conditions.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.surf">
<span id="lameg-surf-module"></span><h2>lameg.surf module<a class="headerlink" href="#module-lameg.surf" title="Permalink to this heading">#</a></h2>
<p>Tools for generating, managing, and postprocessing laminar cortical surfaces.</p>
<p>This module implements a complete workflow for constructing, manipulating, and visualizing
laminar surface meshes derived from FreeSurfer reconstructions. It provides a high-level API
for end-to-end postprocessing, including coordinate transformations, hemisphere merging,
downsampling, and computation of laminar dipole orientations.</p>
<section id="public-api">
<h3>Public API<a class="headerlink" href="#public-api" title="Permalink to this heading">#</a></h3>
</section>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this heading">#</a></h3>
<dl class="simple">
<dt>LayerSurfaceSet</dt><dd><p>High-level interface for organizing, validating, and manipulating laminar surface hierarchies.</p>
</dd>
</dl>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading">#</a></h3>
<dl class="simple">
<dt>interpolate_data</dt><dd><p>Interpolate scalar or vector data between aligned surface meshes.</p>
</dd>
<dt>convert_fsaverage_to_native</dt><dd><p>Convert vertices from the fsaverage template space into the subject’s native surface space.</p>
</dd>
<dt>convert_native_to_fsaverage</dt><dd><p>Convert vertices from a subject’s native space to the fsaverage template.</p>
</dd>
</dl>
<p>Internal utilities handle surface file I/O, mesh decimation, transformation tracking, and
FreeSurfer compatibility.</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">LayerSurfaceSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subjects_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Object-oriented interface for managing subject-specific laminar cortical surfaces.</p>
<p>This class provides standardized access to the laminar surface hierarchy generated from
FreeSurfer reconstructions, stored under:</p>
<blockquote>
<div><p>$SUBJECTS_DIR/&lt;subj_id&gt;/surf/laminar</p>
</div></blockquote>
<p>It handles file naming, metadata sidecars, validation, and mappings between processing stages
(e.g., ‘converted’ -&gt; ‘nodeep’ -&gt; ‘combined’ -&gt; ‘ds’). The class also provides convenience
functions for loading, saving, and verifying consistency across layers and hemispheres.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – Subject identifier corresponding to the FreeSurfer reconstruction directory.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of cortical layers (including white and pial surfaces).</p></li>
<li><p><strong>subjects_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to the FreeSurfer SUBJECTS_DIR. If None, it is read from the environment variable.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.subj_id">
<span class="sig-name descname"><span class="pre">subj_id</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.subj_id" title="Permalink to this definition">#</a></dt>
<dd><p>The subject identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.n_layers">
<span class="sig-name descname"><span class="pre">n_layers</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.n_layers" title="Permalink to this definition">#</a></dt>
<dd><p>Number of layers managed by this surface set.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.layer_spacing">
<span class="sig-name descname"><span class="pre">layer_spacing</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.layer_spacing" title="Permalink to this definition">#</a></dt>
<dd><p>Proportional thickness values between 0 (white matter) and 1 (pial).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.subjects_dir">
<span class="sig-name descname"><span class="pre">subjects_dir</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.subjects_dir" title="Permalink to this definition">#</a></dt>
<dd><p>Path to the FreeSurfer subjects directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.subj_dir">
<span class="sig-name descname"><span class="pre">subj_dir</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.subj_dir" title="Permalink to this definition">#</a></dt>
<dd><p>Path to the subject’s directory within SUBJECTS_DIR.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.mri_file">
<span class="sig-name descname"><span class="pre">mri_file</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.mri_file" title="Permalink to this definition">#</a></dt>
<dd><p>Path to the subject’s mri/orig.nii, converted from mri/orig.mgz</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.surf_dir">
<span class="sig-name descname"><span class="pre">surf_dir</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.surf_dir" title="Permalink to this definition">#</a></dt>
<dd><p>Path to the subject’s FreeSurfer surface directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.laminar_surf_dir">
<span class="sig-name descname"><span class="pre">laminar_surf_dir</span></span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.laminar_surf_dir" title="Permalink to this definition">#</a></dt>
<dd><p>Path to the laminar surface output directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<ul>
<li><dl class="simple">
<dt>File naming follows the convention:</dt><dd><p>&lt;hemi&gt;.&lt;layer&gt;.&lt;stage&gt;[.&lt;orientation&gt;[.&lt;fixed&gt;]].gii</p>
</dd>
</dl>
<p>where each stage represents a processing step (e.g., ‘raw’, ‘converted’, ‘nodeep’,
‘combined’, ‘ds’).</p>
</li>
<li><p>JSON sidecars store transformation matrices, removed vertices, and other metadata.</p></li>
<li><p>The class provides validation and mapping functions to ensure geometric and topological
consistency across all processing stages.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subjects_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize a <cite>LayerSurfaceSet</cite> instance for a given subject.</p>
<p>This constructor sets up paths and metadata for managing laminar surface files
derived from a FreeSurfer reconstruction. It verifies the existence of the subject
directory and defines the expected hierarchy under <cite>$SUBJECTS_DIR/&lt;subj_id&gt;/surf/laminar</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – Subject identifier corresponding to the FreeSurfer reconstruction directory.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em>) – Number of cortical layers (including pial and white matter surfaces).</p></li>
<li><p><strong>subjects_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to the FreeSurfer <cite>SUBJECTS_DIR</cite>. If not provided, the environment variable
<cite>SUBJECTS_DIR</cite> is used.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EnvironmentError</strong> – If neither <cite>subjects_dir</cite> is provided nor the environment variable <cite>SUBJECTS_DIR</cite>
is set.</p></li>
<li><p><strong>FileNotFoundError</strong> – If the subject directory does not exist or if FreeSurfer reconstruction outputs
are missing.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>The laminar surface directory is assumed to be located at:</dt><dd><p>$SUBJECTS_DIR/&lt;subj_id&gt;/surf/laminar</p>
</dd>
</dl>
</li>
<li><p>The cortical layer spacing is defined linearly from white matter (0.0) to pial (1.0).</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.compute_dipole_orientations">
<span class="sig-name descname"><span class="pre">compute_dipole_orientations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.compute_dipole_orientations" title="Permalink to this definition">#</a></dt>
<dd><p>Compute vertex-wise dipole orientation vectors for all cortical layers.</p>
<p>This function estimates dipole orientations using one of several geometric methods applied
to the laminar surface set. Depending on the method, orientations may be derived from
vertex correspondence between pial and white surfaces or from local surface normals.
Optionally, orientations can be fixed across layers, ensuring consistent directionality
between homologous vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>{'link_vector'</em><em>, </em><em>'ds_surf_norm'</em><em>, </em><em>'orig_surf_norm'</em><em>, </em><em>'cps'}</em>) – <dl class="simple">
<dt>Algorithm used to compute dipole orientations:</dt><dd><ul>
<li><p><strong>’link_vector’</strong> - vectors connecting pial and white vertices.</p></li>
<li><p><strong>’ds_surf_norm’</strong> - surface normals computed from the downsampled surfaces.</p></li>
<li><p><strong>’orig_surf_norm’</strong> - normals from original (combined) surfaces, mapped to the
downsampled meshes.</p></li>
<li><p><strong>’cps’</strong> - cortical patch statistics; averages of original-surface normals for
vertices mapped to each downsampled vertex.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True (default), the orientation vectors from the pial surface are reused for all
layers, ensuring layer-consistent directionality. If False, orientations are computed
separately for each layer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>orientations</strong> – Array of shape (n_layers, n_vertices, 3) containing normalized dipole orientation
vectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the pial and white surfaces have mismatched vertex counts when using the
‘link_vector’ method.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All orientation vectors are normalized to unit length.</p></li>
<li><p>For ‘orig_surf_norm’ and ‘cps’, geometric mapping between stages is computed using
nearest-neighbour search.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.create">
<span class="sig-name descname"><span class="pre">create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.create" title="Permalink to this definition">#</a></dt>
<dd><p>Postprocess and combine FreeSurfer cortical surface meshes for laminar analysis.</p>
<p>This function reconstructs a complete laminar surface hierarchy for a given FreeSurfer
subject. It generates intermediate cortical layers between the pial and white matter
surfaces, converts all surfaces to GIFTI format, aligns them to scanner RAS coordinates,
removes deep-cut vertices, combines hemispheres, performs mesh decimation, and computes
dipole orientation vectors. The resulting downsampled, orientation-annotated multilayer
surfaces are stored in:
<code class="docutils literal notranslate"><span class="pre">$SUBJECTS_DIR/&lt;subj_id&gt;/surf/laminar</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ds_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Fraction of vertices to retain during mesh decimation (default: 0.1).</p></li>
<li><p><strong>orientation</strong> (<em>{'link_vector'</em><em>, </em><em>'ds_surf_norm'</em><em>, </em><em>'orig_surf_norm'</em><em>, </em><em>'cps'}</em><em>, </em><em>optional</em>) – <dl class="simple">
<dt>Method used to compute dipole orientations:</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'link_vector'</span></code>: vectors connecting pial - white vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'ds_surf_norm'</span></code>: surface normals from downsampled meshes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'orig_surf_norm'</span></code>: surface normals from original combined meshes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'cps'</span></code>: cortical patch statistics (mean local normals).</p></li>
</ul>
</dd>
</dl>
<p>Default is <code class="docutils literal notranslate"><span class="pre">'link_vector'</span></code>.</p>
</p></li>
<li><p><strong>fix_orientation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, enforces consistent orientation across layers by copying pial-layer normals
to all other layers (default: True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of parallel jobs used when generating intermediate surfaces (default: -1 for all
cores).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed
after execution.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>EnvironmentError</strong> – If required FreeSurfer binaries (<code class="docutils literal notranslate"><span class="pre">mris_convert</span></code>, <code class="docutils literal notranslate"><span class="pre">mris_inflate</span></code>, <code class="docutils literal notranslate"><span class="pre">mri_info</span></code>)
are not found in the system PATH.</p></li>
<li><p><strong>FileNotFoundError</strong> – If the subject directory or expected FreeSurfer files are missing.</p></li>
<li><p><strong>ValueError</strong> – If validation fails due to vertex count mismatches across layers or hemispheres.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Requires that FreeSurfer’s <code class="docutils literal notranslate"><span class="pre">$SUBJECTS_DIR</span></code> environment variable is set and
<code class="docutils literal notranslate"><span class="pre">recon-all</span></code> has completed successfully for <code class="docutils literal notranslate"><span class="pre">subj_id</span></code>.</p></li>
<li><p>Surface metadata JSON files record coordinate transformations, removed vertices,
downsampling ratios, and orientation method parameters.</p></li>
<li><p>Downsampling and orientation computation are applied identically across all layers
to preserve laminar alignment.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.downsample">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.downsample" title="Permalink to this definition">#</a></dt>
<dd><p>Downsample all combined cortical surface meshes using the VTK decimation algorithm.</p>
<p>This function applies geometric mesh reduction to each combined surface (including all
laminar layers and the inflated mesh) using the <cite>vtkDecimatePro</cite> algorithm. The first
surface in the sequence defines the downsampling vertex mapping, which is then applied to
all other surfaces to ensure topological and vertex-wise correspondence across layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ds_factor</strong> (<em>float</em>) – Fraction of vertices to retain during decimation (e.g., 0.1 retains 10% of vertices).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed
after execution.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The vertex mapping from the first (reference) surface is reused for all other layers to
maintain laminar alignment.</p></li>
<li><p>Downsampling removes redundant vertices while preserving overall cortical geometry.</p></li>
<li><p>If vertex normals are present in the input GIFTI files, they are resampled and stored in
the output surfaces.</p></li>
<li><dl class="simple">
<dt>Metadata for each surface includes:</dt><dd><ul>
<li><p><cite>‘ds_factor’</cite> - the applied decimation ratio.</p></li>
<li><p><cite>‘ds_removed_vertices’</cite> - indices of removed vertices in the original mesh.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Downsampled surfaces are saved under the <cite>‘ds’</cite> stage within the laminar directory.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">_iterative_downsample_single_surface</span></code></dt><dd><p>Performs per-surface iterative decimation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">_fix_non_manifold_edges</span></code></dt><dd><p>Repairs topological defects introduced by downsampling.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">_create_surf_gifti</span></code></dt><dd><p>Creates a valid GIFTI surface from vertices and faces.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">surf_set</span> <span class="o">=</span> <span class="n">LayerSurfaceSet</span><span class="p">(</span><span class="s1">&#39;sub-01&#39;</span><span class="p">,</span> <span class="n">n_layers</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surf_set</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_bigbrain_layer_boundaries">
<span class="sig-name descname"><span class="pre">get_bigbrain_layer_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_bigbrain_layer_boundaries" title="Permalink to this definition">#</a></dt>
<dd><p>Map BigBrain proportional layer boundaries into the subject’s downsampled surface space.</p>
<p>This function retrieves the laminar boundary proportions defined in the BigBrain
histological atlas and projects them into the subject’s cortical geometry by mapping
through fsaverage correspondence. It returns the proportional depth boundaries (0-1 range)
of the six cortical layers for each vertex in the subject’s surface space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subj_coord</strong> (<em>array-like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Optional array of vertex coordinates (n_vertices × 3) in the subject’s native space.
If None, mapping is performed for all vertices of the subject’s pial surface.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>layer_boundaries</strong> – Array of proportional cortical layer boundaries per vertex, shape (n_layers,
n_vertices). If both hemispheres are processed, returns an array of shape (n_layers,
n_total_vertices) with hemisphere stacking.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Uses <cite>convert_native_to_fsaverage</cite> to identify corresponding fsaverage vertices for the
subject.</p></li>
<li><p>Retrieves laminar proportion data from <cite>big_brain_proportional_layer_boundaries()</cite>.</p></li>
<li><p>The returned values represent depth fractions (0 at white matter, 1 at pial surface) that
can be used for aligning laminar CSD or source estimates across subjects.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_cortical_thickness">
<span class="sig-name descname"><span class="pre">get_cortical_thickness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_cortical_thickness" title="Permalink to this definition">#</a></dt>
<dd><p>Compute vertex-wise cortical thickness from pial and white matter surfaces.</p>
<p>This method loads the pial and white matter meshes at the specified processing stage
and hemisphere, then computes cortical thickness as the Euclidean distance between
corresponding vertices on the two surfaces. Vertex correspondence is maintained across
layers, allowing accurate per-vertex thickness estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Surface processing stage to use (e.g., ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘ds’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'</em><em>, </em><em>None}</em><em>, </em><em>optional</em>) – Hemisphere to process (‘lh’ or ‘rh’). If None, the combined surface is used
(default: None).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>thickness</strong> – Vertex-wise cortical thickness values (in millimeters).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, shape (n_vertices,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Thickness is computed as the Euclidean distance between corresponding pial and white
matter vertices.</p></li>
<li><p>Requires vertex correspondence between surfaces, as guaranteed by <cite>LayerSurfaceSet</cite>.</p></li>
<li><p>Can be used to assess local cortical geometry or normalize laminar profiles.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_distance_to_scalp">
<span class="sig-name descname"><span class="pre">get_distance_to_scalp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_distance_to_scalp" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the minimum Euclidean distance from each cortical vertex to the scalp surface.</p>
<p>This method loads the cortical surface (e.g., pial or white matter) and computes, for each
vertex, the shortest distance to the nearest point on the scalp mesh. The scalp surface is
expected to be stored as <cite>origscalp_2562.surf.gii</cite> in the subject’s MRI directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Cortical surface layer to use (e.g., ‘pial’, ‘white’, or fractional depth). Default is
‘pial’.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface mesh (e.g., ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘ds’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'</em><em>, </em><em>None}</em><em>, </em><em>optional</em>) – Hemisphere to process (‘lh’ or ‘rh’). If None, the combined surface is used (default:
None).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>distances</strong> – Euclidean distance (in millimeters) from each cortical vertex to the nearest scalp
vertex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, shape (n_vertices,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The scalp surface is expected at: <cite>&lt;SUBJECTS_DIR&gt;/&lt;subject&gt;/mri/origscalp_2562.surf.gii</cite>.</p></li>
<li><p>Uses a KD-tree search for efficient nearest-neighbor computation.</p></li>
<li><p>Useful for evaluating cortical depth relative to scalp or for spatial normalization of
MEG sensitivity profiles.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_layer_names">
<span class="sig-name descname"><span class="pre">get_layer_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_layer_names" title="Permalink to this definition">#</a></dt>
<dd><p>Return the list of cortical layer identifiers for this subject.</p>
<p>This function generates the ordered list of surface layer names corresponding to
the proportional spacing defined in <cite>self.layer_spacing</cite>. The first and last
layers are labeled as ‘pial’ and ‘white’, respectively, while intermediate layers
are represented by fractional depth values between 0 and 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Ordered list of layer identifiers (e.g., [‘pial’, ‘0.900’, ‘0.800’, …, ‘white’]).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_mesh_path">
<span class="sig-name descname"><span class="pre">get_mesh_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_mesh_path" title="Permalink to this definition">#</a></dt>
<dd><p>Return the full path to a single-layer or multilayer surface mesh file.</p>
<p>This function constructs the absolute path to a laminar surface file for a given
layer, processing stage, hemisphere, and orientation configuration. If no layer name
is provided, it returns the path to the combined multilayer surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Name of the cortical layer (e.g., ‘white’, ‘pial’, or an intermediate layer label such
as ‘0.333’). If None, the function returns the path to the combined multilayer surface
(e.g., ‘multilayer.&lt;n_layers&gt;’).</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface (e.g., ‘raw’, ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘ds’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere identifier. Required for hemisphere-specific stages (‘raw’, ‘converted’,
‘nodeep’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation method (e.g., ‘link_vector’, ‘ds_surf_norm’, ‘orig_surf_norm’, ‘cps’).
Used only for downsampled surfaces. Default is ‘link_vector’.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the surface uses fixed dipole orientations. If True, ‘fixed’ is appended to the
filename. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Absolute path to the requested surface mesh file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_multilayer_vertex">
<span class="sig-name descname"><span class="pre">get_multilayer_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_vertex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_multilayer_vertex" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the global vertex index within the concatenated multilayer surface mesh.</p>
<p>This function converts a vertex index belonging to a specific cortical layer into
its corresponding global index in the multilayer surface representation, where
vertices from all layers are stored contiguously.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer</strong> (<em>int</em><em> or </em><em>str</em>) – Layer identifier. If an integer, it is treated as a zero-based layer index.
If a string, it must match one of the layer names in <cite>self.get_layer_names()</cite>.</p></li>
<li><p><strong>layer_vertex</strong> (<em>int</em>) – Vertex index within the specified layer.</p></li>
<li><p><strong>orientation</strong> (<em>{'link_vector'</em><em>, </em><em>'surface_normal'}</em><em>, </em><em>optional</em>) – Dipole orientation model used to determine vertex ordering. Default is <cite>‘link_vector’</cite>.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use the fixed-orientation surface set. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>global_vertex</strong> – The global vertex index corresponding to the given layer and local vertex index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Vertices across layers are assumed to be stored in sequential order
(i.e., all vertices from layer 0 precede those from layer 1, etc.).</p></li>
<li><p>Useful for indexing vertex-wise quantities defined over the full multilayer mesh.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_radiality_to_scalp">
<span class="sig-name descname"><span class="pre">get_radiality_to_scalp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_radiality_to_scalp" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the radiality of cortical dipole orientations relative to the scalp surface.</p>
<p>This function quantifies the degree to which each cortical orientation vector
(e.g., dipole or column direction) is aligned with the local scalp normal.
The result is a vertex-wise cosine similarity (absolute dot product) between
dipole orientation and scalp normal vectors, indicating radial alignment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Cortical surface layer to analyze (e.g., ‘pial’, ‘white’, or fractional depth).
Default is ‘pial’.</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Dipole orientation model used in the surface reconstruction
(e.g., ‘link_vector’, ‘ds_surf_norm’, ‘orig_surf_norm’, ‘cps’).
Default is ‘link_vector’.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether fixed dipole orientations were used during inversion. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>radiality</strong> – Absolute cosine similarity between cortical dipole vectors and local scalp normals.
Values range from 0 (tangential) to 1 (perfectly radial).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, shape (n_vertices,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Higher values indicate more radial orientations (dipoles pointing toward the scalp).</p></li>
<li><p>Scalp geometry is loaded from <cite>&lt;SUBJECTS_DIR&gt;/&lt;subject&gt;/mri/origscalp_2562.surf.gii</cite>.</p></li>
<li><p>Surface normals are estimated per face and averaged across connected vertices.</p></li>
<li><p>Useful for assessing source sensitivity, forward-model biases, or validating
laminar orientation models.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.get_vertices_per_layer">
<span class="sig-name descname"><span class="pre">get_vertices_per_layer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.get_vertices_per_layer" title="Permalink to this definition">#</a></dt>
<dd><p>Return the number of vertices per cortical layer in the downsampled multilayer mesh.</p>
<p>This method loads the multilayer surface (spanning all cortical depths) and computes
how many vertices correspond to a single layer by dividing the total vertex count
by the number of layers in the surface set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Dipole orientation model used in the laminar surface reconstruction
(e.g., ‘link_vector’, ‘ds_surf_norm’, ‘orig_surf_norm’, ‘cps’).
Default is ‘link_vector’.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether fixed dipole orientations were used across layers. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>n_vertices</strong> – Number of vertices per cortical layer in the downsampled (stage=’ds’) mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.interpolate_layer_data">
<span class="sig-name descname"><span class="pre">interpolate_layer_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'combined'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.interpolate_layer_data" title="Permalink to this definition">#</a></dt>
<dd><p>Interpolate vertex-wise data from a downsampled layer mesh to the original high-resolution
surface.</p>
<p>This function projects data values defined on a downsampled surface (e.g., ‘ds’ stage) onto
the corresponding vertices of the full-resolution mesh (e.g., ‘combined’ stage).
Interpolation is performed using a nearest-neighbour scheme with optional local averaging
over connected vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em>) – Name of the cortical layer to interpolate (e.g., ‘pial’, ‘white’, ‘0.333’).</p></li>
<li><p><strong>data</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_vertices_ds</em><em>,</em><em>)</em>) – Vertex-wise data associated with the downsampled mesh.</p></li>
<li><p><strong>from_stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Source mesh stage for interpolation (default: ‘ds’).</p></li>
<li><p><strong>to_stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Target mesh stage to which data are interpolated (default: ‘combined’).</p></li>
<li><p><strong>k_neighbors</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of nearest neighbours to use for smoothing interpolation (default: 5).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>interpolated_data</strong> – Array of interpolated vertex values in the target mesh space.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The interpolation preserves the laminar correspondence between meshes by using vertex
adjacency and spatial proximity.</p></li>
<li><p>This function is typically used to project laminar or orientation data back to the
original-resolution FreeSurfer space after downsampling.</p></li>
<li><p>Internally calls <cite>interpolate_data()</cite> to perform weighted vertex interpolation.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.load" title="Permalink to this definition">#</a></dt>
<dd><p>Load a GIFTI surface mesh for a specified cortical layer and processing stage.</p>
<p>This function retrieves and loads a surface file corresponding to a given layer,
hemisphere, and processing stage. If <cite>layer_name</cite> is None, the multilayer combined
surface (e.g., ‘multilayer.&lt;n_layers&gt;’) is loaded. Optionally, orientation and fixation
metadata can be specified to load downsampled or orientation-specific variants.
Combined surfaces (both hemispheres) are loaded when <cite>hemi</cite> is None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the cortical layer (e.g., ‘pial’, ‘white’, intermediate label such as ‘0.333’,
or None to load the multilayer combined surface).</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface (e.g., ‘raw’, ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘raw’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere identifier. If None, the function loads the combined surface file.</p></li>
<li><p><strong>orientation</strong> (<em>{'link_vector'</em><em>, </em><em>'ds_surf_norm'</em><em>, </em><em>'orig_surf_norm'</em><em>, </em><em>'cps'}</em><em>, </em><em>optional</em>) – Orientation method used for dipole estimation (applies only to downsampled surfaces).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether a fixed-orientation variant of the surface should be loaded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The loaded GIFTI surface object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nib.GiftiImage</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>FileNotFoundError</strong> – If the requested surface file does not exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.load_meta">
<span class="sig-name descname"><span class="pre">load_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.load_meta" title="Permalink to this definition">#</a></dt>
<dd><p>Load metadata associated with a laminar surface file.</p>
<p>This function retrieves the JSON sidecar metadata corresponding to a surface mesh
at a specified processing stage, hemisphere, and orientation configuration. If the
metadata file does not exist, an empty dictionary is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the cortical layer (e.g., ‘pial’, ‘white’, or an intermediate layer label such
as ‘0.333’). If None, the function attempts to load metadata for the multilayer
combined surface.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface (e.g., ‘raw’, ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘raw’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere identifier. Required for hemisphere-specific stages (‘raw’, ‘converted’,
‘nodeep’). If None, loads metadata for the combined surface.</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation method (e.g., ‘link_vector’, ‘ds_surf_norm’, ‘orig_surf_norm’, ‘cps’).
Used only for downsampled surfaces.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the surface uses fixed dipole orientations. If True, loads metadata from the
corresponding ‘fixed’ file variant.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary containing the surface metadata. Returns an empty dictionary if no metadata
file is found.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.map_between_stages">
<span class="sig-name descname"><span class="pre">map_between_stages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'converted'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.map_between_stages" title="Permalink to this definition">#</a></dt>
<dd><p>Map vertex indices between different surface processing stages.</p>
<p>This function computes vertex correspondences between surfaces at different
stages of the laminar processing pipeline (e.g., ‘converted’, ‘nodeep’,
‘combined’, ‘ds’). It handles stage-specific transformations such as vertex
removal, hemisphere concatenation/splitting, and geometric downsampling.
The mapping is returned as an integer index array that maps vertices in the
<cite>from_stage</cite> surface to their nearest counterparts in the <cite>to_stage</cite> surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em>) – Name of the cortical layer (e.g., ‘pial’, ‘white’, or intermediate layer such as
‘0.333’).</p></li>
<li><p><strong>from_stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Source processing stage from which vertices are mapped (e.g., ‘converted’, ‘nodeep’,
‘combined’, ‘ds’). Default is ‘ds’.</p></li>
<li><p><strong>from_hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere for the source surface. Must be specified when mapping from per-hemisphere
stages (‘converted’ or ‘nodeep’).</p></li>
<li><p><strong>to_stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Target processing stage to which vertices are mapped (e.g., ‘converted’, ‘nodeep’,
‘combined’, ‘ds’). Default is ‘converted’.</p></li>
<li><p><strong>to_hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere for the target surface. Must be specified when mapping to per-hemisphere
stages (‘converted’ or ‘nodeep’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>idx</strong> – Integer array mapping vertex indices from <cite>from_stage</cite> to <cite>to_stage</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If invalid hemisphere combinations are specified or if mapping across hemispheres is
attempted.</p></li>
<li><p><strong>FileNotFoundError</strong> – If one of the required surface files does not exist.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>Stage-specific mappings are handled as follows:</dt><dd><ul>
<li><p><strong>‘converted’ -&gt; ‘nodeep’</strong> - applies vertex removal based on metadata.</p></li>
<li><p><strong>‘nodeep’ -&gt; ‘combined’</strong> - concatenates hemispheres and offsets right-hemisphere
indices.</p></li>
<li><p><strong>‘combined’ -&gt; ‘nodeep’</strong> - splits the combined mesh into hemispheres.</p></li>
<li><p><strong>‘combined’ -&gt; ‘ds’</strong> - maps vertices geometrically via nearest-neighbour search.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>All other transitions fall back to geometric nearest-neighbour mapping.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.save" title="Permalink to this definition">#</a></dt>
<dd><p>Save a GIFTI surface mesh and its associated metadata.</p>
<p>This function saves a GIFTI surface object to the laminar surface directory using the
standardized naming convention defined by the layer, stage, hemisphere, and orientation.
A corresponding JSON sidecar file is also written, containing metadata and a timestamp
of the last modification. If no metadata is provided, a minimal file with a modification
timestamp is created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gifti_obj</strong> (<em>nib.GiftiImage</em>) – The GIFTI surface object to save.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the cortical layer (e.g., ‘pial’, ‘white’, ‘0.333’, or None for multilayer
surfaces).</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface (e.g., ‘raw’, ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘raw’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere identifier. If None, saves the combined surface.</p></li>
<li><p><strong>orientation</strong> (<em>{'link_vector'</em><em>, </em><em>'ds_surf_norm'</em><em>, </em><em>'orig_surf_norm'</em><em>, </em><em>'cps'}</em><em>, </em><em>optional</em>) – Orientation method, if applicable (used for downsampled surfaces).</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether a fixed-orientation variant should be saved.</p></li>
<li><p><strong>meta</strong> (<em>dict</em><em>, </em><em>optional</em>) – Optional metadata dictionary to be saved alongside the surface as a JSON file.
If None, only a timestamp entry is written.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The GIFTI file is saved in the laminar surface directory for the subject.</p></li>
<li><p>Metadata is stored in a <cite>.json</cite> sidecar file with the same base name as the surface file.</p></li>
<li><p>The metadata file always includes a <cite>modified_at</cite> timestamp field.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.update_meta">
<span class="sig-name descname"><span class="pre">update_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">updates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.update_meta" title="Permalink to this definition">#</a></dt>
<dd><p>Update or create the metadata JSON sidecar for a surface file.</p>
<p>This function loads the existing metadata for a given surface, applies updates from
a provided dictionary, and writes the modified metadata back to disk. If the metadata
file does not exist, it is created automatically. The modification timestamp is always
updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the cortical layer (e.g., ‘pial’, ‘white’, or intermediate layer label such as
‘0.333’). If None, the function targets the combined multilayer surface.</p></li>
<li><p><strong>stage</strong> (<em>str</em><em>, </em><em>optional</em>) – Processing stage of the surface (e.g., ‘raw’, ‘converted’, ‘nodeep’, ‘combined’, ‘ds’).
Default is ‘raw’.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere identifier. Required for hemisphere-specific stages (‘raw’, ‘converted’,
‘nodeep’).</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em>, </em><em>optional</em>) – Orientation method (e.g., ‘link_vector’, ‘ds_surf_norm’, ‘orig_surf_norm’, ‘cps’).
Used only for downsampled surfaces.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the surface uses fixed dipole orientations. If True, updates metadata for the
corresponding ‘fixed’ file variant.</p></li>
<li><p><strong>updates</strong> (<em>dict</em><em>, </em><em>optional</em>) – Dictionary of key-value pairs to add or modify in the metadata. If None, no update is
performed.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>A timestamp field (‘modified_at’) is automatically added or updated.</p></li>
<li><p>The directory structure for the metadata file is created if it does not exist.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lameg.surf.LayerSurfaceSet.validate">
<span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">required_stages</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('raw',</span> <span class="pre">'converted',</span> <span class="pre">'nodeep',</span> <span class="pre">'combined',</span> <span class="pre">'ds')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('lh',</span> <span class="pre">'rh')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.LayerSurfaceSet.validate" title="Permalink to this definition">#</a></dt>
<dd><p>Validate the completeness and internal consistency of surface files across layers,
hemispheres, and stages.</p>
<p>This function checks that all expected surface files are present for the specified
processing stages and verifies vertex count consistency across layers within each stage.
For downsampled surfaces, optional validation of orientation and fixed-orientation variants
is supported. The function raises descriptive errors for missing files or mismatched vertex
counts, ensuring structural integrity of the laminar surface set before further processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>required_stages</strong> (<em>sequence</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – List of processing stages to validate (e.g., ‘raw’, ‘converted’, ‘nodeep’, ‘combined’,
‘ds’). Default includes all standard stages.</p></li>
<li><p><strong>hemis</strong> (<em>sequence</em><em> of </em><em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemispheres to check for per-hemisphere stages (default: both).</p></li>
<li><p><strong>orientations</strong> (<em>sequence</em><em> of </em><em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Orientation methods to validate for the downsampled stage (e.g., [‘link_vector’]).
Ignored for other stages.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Whether to restrict validation to fixed-orientation variants. If None, both fixed and
non-fixed variants are checked.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If any expected surface files are missing from the directory structure.</p></li>
<li><p><strong>ValueError</strong> – If vertex counts are inconsistent across layers within a hemisphere or combined mesh.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>For ‘raw’, ‘converted’, and ‘nodeep’ stages, each hemisphere is validated separately.</p></li>
<li><p>For ‘combined’ surfaces, vertex counts are checked across layers for the merged
hemispheres.</p></li>
<li><p>For ‘ds’ (downsampled) surfaces, each orientation and fixedness combination is validated
independently.</p></li>
<li><p>This validation step is typically run at the end of <cite>create</cite> to
ensure consistency before dipole orientation computation or laminar combination.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.convert_fsaverage_to_native">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">convert_fsaverage_to_native</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.convert_fsaverage_to_native" title="Permalink to this definition">#</a></dt>
<dd><p>Map vertex indices from fsaverage spherical registration space to a subject’s native,
downsampled surface space.</p>
<p>This function maps vertices defined on the fsaverage template to their corresponding
locations on an individual subject’s cortical surface. It first identifies the subject’s
corresponding vertex in spherical registration space (<cite>?h.sphere.reg</cite>) via nearest-neighbour
search, then maps those vertices to the subject’s downsampled surface for use in laminar or
source-space analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – Subject’s surface set instance containing paths and metadata for all cortical layers.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em>) – Name of the surface layer to use for mapping (e.g., ‘pial’, ‘white’, or a fractional layer).</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em>) – Hemisphere to convert.</p></li>
<li><p><strong>vert_idx</strong> (<em>int</em><em> | </em><em>array-like</em><em> of </em><em>int</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Vertex index or array of vertex indices on the fsaverage surface.
If None, all fsaverage vertices are mapped.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>subj_v_idx</strong> – Corresponding vertex index (or array of indices) on the subject’s downsampled surface.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>The mapping is performed in two stages:</dt><dd><ol class="arabic simple">
<li><p><strong>Spherical registration mapping:</strong> fsaverage vertices are mapped to the subject’s
<cite>?h.sphere.reg</cite> using nearest-neighbour search in spherical space.</p></li>
<li><p><strong>Downsampling alignment:</strong> the subject’s full-resolution surface vertices are
mapped onto the downsampled mesh via spatial proximity.</p></li>
</ol>
</dd>
</dl>
</li>
<li><p>Assumes that the downsampled surface is a vertex subset of the full-resolution mesh.</p></li>
<li><p>This provides a lightweight geometric approximation to FreeSurfer’s surface morph,
suitable for vertex-level correspondence in laminar analyses.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subj_v_idx</span> <span class="o">=</span> <span class="n">convert_fsaverage_to_native</span><span class="p">(</span><span class="n">surf_set</span><span class="p">,</span> <span class="s1">&#39;pial&#39;</span><span class="p">,</span> <span class="s1">&#39;lh&#39;</span><span class="p">,</span> <span class="n">vert_idx</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subj_v_idx</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.convert_native_to_fsaverage">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">convert_native_to_fsaverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.convert_native_to_fsaverage" title="Permalink to this definition">#</a></dt>
<dd><p>Map coordinates from a subject’s native surface space to fsaverage spherical registration space.</p>
<p>This function maps vertices or coordinates defined in a subject’s native surface (typically
downsampled pial or white matter surfaces) to their corresponding vertices on the fsaverage
template. It uses the spherical registration surfaces (<cite>?h.sphere.reg</cite>) to establish vertex-
level correspondence via nearest-neighbour matching in spherical space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – Subject’’s surface set instance containing paths and metadata for cortical layers.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em>) – Surface layer to use for mapping (e.g., ‘pial’, ‘white’, or a fractional layer).</p></li>
<li><p><strong>subj_coord</strong> (<em>array-like</em><em> of </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>) or </em><em>(</em><em>N</em><em>, </em><em>3</em><em>)</em><em>, </em><em>optional</em>) – Vertex coordinate(s) in the subject’s downsampled surface space.
If None, all downsampled vertices are mapped.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hemis</strong> (<em>str or list of str</em>) – Hemisphere label(s) for each vertex (‘lh’ or ‘rh’).</p></li>
<li><p><strong>fsave_v_idx</strong> (<em>int or list of int</em>) – Corresponding vertex index (or list of indices) on the fsaverage spherical surface.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>The mapping proceeds in three stages:</dt><dd><ol class="arabic simple">
<li><p><strong>Downsampled -&gt; full-resolution mapping:</strong> Each downsampled vertex is matched to the
nearest vertex in the subject’s full-resolution left and right hemisphere meshes.</p></li>
<li><p><strong>Hemisphere assignment:</strong> Vertices are assigned to the hemisphere with the smallest
Euclidean distance.</p></li>
<li><p><strong>Spherical registration mapping:</strong> The corresponding vertex on the subject’s
<cite>?h.sphere.reg</cite> surface is matched to fsaverage using nearest-neighbour search in
spherical space.</p></li>
</ol>
</dd>
</dl>
<p>This procedure approximates FreeSurfer’s spherical morph alignment geometrically and is
suitable for mapping subject-specific data into fsaverage space for group-level laminar or
source-space analyses.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hemis</span><span class="p">,</span> <span class="n">fsave_idx</span> <span class="o">=</span> <span class="n">convert_native_to_fsaverage</span><span class="p">(</span><span class="n">surf_set</span><span class="p">,</span> <span class="s1">&#39;pial&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">fsave_idx</span><span class="p">)</span>
<span class="go">81924</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hemis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fsave_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(&#39;lh&#39;, 10234)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.interpolate_data">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">interpolate_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsampled_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsampled_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.surf.interpolate_data" title="Permalink to this definition">#</a></dt>
<dd><p>Interpolate vertex-wise data from a downsampled mesh back to the original high-resolution mesh.</p>
<p>This function reconstructs vertex data on the full-resolution surface by weighted averaging
of the <em>k</em> nearest downsampled vertices in Euclidean space. It then performs a refinement pass
for vertices that were part of the downsampled mesh, averaging their values with adjacent
vertices to enforce local smoothness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_mesh</strong> (<em>nibabel.gifti.GiftiImage</em>) – Original high-resolution cortical mesh (GIFTI format).</p></li>
<li><p><strong>downsampled_mesh</strong> (<em>nibabel.gifti.GiftiImage</em>) – Downsampled version of the mesh corresponding to the provided data.</p></li>
<li><p><strong>downsampled_data</strong> (<em>np.ndarray</em>) – Vertex-wise data array from the downsampled mesh.</p></li>
<li><p><strong>adjacency_matrix</strong> (<em>scipy.sparse matrix</em><em>, </em><em>optional</em>) – Vertex adjacency matrix for the original mesh. If None, it is computed internally.</p></li>
<li><p><strong>k_neighbors</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of nearest downsampled vertices used for interpolation (default: 5).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vertex_data</strong> – Interpolated vertex-wise data for the original high-resolution mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The first interpolation pass uses inverse-distance weighting based on <em>k</em>-nearest neighbors
in Euclidean space between meshes.</p></li>
<li><p>The second pass refines vertices present in the downsampled mesh using weighted neighborhood
averaging based on surface adjacency.</p></li>
<li><p>This method preserves spatial smoothness while minimizing interpolation bias near downsampled
vertices.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_data</span> <span class="o">=</span> <span class="n">interpolate_data</span><span class="p">(</span><span class="n">orig_gii</span><span class="p">,</span> <span class="n">ds_gii</span><span class="p">,</span> <span class="n">ds_data</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(163842,)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-lameg.util">
<span id="lameg-util-module"></span><h2>lameg.util module<a class="headerlink" href="#module-lameg.util" title="Permalink to this heading">#</a></h2>
<p>Utility functions for SPM, MEG sensor data management, and neuroanatomical processing.</p>
<p>This module provides a suite of high-level tools to interface with SPM (Statistical Parametric
Mapping), MNE-Python, and FreeSurfer environments. It facilitates batch execution, data format
conversion, sensor-level data handling, and laminar or anatomical computations relevant to
MEG/EEG analysis pipelines. Many functions integrate seamlessly with standalone SPM sessions and
FreeSurfer-derived cortical surfaces.</p>
<section id="core-functionalities">
<h3>Core functionalities<a class="headerlink" href="#core-functionalities" title="Permalink to this heading">#</a></h3>
<ul>
<li><p><strong>SPM interfacing and batch execution</strong>
- Context-managed lifecycle for standalone SPM instances (<cite>spm_context</cite>).
- Automated batch execution of MATLAB-based neuroimaging workflows (<cite>batch</cite>).
- Conversion of CTF MEG data from MNE <cite>.fif</cite> to SPM <cite>.mat</cite> format (<cite>ctf_fif_spm_conversion</cite>).</p></li>
<li><p><strong>File and directory utilities</strong>
- Structured recursive file and directory retrieval (<cite>get_files</cite>, <cite>get_directories</cite>).
- Directory creation with automatic parent handling (<cite>make_directory</cite>).
- Flexible substring matching (<cite>check_many</cite>).</p></li>
<li><p><strong>Statistical and numerical utilities</strong>
- Corrected paired-sample t-tests with NaN handling (<cite>ttest_rel_corrected</cite>).
- Conversion of absolute layer thicknesses to proportional coordinates (<cite>calc_prop</cite>).</p></li>
<li><p><strong>Anatomical and laminar processing</strong>
- Derivation of normalized laminar boundaries from the fsaverage BigBrain atlas</p>
<blockquote>
<div><p>(<cite>big_brain_proportional_layer_boundaries</cite>).</p>
</div></blockquote>
</li>
<li><p><strong>Coregistration and fiducial handling</strong>
- Extraction of subject-specific fiducial coordinates from TSV metadata files</p>
<blockquote>
<div><p>(<cite>get_fiducial_coords</cite>).</p>
</div></blockquote>
<ul class="simple">
<li><p>Coregistration of 3D facial scans to FreeSurfer MRI via fiducial and ICP alignment
(<cite>coregister_3d_scan_mri</cite>).</p></li>
</ul>
</li>
</ul>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The module assumes correctly configured environments for SPM standalone, MNE-Python, and
FreeSurfer.</p></li>
<li><p>Designed for reproducible neuroimaging workflows combining MATLAB-based and Python-based tools.</p></li>
<li><p>File operations are implemented with explicit error handling for compatibility across platforms.</p></li>
<li><p>The laminar utilities rely on fsaverage-space anatomical templates distributed with laMEG.</p></li>
</ul>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.batch">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#lameg.util.batch" title="Permalink to this definition">#</a></dt>
<dd><p>Execute an SPM batch job within a managed standalone MATLAB session.</p>
<p>This function runs an arbitrary SPM batch configuration (<cite>matlabbatch</cite>) by writing it to a
temporary MATLAB file and executing it within an SPM standalone environment. It supports both
interactive (visual) and non-interactive (headless) execution, automatically handling session
setup and cleanup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cfg</strong> (<em>dict</em>) – Dictionary defining the SPM batch configuration, following the standard <cite>matlabbatch</cite>
format (e.g., as used in <cite>spm_jobman</cite>).</p></li>
<li><p><strong>viz</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to display the SPM GUI during execution (<cite>True</cite>) or run in command-line mode
(<cite>False</cite>). Default is True.</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function automatically wraps <cite>cfg</cite> into a valid <cite>matlabbatch</cite> structure and saves it to
a temporary <cite>.mat</cite> file before execution.</p></li>
<li><p>Temporary files are created using the system’s default temp directory and deleted after
the job completes.</p></li>
<li><p>Runs all standard SPM batch modules, including EEG/MEG preprocessing, coregistration,
inversion, and statistical analyses.</p></li>
<li><p>When <cite>viz=False</cite>, <cite>spm_get_defaults(‘cmdline’, 1)</cite> is used to suppress GUI output, making
the function suitable for automated pipelines and HPC execution.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.big_brain_proportional_layer_boundaries">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">big_brain_proportional_layer_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.big_brain_proportional_layer_boundaries" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve proportional cortical layer boundary coordinates from the fsaverage-converted
BigBrain atlas included in laMEG.</p>
<p>This function computes normalized laminar depth coordinates (ranging from 0 to 1) for each
cortical vertex using the fsaverage-mapped BigBrain histological atlas. The proportional
layer boundaries (layers 1-6) are derived from absolute thickness values and cached as a
NumPy dictionary to improve subsequent loading speed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>overwrite</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, recomputes proportional boundaries and overwrites the existing cached file.
Default is False.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>bb_data</strong> – Dictionary containing normalized layer boundaries for each hemisphere:
- <cite>“lh”</cite>: left hemisphere vertex-wise boundary array (shape: 6 × n_vertices)
- <cite>“rh”</cite>: right hemisphere vertex-wise boundary array (shape: 6 × n_vertices)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The proportional boundaries represent cumulative thickness proportions from layer 1 (pial)
to layer 6 (white matter).</p></li>
<li><p>Cached results are stored as <cite>proportional_layer_boundaries.npy</cite> in the module’s <cite>assets</cite>
directory.</p></li>
<li><p>Uses <cite>calc_prop()</cite> internally to normalize absolute thickness values per vertex.</p></li>
<li><p>This dataset provides a standard laminar coordinate reference compatible with fsaverage-
registered MEG/EEG source models.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.calc_prop">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">calc_prop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.calc_prop" title="Permalink to this definition">#</a></dt>
<dd><p>Compute cumulative proportional values from a vector while preserving zero-sum cases.</p>
<p>This function converts an array of independent thickness or weight values into cumulative
proportions that sum to one. If the total sum of the input is zero, the function returns the
original vector unchanged to avoid division by zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vec</strong> (<em>array_like</em>) – Input array of non-negative values (e.g., layer thicknesses or weights).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vec</strong> – Cumulative proportion vector, normalized by the total sum. If the input sum is zero,
returns the original vector unchanged.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The result ranges from 0 to 1, representing the normalized cumulative distribution.</p></li>
<li><p>Useful for converting laminar thickness values into depth proportion coordinates.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.check_freesurfer_setup">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">check_freesurfer_setup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.check_freesurfer_setup" title="Permalink to this definition">#</a></dt>
<dd><p>Verify that essential FreeSurfer command-line tools are available in the environment.</p>
<p>This function checks whether the required FreeSurfer binaries (<cite>mris_convert</cite> and <cite>mri_info</cite>)
can be found in the system’s PATH. If one or more binaries are missing, it raises an
<cite>EnvironmentError</cite> with detailed setup instructions for sourcing the FreeSurfer environment.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>EnvironmentError</strong> – If one or more required FreeSurfer binaries are not found in the system PATH.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>This check ensures that FreeSurfer has been properly installed and initialized via:</dt><dd><p>export FREESURFER_HOME=/path/to/freesurfer
source $FREESURFER_HOME/SetUpFreeSurfer.sh</p>
</dd>
</dl>
</li>
<li><p>Typically called before surface conversion or reconstruction routines that depend on
FreeSurfer utilities.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.check_many">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">check_many</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multiple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.check_many" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluate whether multiple substrings occur within a target string.</p>
<p>This utility checks whether all or any of a list of substrings are present in a given target
string. It is designed for use in conditional logic (e.g., list comprehensions or filtering
routines) where flexible substring matching is required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>multiple</strong> (<em>list</em><em> of </em><em>str</em>) – Substrings to search for within the target string.</p></li>
<li><p><strong>target</strong> (<em>str</em>) – String in which to search for the specified substrings.</p></li>
<li><p><strong>func</strong> (<em>{'all'</em><em>, </em><em>'any'}</em>) – Search mode: <cite>‘all’</cite> returns True only if all substrings are found, <cite>‘any’</cite> returns True
if at least one substring is found.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the condition specified by <cite>func</cite> is satisfied; False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>func</cite> is not <cite>‘all’</cite> or <cite>‘any’</cite>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Useful for concise logical checks in comprehensions or filters.</p></li>
<li><p>Matching is case-sensitive and does not support regular expressions.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.coregister_3d_scan_mri">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">coregister_3d_scan_mri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subject_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dig_face_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dig_units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.coregister_3d_scan_mri" title="Permalink to this definition">#</a></dt>
<dd><p>Coregister a 3D facial surface scan to a FreeSurfer MRI using fiducial- and ICP-based alignment.</p>
<p>This function aligns a subject’s 3D facial mesh (e.g., STL scan) to their FreeSurfer MRI space.
It first performs a fiducial-based rigid alignment using the NAS, LPA, and RPA landmarks, then
refines the fit using iterative closest point (ICP) optimization on dense head-surface points.
The resulting transformation is applied to the fiducials, returning their coordinates in
FreeSurfer MRI voxel space (scanner RAS + CRAS offset).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subject_id</strong> (<em>str</em>) – Name of the FreeSurfer subject (must exist in <cite>$SUBJECTS_DIR</cite>).</p></li>
<li><p><strong>lpa</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – Left preauricular fiducial in millimeters (3D scan coordinate frame).</p></li>
<li><p><strong>rpa</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – Right preauricular fiducial in millimeters (3D scan coordinate frame).</p></li>
<li><p><strong>nas</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – Nasion fiducial in millimeters (3D scan coordinate frame).</p></li>
<li><p><strong>dig_face_fname</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Path to the subject’s 3D facial mesh (e.g., <cite>.stl</cite>) containing head-surface points.</p></li>
<li><p><strong>dig_units</strong> (<em>{'m'</em><em>, </em><em>'mm'}</em><em>, </em><em>optional</em>) – Units of the 3D facial scan coordinates. Default is <cite>‘mm’</cite>.</p></li>
<li><p><strong>out_dir</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Directory where visualization screenshots of the alignment stages will be saved.
If None, no figures are written.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lpa_t</strong> (<em>np.ndarray, shape (3,)</em>) – Transformed LPA coordinate in FreeSurfer MRI voxel space (mm).</p></li>
<li><p><strong>rpa_t</strong> (<em>np.ndarray, shape (3,)</em>) – Transformed RPA coordinate in FreeSurfer MRI voxel space (mm).</p></li>
<li><p><strong>nas_t</strong> (<em>np.ndarray, shape (3,)</em>) – Transformed NAS coordinate in FreeSurfer MRI voxel space (mm).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Requires FreeSurfer to be installed and <cite>$SUBJECTS_DIR</cite> to be set.</p></li>
<li><p>Uses MNE-Python’s <cite>Coregistration</cite> and <cite>plot_alignment</cite> utilities for alignment and
visualization.</p></li>
<li><p>Fiducial alignment is refined using ICP on dense surface points but excludes fiducial
weighting during ICP iterations.</p></li>
<li><p>The returned coordinates are in <strong>scanner RAS + CRAS</strong> space (voxel-aligned), not FreeSurfer
surface RAS.</p></li>
<li><p>If <cite>out_dir</cite> is provided, three screenshots are saved:
<cite>coreg-initial.png</cite>, <cite>coreg-fit_fiducials.png</cite>, and <cite>coreg-fit_icp.png</cite>.</p></li>
<li><p>This workflow is useful for aligning 3D optical scans or digitized head shapes to MRI space
prior to MEG/EEG forward modeling.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.ctf_fif_spm_conversion">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">ctf_fif_spm_conversion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mne_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res4_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoched</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spm_'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.ctf_fif_spm_conversion" title="Permalink to this definition">#</a></dt>
<dd><p>Convert MEG data from CTF <cite>.fif</cite> format to SPM-compatible <cite>.mat</cite> format.</p>
<p>This function converts raw or epoched MEG data acquired from a CTF scanner (in <cite>.fif</cite> format)
into SPM’s M/EEG format using the standalone SPM interface. It requires the corresponding
CTF <cite>.res4</cite> file for sensor geometry and saves the converted dataset to the specified output
directory with a customizable prefix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mne_file</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Path to the MNE <cite>.fif</cite> file containing MEG data (either <cite>*-raw.fif</cite> or <cite>*-epo.fif</cite>).</p></li>
<li><p><strong>res4_file</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Path to the CTF <cite>.res4</cite> file containing sensor position and geometry information.</p></li>
<li><p><strong>output_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Destination directory for the converted SPM dataset.</p></li>
<li><p><strong>epoched</strong> (<em>bool</em>) – Whether the input data are epoched (<cite>True</cite>) or continuous (<cite>False</cite>).</p></li>
<li><p><strong>prefix</strong> (<em>str</em><em>, </em><em>optional</em>) – Prefix to prepend to the converted dataset filename (default: <cite>“spm_”</cite>).</p></li>
<li><p><strong>spm_instance</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Active standalone SPM instance. If None, a temporary instance is created and closed after
execution.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>spm_instance</cite> is not provided, a new standalone SPM session is automatically launched and
terminated after completion.</p></li>
<li><p>The resulting <cite>.mat</cite> file is compatible with all SPM EEG/MEG preprocessing, inversion, and
model comparison pipelines.</p></li>
<li><p>Both paths (<cite>mne_file</cite> and <cite>res4_file</cite>) must be valid and refer to files from the same
acquisition session.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_directories">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_directories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_directories" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve directories within a path that contain specified substrings in their names.</p>
<p>This function searches a target directory (optionally recursively) for subdirectories whose
names match one or more specified substrings. It supports both shallow and recursive search
modes and flexible matching logic (“all” or “any”) for substring inclusion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Root directory in which to search for subdirectories.</p></li>
<li><p><strong>strings</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – Substrings to be matched within each directory path or name. Default is an empty string.</p></li>
<li><p><strong>check</strong> (<em>{'all'</em><em>, </em><em>'any'}</em><em>, </em><em>optional</em>) – Search mode: <cite>‘all’</cite> requires all substrings in <cite>strings</cite> to be present; <cite>‘any’</cite> requires
at least one. Default is <cite>‘all’</cite>.</p></li>
<li><p><strong>depth</strong> (<em>{'all'</em><em>, </em><em>'one'}</em><em>, </em><em>optional</em>) – Search depth: <cite>‘all’</cite> performs a recursive search through subdirectories, <cite>‘one’</cite>
limits the search to the top-level directory. Default is <cite>‘all’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>subdirs</strong> – Sorted list of paths to directories matching the specified criteria.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of pathlib.Path</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Matching is case-sensitive and performed using <cite>check_many()</cite>.</p></li>
<li><p>The returned list is sorted lexicographically by directory path.</p></li>
<li><p>Useful for structured directory traversal and dataset organization tasks.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_fiducial_coords">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_fiducial_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\t'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subject_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'subj_id'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nas_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nas'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lpa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rpa'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_delimiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">','</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_fiducial_coords" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve fiducial landmark coordinates (NAS, LPA, RPA) for a specified subject from a TSV file.</p>
<p>This function reads a tab- or comma-delimited text file containing subject-specific
fiducial landmarks and returns the NASion (NAS), Left Preauricular (LPA), and Right
Preauricular (RPA) coordinates for the requested subject. Each coordinate entry
should contain three comma-separated values representing the x, y, and z positions
(in millimeters, unless otherwise specified).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subj_id</strong> (<em>str</em>) – Subject identifier used to locate the corresponding row in the file.</p></li>
<li><p><strong>fname</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Path to the TSV file containing fiducial coordinates.</p></li>
<li><p><strong>col_delimiter</strong> (<em>str</em><em>, </em><em>optional</em>) – Character delimiting columns in the file (default: ‘t’).</p></li>
<li><p><strong>subject_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name containing subject identifiers (default: ‘subj_id’).</p></li>
<li><p><strong>nas_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for NASion coordinates (default: ‘nas’).</p></li>
<li><p><strong>lpa_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for Left Preauricular coordinates (default: ‘lpa’).</p></li>
<li><p><strong>rpa_column</strong> (<em>str</em><em>, </em><em>optional</em>) – Column name for Right Preauricular coordinates (default: ‘rpa’).</p></li>
<li><p><strong>val_delimiter</strong> (<em>str</em><em>, </em><em>optional</em>) – Character delimiting coordinate values within each cell (default: ‘,’).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>fid_coords</strong> – Dictionary containing fiducial coordinates:
<code class="docutils literal notranslate"><span class="pre">{'nas':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'lpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z],</span> <span class="pre">'rpa':</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]}</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if the subject is not found in the file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict or None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If a matching subject is found but one or more fiducial columns are missing or malformed.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The file must contain a header row with named columns.</p></li>
<li><p>Coordinates are typically in head or MRI space, depending on acquisition convention.</p></li>
<li><p>Commonly used to initialize coregistration in MEG/EEG preprocessing pipelines
(e.g., for SPM, MNE, or hpMEG analyses).</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_files">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.get_files" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve files from a directory matching specified criteria (suffix, prefix, and substrings).</p>
<p>This function searches a target directory (optionally recursively) for files with a given
extension and filters them by filename content and prefix. It supports flexible substring
matching via “all” or “any” logic, making it suitable for controlled file selection in large
datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – Root directory in which to search for files.</p></li>
<li><p><strong>suffix</strong> (<em>str</em>) – File extension to match, in the form ‘<em>.ext’ (e.g., ‘</em>.mat’ or ‘<a href="#id2"><span class="problematic" id="id3">*</span></a>.fif’).</p></li>
<li><p><strong>strings</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – Substrings to be matched within each filename. Default is an empty string.</p></li>
<li><p><strong>prefix</strong> (<em>str</em><em>, </em><em>optional</em>) – Restrict results to filenames beginning with this prefix. Default is None.</p></li>
<li><p><strong>check</strong> (<em>{'all'</em><em>, </em><em>'any'}</em><em>, </em><em>optional</em>) – Search mode: <cite>‘all’</cite> requires all substrings in <cite>strings</cite> to be present; <cite>‘any’</cite>
requires at least one. Default is <cite>‘all’</cite>.</p></li>
<li><p><strong>depth</strong> (<em>{'all'</em><em>, </em><em>'one'}</em><em>, </em><em>optional</em>) – Search depth: <cite>‘all’</cite> performs a recursive search through subdirectories, <cite>‘one’</cite>
limits the search to the top-level directory. Default is <cite>‘all’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>files</strong> – Sorted list of paths to files matching the specified criteria.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of pathlib.Path</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Matching is case-sensitive and exact (no regular expressions).</p></li>
<li><p>The function internally uses <cite>check_many()</cite> for substring evaluation.</p></li>
<li><p>Useful for structured data pipelines where file inclusion depends on both naming and
hierarchical constraints.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.load_meg_sensor_data">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">load_meg_sensor_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.load_meg_sensor_data" title="Permalink to this definition">#</a></dt>
<dd><p>Load MEG sensor-level data and metadata from an SPM M/EEG dataset.</p>
<p>This function extracts MEG channel data, timestamps, and channel labels from an SPM-format
dataset, supporting both HDF5-based (v7.3+) and older MATLAB <cite>.mat</cite> file structures. It filters
out non-MEG and bad channels, reconstructs the binary data matrix, and returns it in
sensor × time × trial format (if applicable).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_fname</strong> (<em>str</em>) – Path to the SPM M/EEG <cite>.mat</cite> file containing metadata and reference to the binary data file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sensor_data</strong> (<em>np.ndarray</em>) – MEG sensor data (channels × time [× trials]) extracted from the referenced binary file.</p></li>
<li><p><strong>time</strong> (<em>np.ndarray</em>) – Time vector in milliseconds.</p></li>
<li><p><strong>ch_names</strong> (<em>list of str</em>) – Names of the valid MEG channels included in the output.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If the binary data file specified in the <cite>.mat</cite> structure cannot be found.</p></li>
<li><p><strong>OSError</strong> – If the <cite>.mat</cite> file cannot be opened as an HDF5 dataset.</p></li>
<li><p><strong>KeyError</strong> – If required fields are missing from the file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Supports both MATLAB v7.3 (HDF5) and earlier formats.</p></li>
<li><p>Only MEG channels marked as ‘good’ (not bad) are retained.</p></li>
<li><p>Binary data are read directly from the file specified in <cite>D.data.fname</cite> using
Fortran-order reshaping to match SPM’s internal data layout.</p></li>
<li><p>The returned time vector is derived from <cite>timeOnset</cite>, <cite>Fsample</cite>, and <cite>Nsamples</cite>
fields within the dataset.</p></li>
<li><p>Non-MEG modalities (e.g., EEG, EOG, EMG) are excluded automatically.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.make_directory">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">make_directory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extended_dir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.make_directory" title="Permalink to this definition">#</a></dt>
<dd><p>Create a directory (and all necessary parent directories) within a specified root path.</p>
<p>This function ensures that the full directory path exists, creating intermediate directories
as needed. It supports both single directory names and nested paths provided as lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root_path</strong> (<em>str</em><em> or </em><em>pathlib.Path</em>) – The root directory in which to create the new directory or directories.</p></li>
<li><p><strong>extended_dir</strong> (<em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – Subdirectory (or sequence of nested subdirectories) to be created within <cite>root_path</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>root_path</strong> – Path object representing the created directory.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pathlib.Path</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Existing directories are preserved (<cite>exist_ok=True</cite>).</p></li>
<li><p>Intermediate directories are automatically created (<cite>parents=True</cite>).</p></li>
<li><p>Useful for ensuring consistent directory structure in data processing pipelines.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.spm_context">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">spm_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.spm_context" title="Permalink to this definition">#</a></dt>
<dd><p>Context manager for safe initialization and termination of standalone SPM sessions.</p>
<p>This utility ensures proper lifecycle management of SPM standalone instances when executing
MATLAB-based analyses (e.g., source reconstruction or simulation). It supports both
user-supplied SPM sessions and automatic instantiation of temporary ones with optional
parallelization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spm</strong> (<em>spm_standalone</em><em>, </em><em>optional</em>) – Existing SPM standalone instance. If None, a new instance is launched and automatically
terminated upon context exit (default: None).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of MATLAB parallel workers to initialize via <cite>parpool</cite>. Default is 4.</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>spm</strong> (<em>spm_standalone</em>) – Active standalone SPM instance usable within the context.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Designed for use within a <cite>with</cite> block to ensure safe cleanup of MATLAB processes.</p></li>
<li><p>If <cite>spm</cite> is None, a new standalone SPM session is created with a parallel pool of size
<cite>n_jobs</cite>, and both are terminated automatically upon exit.</p></li>
<li><p>If an existing <cite>spm</cite> instance is provided, it is reused and not terminated at the end of the
context.</p></li>
<li><p>The default setting (<cite>n_jobs=4</cite>) is suitable for standard workstations; higher values may
be beneficial on high-performance computing (HPC) systems.</p></li>
<li><p>Ensures robustness against MATLAB errors when initializing or closing <cite>parpool</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.ttest_rel_corrected">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">ttest_rel_corrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.util.ttest_rel_corrected" title="Permalink to this definition">#</a></dt>
<dd><p>Perform a corrected paired-sample t-test with NaN handling and variance stabilization.</p>
<p>This function computes a t-statistic, degrees of freedom, and p-value for paired data while
accounting for potential missing values (NaNs) and small-sample variance instabilities.
A correction term is applied to the variance to prevent division by zero or underflow
when the variance is near zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em>) – Input data array (typically representing paired differences), where the t-test is
computed along the specified axis. NaN values are ignored in statistical computations.</p></li>
<li><p><strong>correction</strong> (<em>float</em><em>, </em><em>optional</em>) – Variance correction term. If 0 (default), an adaptive correction of
<cite>0.01 * max(variance)</cite> is applied automatically.</p></li>
<li><p><strong>tail</strong> (<em>{0</em><em>, </em><em>1</em><em>, </em><em>-1}</em><em>, </em><em>optional</em>) – Specifies the type of test:
- <cite>0</cite>: two-tailed test (default)
- <cite>1</cite>: right-tailed test
- <cite>-1</cite>: left-tailed test</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em>) – Axis along which the t-test is performed. Default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>tval</strong> (<em>float or ndarray</em>) – Computed t-statistic(s).</p></li>
<li><p><strong>deg_of_freedom</strong> (<em>int or ndarray</em>) – Degrees of freedom associated with each test.</p></li>
<li><p><strong>p_val</strong> (<em>float or ndarray</em>) – Corresponding p-value(s).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Missing values (NaNs) are excluded from mean and variance computations.</p></li>
<li><p>The standard error includes the correction term to ensure numerical stability.</p></li>
<li><p>For two-tailed tests, <cite>p = 2 * t.sf(|tval|, df)</cite>; for one-tailed, <cite>p = t.sf(-tval, df)</cite> or
<cite>p = t.cdf(tval, df)</cite> depending on direction.</p></li>
<li><p>This test is useful for robust paired-sample comparisons when small variance or missing
data may otherwise bias standard t-test results.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.viz">
<span id="lameg-viz-module"></span><h2>lameg.viz module<a class="headerlink" href="#module-lameg.viz" title="Permalink to this heading">#</a></h2>
<p>Visualization and color mapping utilities for laminar and cortical surface data.</p>
<p>This module provides a set of functions for visualizing laminar MEG and cortical data, including
color mapping utilities, 3D surface rendering, and Current Source Density (CSD) plotting. It
integrates seamlessly with FreeSurfer surfaces, laMEG outputs, and matplotlib-based plotting
pipelines.</p>
<section id="main-features">
<h3>Main Features<a class="headerlink" href="#main-features" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>Color Mapping</strong>:
- Convert numerical data into RGB, RGBA, or hexadecimal color representations.
- Support for diverging, linear, and logarithmic normalization schemes.
- Utilities for encoding RGB triplets as 32-bit integers for compact graphical representation.</p></li>
<li><p><strong>Surface Visualization</strong>:
- Render 3D cortical surfaces using the <cite>k3d</cite> engine.
- Overlay vertex-wise statistical maps, curvature-based shading, and anatomical markers.
- Interactive camera controls and scene export support.</p></li>
<li><p><strong>Laminar Data Visualization</strong>:
- Visualization of Current Source Density (CSD) profiles across cortical layers.
- Optional display of laminar boundaries and custom color scaling.</p></li>
</ul>
</section>
<section id="id4">
<h3>Functions<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<dl class="simple">
<dt>data_to_rgb(data, n_bins, cmap, vmin, vmax, vcenter=0.0, ret_map=False, norm=’TS’)</dt><dd><p>Map numerical data to RGBA colors using matplotlib colormaps with specified normalization.</p>
</dd>
<dt>rgbtoint(rgb)</dt><dd><p>Convert an RGB color triplet to a 32-bit integer color code.</p>
</dd>
<dt>color_map(data, cmap, vmin, vmax, n_bins=1000, vcenter=0, norm=’TS’)</dt><dd><p>Map numerical data to hexadecimal color codes suitable for visualization.</p>
</dd>
<dt>show_surface(surf_set, layer_name=’inflated’, stage=’combined’, …)</dt><dd><p>Render a cortical or laminar surface with optional curvature, color, and marker overlays.</p>
</dd>
<dt>plot_csd(csd, times, axis, colorbar=True, cmap=’RdBu_r’, …)</dt><dd><p>Plot a 2D laminar Current Source Density (CSD) profile over time.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All functions are designed to integrate with laMEG’s surface and layer representations.</p></li>
<li><p>Surface visualization relies on <cite>k3d</cite> for GPU-accelerated rendering.</p></li>
<li><p>The module assumes FreeSurfer-compatible surface files and curvature data.</p></li>
</ul>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.color_map">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">color_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.color_map" title="Permalink to this definition">#</a></dt>
<dd><p>Map numerical data to hexadecimal color codes using a specified matplotlib colormap.</p>
<p>This function normalizes numerical data using a chosen normalization scheme, maps values to
RGB colors via a matplotlib colormap, and converts them to hexadecimal format suitable for
visualization (e.g., in surface plots or colorbar annotations).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>,</em><em>)</em>) – One-dimensional array of numerical values to be color-mapped.</p></li>
<li><p><strong>cmap</strong> (<em>str</em>) – Name of the matplotlib colormap (e.g., <cite>‘viridis’</cite>, <cite>‘RdBu_r’</cite>).</p></li>
<li><p><strong>vmin</strong> (<em>float</em>) – Minimum data value for normalization.</p></li>
<li><p><strong>vmax</strong> (<em>float</em>) – Maximum data value for normalization.</p></li>
<li><p><strong>n_bins</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of histogram bins used to discretize the data range. Default is 1000.</p></li>
<li><p><strong>vcenter</strong> (<em>float</em><em>, </em><em>optional</em>) – Center value for diverging normalization (<cite>norm=’TS’</cite>). Default is 0.</p></li>
<li><p><strong>norm</strong> (<em>{'TS'</em><em>, </em><em>'N'</em><em>, </em><em>'LOG'}</em><em>, </em><em>optional</em>) – Type of normalization:
- <cite>‘TS’</cite>: Two-slope (diverging) normalization.
- <cite>‘N’</cite>: Linear normalization.
- <cite>‘LOG’</cite>: Logarithmic normalization.
Default is <cite>‘TS’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>map_colors</strong> (<em>ndarray, shape (n,)</em>) – Array of hexadecimal color codes corresponding to the input data values.</p></li>
<li><p><strong>cmap</strong> (<em>matplotlib.colors.Colormap</em>) – The matplotlib colormap object used for mapping.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Internally uses <cite>data_to_rgb()</cite> to compute RGBA values, which are then scaled and converted
to hexadecimal color codes.</p></li>
<li><p>The <cite>‘TS’</cite> normalization is suited for data centered around a neutral reference (e.g., zero).</p></li>
<li><p>Useful for generating vertex-wise color encodings or colorbars consistent with matplotlib
colormaps.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.data_to_rgb">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">data_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TS'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.data_to_rgb" title="Permalink to this definition">#</a></dt>
<dd><p>Map numerical data values to RGB colors using a specified matplotlib colormap.</p>
<p>This function normalizes input data according to a chosen scaling mode (two-slope, linear,
or logarithmic), bins the data into a specified number of intervals, and maps each bin to
an RGB color value. It optionally returns the colormap object for use in associated plots
(e.g., colorbars).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>n</em><em>,</em><em>)</em>) – One-dimensional array of numerical values to be color-mapped.</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – Number of histogram bins used to discretize the data range.</p></li>
<li><p><strong>cmap</strong> (<em>str</em>) – Name of the matplotlib colormap (e.g., <cite>‘viridis’</cite>, <cite>‘RdBu_r’</cite>).</p></li>
<li><p><strong>vmin</strong> (<em>float</em>) – Minimum data value for normalization.</p></li>
<li><p><strong>vmax</strong> (<em>float</em>) – Maximum data value for normalization.</p></li>
<li><p><strong>vcenter</strong> (<em>float</em><em>, </em><em>optional</em>) – Center value for the colormap when using two-slope normalization (<cite>norm=”TS”</cite>).
Default is 0.0.</p></li>
<li><p><strong>ret_map</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, return the matplotlib <cite>ScalarMappable</cite> object along with the mapped RGB values.
Default is False.</p></li>
<li><p><strong>norm</strong> (<em>{'TS'</em><em>, </em><em>'N'</em><em>, </em><em>'LOG'}</em><em>, </em><em>optional</em>) – Normalization type:
- <cite>‘TS’</cite>: Two-slope normalization (diverging colormap, zero-centered)
- <cite>‘N’</cite>: Linear normalization
- <cite>‘LOG’</cite>: Logarithmic normalization
Default is <cite>‘TS’</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>color_mapped</strong> (<em>ndarray, shape (n, 4)</em>) – Array of RGBA color values corresponding to each input datum.</p></li>
<li><p><strong>scalar_map</strong> (<em>matplotlib.cm.ScalarMappable, optional</em>) – The colormap object used for mapping (returned only if <cite>ret_map=True</cite>).</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>norm</cite> is not one of <cite>‘TS’</cite>, <cite>‘N’</cite>, or <cite>‘LOG’</cite>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assigns each data point the color of its corresponding histogram bin.</p></li>
<li><p>The <cite>‘TS’</cite> normalization is best suited for data centered around a neutral reference value
(e.g., 0), producing balanced diverging colormaps.</p></li>
<li><p>The returned colors can be directly used for visualizing scalar data distributions or
as vertex colors in surface plots.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.plot_csd">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">plot_csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RdBu_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin_vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_boundaries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.plot_csd" title="Permalink to this definition">#</a></dt>
<dd><p>Visualize a laminar Current Source Density (CSD) profile over time.</p>
<p>This function plots a 2D representation of CSD data (layers × time) using a diverging
colormap to indicate current sources and sinks. It supports automatic or user-defined color
scaling, customizable colormaps, and optional display of laminar boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>csd</strong> (<em>np.ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_layers</em><em>, </em><em>n_times</em><em>)</em>) – CSD matrix to plot, where each row corresponds to a cortical layer and each column to a
time point.</p></li>
<li><p><strong>times</strong> (<em>np.ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_times</em><em>,</em><em>)</em>) – Time vector corresponding to the CSD data columns (in ms).</p></li>
<li><p><strong>axis</strong> (<em>matplotlib.axes.Axes</em>) – Matplotlib axes on which to draw the CSD plot.</p></li>
<li><p><strong>colorbar</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, adds a colorbar indicating CSD amplitude (source/sink polarity). Default is True.</p></li>
<li><p><strong>cmap</strong> (<em>str</em><em>, </em><em>optional</em>) – Colormap name (e.g., <cite>‘RdBu_r’</cite>, <cite>‘viridis’</cite>). Default is <cite>‘RdBu_r’</cite>.</p></li>
<li><p><strong>vmin_vmax</strong> (<em>tuple</em><em> of </em><em>float</em><em> or </em><em>{'norm'</em><em>, </em><em>None}</em><em>, </em><em>optional</em>) – Color normalization limits:
- (vmin, vmax): explicit color scale limits,
- <cite>‘norm’</cite>: symmetric normalization based on maximum absolute CSD value,
- None: uses full data range. Default is None.</p></li>
<li><p><strong>n_layers</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of cortical layers represented in the CSD matrix. Default is 11.</p></li>
<li><p><strong>layer_boundaries</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Optional array of y-axis positions marking laminar boundaries. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>im</strong> (<em>matplotlib.image.AxesImage</em>) – The plotted image object.</p></li>
<li><p><strong>cb</strong> (<em>matplotlib.colorbar.Colorbar or None</em>) – The colorbar object, if <cite>colorbar=True</cite>, otherwise None.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Assumes CSD is in units of current per unit area (e.g., uA/mm²).</p></li>
<li><p>Negative values (blue) typically represent current sinks; positive values (red) represent
sources.</p></li>
<li><p>If <cite>layer_boundaries</cite> is provided, horizontal lines are drawn at those positions.</p></li>
<li><p>Suitable for visualizing laminar profiles from simulations, hpMEG reconstructions, or
LFP-derived CSD estimates.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.rgbtoint">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">rgbtoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.rgbtoint" title="Permalink to this definition">#</a></dt>
<dd><p>Convert an RGB triplet to a 32-bit integer color representation.</p>
<p>This function encodes red, green, and blue components (0-255) into a single 32-bit integer,
enabling compact storage or low-level graphical interfacing. The resulting integer can be
decoded back into RGB components via bitwise operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rgb</strong> (<em>array_like</em><em> of </em><em>int</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – RGB color triplet with values in the range [0, 255].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>color</strong> – 32-bit integer encoding of the input RGB color.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AssertionError</strong> – If any RGB component is outside the valid range [0, 255].</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Values are packed in big-endian order: <cite>R &lt;&lt; 16 | G &lt;&lt; 8 | B</cite>.</p></li>
<li><p>Useful for transferring color information to graphics libraries that use integer encoding.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.show_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">show_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surf_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inflated'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ds'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">menu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker_coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marker_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_curvature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lameg.viz.show_surface" title="Permalink to this definition">#</a></dt>
<dd><p>Render a 3D cortical surface with optional curvature, vertex-wise data, and marker overlays.</p>
<p>This function visualizes a laminar or pial surface loaded from a <cite>LayerSurfaceSet</cite> object
using the <cite>k3d</cite> rendering backend. It supports curvature shading, vertex-specific color
mapping, and visualization of fiducial or region markers, providing a flexible interactive
3D view of laminar or anatomical surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surf_set</strong> (<a class="reference internal" href="#lameg.surf.LayerSurfaceSet" title="lameg.surf.LayerSurfaceSet"><em>LayerSurfaceSet</em></a>) – Layer surface container providing access to laminar or pial surfaces.</p></li>
<li><p><strong>layer_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the layer to render (e.g., <cite>‘pial’</cite>, <cite>‘white’</cite>, <cite>‘inflated’</cite>). Default is
<cite>‘inflated’</cite>.</p></li>
<li><p><strong>stage</strong> (<em>{'combined'</em><em>, </em><em>'ds'}</em><em>, </em><em>optional</em>) – Rendering stage: <cite>‘combined’</cite> for merged hemispheres, <cite>‘ds’</cite> for downsampled single
surfaces. Default is <cite>‘combined’</cite>.</p></li>
<li><p><strong>hemi</strong> (<em>{'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – Hemisphere to render. Required if <cite>stage=’ds’</cite>. Default is None.</p></li>
<li><p><strong>orientation</strong> (<em>str</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Downsampling orientation identifier used when <cite>stage=’ds’</cite>. Ignored otherwise.</p></li>
<li><p><strong>fixed</strong> (<em>bool</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Whether to load fixed or adaptive orientation surfaces when <cite>stage=’ds’</cite>. Default is None.</p></li>
<li><p><strong>color</strong> (<em>array_like</em><em> of </em><em>int</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Base RGB color of the surface (0-255). Default is <cite>[166, 166, 166]</cite>.</p></li>
<li><p><strong>grid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display background grid. Default is False.</p></li>
<li><p><strong>menu</strong> (<em>bool</em><em>, </em><em>optional</em>) – Display interactive visualization menu. Default is False.</p></li>
<li><p><strong>vertex_colors</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Vertex-wise colors specified as either RGB(A) values or packed 32-bit integers. Default is
None.</p></li>
<li><p><strong>info</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints surface metadata (e.g., vertex count). Default is False.</p></li>
<li><p><strong>camera_view</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Predefined camera position and orientation. If None, automatic camera fitting is used.
Default is None.</p></li>
<li><p><strong>height</strong> (<em>int</em><em>, </em><em>optional</em>) – Plot height in pixels. Default is 512.</p></li>
<li><p><strong>opacity</strong> (<em>float</em><em>, </em><em>optional</em>) – Surface opacity (0 = transparent, 1 = opaque). Default is 1.0.</p></li>
<li><p><strong>marker_coords</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Marker coordinates (n × 3) in the same space as the surface vertices.</p></li>
<li><p><strong>marker_vertices</strong> (<em>array_like</em><em> of </em><em>int</em><em>, </em><em>optional</em>) – Vertex indices to highlight as markers (used instead of explicit coordinates if provided).</p></li>
<li><p><strong>marker_size</strong> (<em>float</em><em> or </em><em>sequence</em><em>, </em><em>optional</em>) – Size (radius) of marker spheres. Default is 1.0.</p></li>
<li><p><strong>marker_color</strong> (<em>array_like</em><em>, </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>) or </em><em>(</em><em>n</em><em>, </em><em>3</em><em>)</em><em>, </em><em>optional</em>) – RGB color(s) of marker spheres (0-255). Default is <cite>[255, 0, 0]</cite>.</p></li>
<li><p><strong>plot_curvature</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, overlays sulcal curvature shading derived from FreeSurfer <cite>.curv</cite> files. Default
is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>plot</strong> – Interactive <cite>k3d</cite> plot object containing the rendered surface and optional overlays.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>k3d.plot.Plot</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Supports both per-vertex color overlays (e.g., statistical maps) and curvature-based shading.</p></li>
<li><p>Vertex colors with an alpha channel (RGBA) use transparency to blend with curvature shading.</p></li>
<li><p>Curvature values are mapped to grayscale for sulcal and gyral regions.</p></li>
<li><p>If both <cite>marker_vertices</cite> and <cite>marker_coords</cite> are provided, the function prioritizes
<cite>marker_vertices</cite>.</p></li>
<li><p>Compatible with <cite>fsaverage</cite>-aligned surfaces and laminar surface sets generated by laMEG.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lameg" title="Permalink to this heading">#</a></h2>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.invert">lameg.invert module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#main-functionalities">Main functionalities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.check_inversion_exists"><code class="docutils literal notranslate"><span class="pre">check_inversion_exists()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.coregister"><code class="docutils literal notranslate"><span class="pre">coregister()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.get_lead_field_rms_diff"><code class="docutils literal notranslate"><span class="pre">get_lead_field_rms_diff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.invert_ebb"><code class="docutils literal notranslate"><span class="pre">invert_ebb()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.invert_msp"><code class="docutils literal notranslate"><span class="pre">invert_msp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.invert_sliding_window"><code class="docutils literal notranslate"><span class="pre">invert_sliding_window()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.load_forward_model_vertices"><code class="docutils literal notranslate"><span class="pre">load_forward_model_vertices()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.invert.load_source_time_series"><code class="docutils literal notranslate"><span class="pre">load_source_time_series()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.laminar">lameg.laminar module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-functionalities">Key functionalities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.compute_csd"><code class="docutils literal notranslate"><span class="pre">compute_csd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.model_comparison"><code class="docutils literal notranslate"><span class="pre">model_comparison()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.roi_power_comparison"><code class="docutils literal notranslate"><span class="pre">roi_power_comparison()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.laminar.sliding_window_model_comparison"><code class="docutils literal notranslate"><span class="pre">sliding_window_model_comparison()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.simulate">lameg.simulate module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Key functionalities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.simulate.run_current_density_simulation"><code class="docutils literal notranslate"><span class="pre">run_current_density_simulation()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.simulate.run_dipole_simulation"><code class="docutils literal notranslate"><span class="pre">run_dipole_simulation()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.surf">lameg.surf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#public-api">Public API</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classes">Classes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#functions">Functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.subj_id"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.subj_id</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.n_layers"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.n_layers</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.layer_spacing"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.layer_spacing</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.subjects_dir"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.subjects_dir</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.subj_dir"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.subj_dir</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.mri_file"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.mri_file</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.surf_dir"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.surf_dir</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.laminar_surf_dir"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.laminar_surf_dir</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.__init__"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.__init__()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.compute_dipole_orientations"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.compute_dipole_orientations()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.create"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.create()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.downsample"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.downsample()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_bigbrain_layer_boundaries"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_bigbrain_layer_boundaries()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_cortical_thickness"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_cortical_thickness()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_distance_to_scalp"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_distance_to_scalp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_layer_names"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_layer_names()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_mesh_path"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_mesh_path()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_multilayer_vertex"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_multilayer_vertex()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_radiality_to_scalp"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_radiality_to_scalp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.get_vertices_per_layer"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.get_vertices_per_layer()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.interpolate_layer_data"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.interpolate_layer_data()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.load"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.load()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.load_meta"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.load_meta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.map_between_stages"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.map_between_stages()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.save"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.save()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.update_meta"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.update_meta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.LayerSurfaceSet.validate"><code class="docutils literal notranslate"><span class="pre">LayerSurfaceSet.validate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.convert_fsaverage_to_native"><code class="docutils literal notranslate"><span class="pre">convert_fsaverage_to_native()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.convert_native_to_fsaverage"><code class="docutils literal notranslate"><span class="pre">convert_native_to_fsaverage()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.surf.interpolate_data"><code class="docutils literal notranslate"><span class="pre">interpolate_data()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.util">lameg.util module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#core-functionalities">Core functionalities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.batch"><code class="docutils literal notranslate"><span class="pre">batch()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.big_brain_proportional_layer_boundaries"><code class="docutils literal notranslate"><span class="pre">big_brain_proportional_layer_boundaries()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.calc_prop"><code class="docutils literal notranslate"><span class="pre">calc_prop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.check_freesurfer_setup"><code class="docutils literal notranslate"><span class="pre">check_freesurfer_setup()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.check_many"><code class="docutils literal notranslate"><span class="pre">check_many()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.coregister_3d_scan_mri"><code class="docutils literal notranslate"><span class="pre">coregister_3d_scan_mri()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.ctf_fif_spm_conversion"><code class="docutils literal notranslate"><span class="pre">ctf_fif_spm_conversion()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_directories"><code class="docutils literal notranslate"><span class="pre">get_directories()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_fiducial_coords"><code class="docutils literal notranslate"><span class="pre">get_fiducial_coords()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.get_files"><code class="docutils literal notranslate"><span class="pre">get_files()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.load_meg_sensor_data"><code class="docutils literal notranslate"><span class="pre">load_meg_sensor_data()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.make_directory"><code class="docutils literal notranslate"><span class="pre">make_directory()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.spm_context"><code class="docutils literal notranslate"><span class="pre">spm_context()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.util.ttest_rel_corrected"><code class="docutils literal notranslate"><span class="pre">ttest_rel_corrected()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg.viz">lameg.viz module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#main-features">Main Features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.color_map"><code class="docutils literal notranslate"><span class="pre">color_map()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.data_to_rgb"><code class="docutils literal notranslate"><span class="pre">data_to_rgb()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.plot_csd"><code class="docutils literal notranslate"><span class="pre">plot_csd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.rgbtoint"><code class="docutils literal notranslate"><span class="pre">rgbtoint()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lameg.viz.show_surface"><code class="docutils literal notranslate"><span class="pre">show_surface()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-lameg">Module contents</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  
  <div class="tocsection editthispage">
    <a href="https://github.com/danclab/laMEG/edit/master/docs/_source/lameg.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

  <div class="sidebar-secondary-item">
  <div class="tocsection sourcelink">
    <a href="../_sources/_source/lameg.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2024, DANC lab.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>