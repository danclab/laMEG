<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>lameg package &#8212; laMEG 0.0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          laMEG</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="modules.html">API</a></li>
                <li><a href="https://github.com/danclab/laMEG">GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">lameg package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lameg.invert">lameg.invert module</a><ul>
<li><a class="reference internal" href="#lameg.invert.coregister"><code class="docutils literal notranslate"><span class="pre">coregister()</span></code></a></li>
<li><a class="reference internal" href="#lameg.invert.invert_ebb"><code class="docutils literal notranslate"><span class="pre">invert_ebb()</span></code></a></li>
<li><a class="reference internal" href="#lameg.invert.invert_msp"><code class="docutils literal notranslate"><span class="pre">invert_msp()</span></code></a></li>
<li><a class="reference internal" href="#lameg.invert.invert_sliding_window"><code class="docutils literal notranslate"><span class="pre">invert_sliding_window()</span></code></a></li>
<li><a class="reference internal" href="#lameg.invert.load_source_time_series"><code class="docutils literal notranslate"><span class="pre">load_source_time_series()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-lameg.laminar">lameg.laminar module</a><ul>
<li><a class="reference internal" href="#lameg.laminar.compute_csd"><code class="docutils literal notranslate"><span class="pre">compute_csd()</span></code></a></li>
<li><a class="reference internal" href="#lameg.laminar.model_comparison"><code class="docutils literal notranslate"><span class="pre">model_comparison()</span></code></a></li>
<li><a class="reference internal" href="#lameg.laminar.roi_power_comparison"><code class="docutils literal notranslate"><span class="pre">roi_power_comparison()</span></code></a></li>
<li><a class="reference internal" href="#lameg.laminar.sliding_window_model_comparison"><code class="docutils literal notranslate"><span class="pre">sliding_window_model_comparison()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-lameg.simulate">lameg.simulate module</a><ul>
<li><a class="reference internal" href="#lameg.simulate.run_current_density_simulation"><code class="docutils literal notranslate"><span class="pre">run_current_density_simulation()</span></code></a></li>
<li><a class="reference internal" href="#lameg.simulate.run_dipole_simulation"><code class="docutils literal notranslate"><span class="pre">run_dipole_simulation()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-lameg.surf">lameg.surf module</a><ul>
<li><a class="reference internal" href="#lameg.surf.combine_surfaces"><code class="docutils literal notranslate"><span class="pre">combine_surfaces()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.compute_dipole_orientations"><code class="docutils literal notranslate"><span class="pre">compute_dipole_orientations()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.create_layer_mesh"><code class="docutils literal notranslate"><span class="pre">create_layer_mesh()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.create_surf_gifti"><code class="docutils literal notranslate"><span class="pre">create_surf_gifti()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.downsample_multiple_surfaces"><code class="docutils literal notranslate"><span class="pre">downsample_multiple_surfaces()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.downsample_single_surface"><code class="docutils literal notranslate"><span class="pre">downsample_single_surface()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.find_non_manifold_edges"><code class="docutils literal notranslate"><span class="pre">find_non_manifold_edges()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.fix_non_manifold_edges"><code class="docutils literal notranslate"><span class="pre">fix_non_manifold_edges()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.interpolate_data"><code class="docutils literal notranslate"><span class="pre">interpolate_data()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.iterative_downsample_single_surface"><code class="docutils literal notranslate"><span class="pre">iterative_downsample_single_surface()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.mesh_adjacency"><code class="docutils literal notranslate"><span class="pre">mesh_adjacency()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.mesh_normals"><code class="docutils literal notranslate"><span class="pre">mesh_normals()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.postprocess_freesurfer_surfaces"><code class="docutils literal notranslate"><span class="pre">postprocess_freesurfer_surfaces()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.remove_unconnected_vertices"><code class="docutils literal notranslate"><span class="pre">remove_unconnected_vertices()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.remove_vertices"><code class="docutils literal notranslate"><span class="pre">remove_vertices()</span></code></a></li>
<li><a class="reference internal" href="#lameg.surf.split_fv"><code class="docutils literal notranslate"><span class="pre">split_fv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-lameg.util">lameg.util module</a><ul>
<li><a class="reference internal" href="#lameg.util.batch"><code class="docutils literal notranslate"><span class="pre">batch()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.big_brain_proportional_layer_boundaries"><code class="docutils literal notranslate"><span class="pre">big_brain_proportional_layer_boundaries()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.calc_prop"><code class="docutils literal notranslate"><span class="pre">calc_prop()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.check_many"><code class="docutils literal notranslate"><span class="pre">check_many()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.convert_fsaverage_to_native"><code class="docutils literal notranslate"><span class="pre">convert_fsaverage_to_native()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.convert_native_to_fsaverage"><code class="docutils literal notranslate"><span class="pre">convert_native_to_fsaverage()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.ctf_fif_spm_conversion"><code class="docutils literal notranslate"><span class="pre">ctf_fif_spm_conversion()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.get_bigbrain_layer_boundaries"><code class="docutils literal notranslate"><span class="pre">get_bigbrain_layer_boundaries()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.get_directories"><code class="docutils literal notranslate"><span class="pre">get_directories()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.get_fiducial_coords"><code class="docutils literal notranslate"><span class="pre">get_fiducial_coords()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.get_files"><code class="docutils literal notranslate"><span class="pre">get_files()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.get_surface_names"><code class="docutils literal notranslate"><span class="pre">get_surface_names()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.load_meg_sensor_data"><code class="docutils literal notranslate"><span class="pre">load_meg_sensor_data()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.make_directory"><code class="docutils literal notranslate"><span class="pre">make_directory()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.spm_context"><code class="docutils literal notranslate"><span class="pre">spm_context()</span></code></a></li>
<li><a class="reference internal" href="#lameg.util.ttest_rel_corrected"><code class="docutils literal notranslate"><span class="pre">ttest_rel_corrected()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-lameg.viz">lameg.viz module</a><ul>
<li><a class="reference internal" href="#lameg.viz.color_map"><code class="docutils literal notranslate"><span class="pre">color_map()</span></code></a></li>
<li><a class="reference internal" href="#lameg.viz.data_to_rgb"><code class="docutils literal notranslate"><span class="pre">data_to_rgb()</span></code></a></li>
<li><a class="reference internal" href="#lameg.viz.plot_csd"><code class="docutils literal notranslate"><span class="pre">plot_csd()</span></code></a></li>
<li><a class="reference internal" href="#lameg.viz.rgbtoint"><code class="docutils literal notranslate"><span class="pre">rgbtoint()</span></code></a></li>
<li><a class="reference internal" href="#lameg.viz.show_surface"><code class="docutils literal notranslate"><span class="pre">show_surface()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-lameg">Module contents</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="_sources/lameg.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section id="lameg-package">
<h1>lameg package<a class="headerlink" href="#lameg-package" title="Permalink to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-lameg.invert">
<span id="lameg-invert-module"></span><h2>lameg.invert module<a class="headerlink" href="#module-lameg.invert" title="Permalink to this heading">¶</a></h2>
<p>This module provides tools for the coregistration, and source reconstruction of MEG/EEG data
utilizing MATLAB and SPM (Statistical Parametric Mapping) functionalities.
Key operations include:</p>
<ul class="simple">
<li><p>Coregistration of head models with MRI and mesh data.</p></li>
<li><p>Empirical Bayesian Beamformer (EBB) and Multiple Sparse Priors (MSP) source reconstruction
algorithms.</p></li>
<li><p>Utility function for loading source data after source reconstruction.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.coregister">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">coregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mri_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fid_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('nas',</span> <span class="pre">'lpa',</span> <span class="pre">'rpa')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/invert.html#coregister"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.invert.coregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Run head coregistration.</p>
<p>This function interfaces with MATLAB to perform head coregistration on MEG/EEG data using an
MRI and mesh</p>
<p>Parameters:
nas (list): NASion fiducial coordinates.
lpa (list): Left PreAuricular fiducial coordinates.
rpa (list): Right PreAuricular fiducial coordinates.
mri_fname (str): Filename of the MRI data.
mesh_fname (str): Filename of the mesh data.
data_fname (str): Filename of the MEG/EEG data.
fid_labels (list): Fiducial coordinate labels. Default is [‘nas’, ‘lpa’, ‘rpa’]
viz (boolean, optional): Whether or not to show SPM visualization. Default is True
spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_ebb">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_ebb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_folds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ideal_pc_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/invert.html#invert_ebb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.invert.invert_ebb" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the Empirical Bayesian Beamformer (EBB) source reconstruction algorithm.</p>
<p>This function interfaces with MATLAB to perform EBB source reconstruction on MEG/EEG data.
It involves mesh smoothing and running the EBB algorithm in MATLAB. The MEG/EEG data must
already be coregistered with the given mesh.</p>
<p>Parameters:
mesh_fname (str): Filename of the mesh data.
data_fname (str): Filename of the MEG/EEG data.
n_layers (int): Number of layers in the mesh.
patch_size (int, optional): Patch size for mesh smoothing. Default is 5.
n_temp_modes (int, optional): Number of temporal modes for the beamformer. Default is 4.
foi (list, optional): Frequency of interest range as [low, high]. Default is [0, 256].
woi (list, optional): Window of interest as [start, end]. Default is [-np.inf, np.inf].
hann_windowing (int, option): Whether or not to perform Hann windowing. Default is False
n_folds (int): Number of cross validation folds. Must be &gt;1 for cross validation error
ideal_pc_test (float): Percentage of channels to leave out (ideal because need an integer</p>
<blockquote>
<div><p>number of channels)</p>
</div></blockquote>
<p>viz (boolean, optional): Whether or not to show SPM visualization. Default is True
mat_eng (matlab.engine.MatlabEngine, optional): Instance of MATLAB engine. Default is None.
return_mu_matrix (boolean, optional): Whether or not to return the matrix needed to reconstruct</p>
<blockquote>
<div><p>source activity. Default is False</p>
</div></blockquote>
<p>spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p>Returns:
list: A list containing the free energy, cross validation error (cv_err), and the matrix needed</p>
<blockquote>
<div><p>to reconstruct source activity (mu_matrix; if return_mu_matrix is True).</p>
</div></blockquote>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_msp">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_msp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_folds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ideal_pc_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/invert.html#invert_msp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.invert.invert_msp" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the Multiple Sparse Priors (MSP) source reconstruction algorithm.</p>
<p>This function interfaces with MATLAB to perform MSP source reconstruction on MEG/EEG data.
It involves mesh smoothing and running the MSP algorithm in MATLAB. The MEG/EEG data must
already be coregistered with the given mesh.</p>
<p>Parameters:
mesh_fname (str): Filename of the mesh data.
data_fname (str): Filename of the MEG/EEG data.
n_layers (int): Number of layers in the mesh.
priors (list, optional): Indices of vertices to be used as priors. Default is an empty list.
patch_size (int, optional): Patch size for mesh smoothing. Default is 5.
n_temp_modes (int, optional): Number of temporal modes for the beamformer. Default is 4.
foi (list, optional): Frequency of interest range as [low, high]. Default is [0, 256].
woi (list, optional): Window of interest as [start, end]. Default is [-np.inf, np.inf].
hann_windowing (int, option): Whether or not to perform Hann windowing. Default is False
n_folds (int): Number of cross validation folds. Must be &gt;1 for cross validation error
ideal_pc_test (float): Percentage of channels to leave out (ideal because need an integer</p>
<blockquote>
<div><p>number of channels)</p>
</div></blockquote>
<p>viz (boolean, optional): Whether or not to show SPM visualization. Default is True
return_mu_matrix (boolean, optional): Whether or not to return the matrix needed to reconstruct</p>
<blockquote>
<div><p>source activity. Default is False</p>
</div></blockquote>
<p>spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p>Returns:
list: A list containing the free energy, cross validation error (cv_err), and the matrix</p>
<blockquote>
<div><p>needed to reconstruct source activity (mu_matrix; if return_mu_matrix is True).</p>
</div></blockquote>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>Priors are adjusted by adding 1 to each index to align with MATLAB’s 1-based indexing.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.invert_sliding_window">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">invert_sliding_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_temp_modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hann_windowing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/invert.html#invert_sliding_window"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.invert.invert_sliding_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the Multiple Sparse Priors (MSP) source reconstruction algorithm in a sliding time window.</p>
<p>This function interfaces with MATLAB to perform MSP source reconstruction on MEG/EEG data
within sliding time windows. It involves mesh smoothing and running the MSP algorithm in
MATLAB for each time window. The MEG/EEG data must already be coregistered with the given
mesh.</p>
<p>Parameters:
prior (float): Index of the vertex to be used as a prior.
mesh_fname (str): Filename of the mesh data.
data_fname (str): Filename of the MEG/EEG data.
n_layers (int): Number of layers in the mesh.
patch_size (int, optional): Patch size for mesh smoothing. Default is 5.
n_temp_modes (int, optional): Number of temporal modes for the beamformer. Default is 1.
win_size (float, optional): Size of the sliding window in ms. Default is 16. If you increase</p>
<blockquote>
<div><p>win_size, you may have to increase n_temp_modes.</p>
</div></blockquote>
<p>win_overlap (bool, optional): Whether the windows should overlap. Default is True.
foi (list, optional): Frequency of interest range as [low, high]. Default is [0, 256].
hann_windowing (bool, optional): Whether or not to use Hann windowing. Default is True
viz (boolean, optional): Whether or not to show SPM visualization. Default is True
spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p>Returns:
list: A list containing the free energy time series (free_energy), and the windows of interest</p>
<blockquote>
<div><p>(wois).</p>
</div></blockquote>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>The prior index is adjusted by adding 1 to align with MATLAB’s 1-based indexing.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.invert.load_source_time_series">
<span class="sig-prename descclassname"><span class="pre">lameg.invert.</span></span><span class="sig-name descname"><span class="pre">load_source_time_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/invert.html#load_source_time_series"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.invert.load_source_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Load source time series data from specified vertices using precomputed inverse solutions or a
lead field matrix.</p>
<p>This function interfaces with MATLAB to extract time series data from specific vertices, based
on precomputed inverse solutions, or computes the source time series using a provided lead
field matrix.</p>
<p>Parameters:
data_fname (str): Filename or path of the MEG/EEG data file.
mu_matrix (ndarray, optional): Lead field matrix (source x sensor). Default is None.
inv_fname (str, optional): Filename or path of the file containing the inverse solutions.</p>
<blockquote>
<div><p>Default is None.</p>
</div></blockquote>
<dl class="simple">
<dt>vertices (list of int, optional): List of vertex indices from which to extract time series</dt><dd><p>data. Default is None, which implies all vertices will be
used.</p>
</dd>
</dl>
<p>Returns:
ndarray: An array containing the extracted source time series data (sources x time x trial).
ndarray: An array containing the timestamps
ndarray: The matrix needed to reconstruct source activity from sensor signals</p>
<p>Notes:
- If ‘inv_fname’ is not provided, and ‘mu_matrix’ is None, the inverse solution from the</p>
<blockquote>
<div><p>MEG/EEG data file specified by ‘data_fname’ will be used.</p>
</div></blockquote>
<ul class="simple">
<li><p>If ‘mu_matrix’ is provided, the function will compute the source time series directly using
the lead field matrix, without the need for precomputed inverse solutions.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.laminar">
<span id="lameg-laminar-module"></span><h2>lameg.laminar module<a class="headerlink" href="#module-lameg.laminar" title="Permalink to this heading">¶</a></h2>
<p>This module provides tools for performing laminar analysis of MEG signals.
It integrates functionalities for coregistering head models, performing source reconstruction
using different methods (Empirical Bayesian Beamformer and Multiple Sparse Priors),
and assessing model fit via free energy calculations. It also includes capabilities
for analyzing laminar current source density and comparing regional brain activity
across different conditions or layers.</p>
<p>The module leverages external libraries such as NumPy, SciPy, neo, quantities,
and proprietary tools like MATLAB alongside the SPM toolkit.
Functions provided allow for complex workflows such as sliding window analysis
for dynamic source reconstruction and laminar analysis for studying laminar cortical activity.</p>
<p>Key functionalities include:
- Coregistration of MEG/EEG data with MRI and mesh models.
- Source reconstruction with options to choose between different methods and evaluate model fits.
- Calculation of current source density from laminar neural signals.
- Comparison of power changes across different regions and layers to identify areas of interest.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.compute_csd">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">compute_csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sfreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/laminar.html#compute_csd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.laminar.compute_csd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the laminar Current Source Density (CSD) from a given signal.</p>
<p>This function calculates CSD using the Standard CSD method. It takes a multi-layered neural
signal, typically from laminar probes, and computes the CSD. An optional smoothing step can
be applied to the CSD output.</p>
<p>Parameters:
signal (numpy.ndarray): The neural signal matrix, where rows correspond to different layers</p>
<blockquote>
<div><p>and columns to time points.</p>
</div></blockquote>
<dl class="simple">
<dt>thickness (float): The laminar thickness of the cortex from which the signal was recorded, in</dt><dd><p>millimeters.</p>
</dd>
</dl>
<p>sfreq (float): Sampling frequency of the signal in Hertz.
smoothing (str, optional): Specifies the kind of smoothing to apply to the CSD. Acceptable</p>
<blockquote>
<div><p>values are those compatible with scipy.interpolate.interp1d, such as
‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, etc.
If None, no smoothing is applied. Default is None.</p>
</div></blockquote>
<p>Returns:
list: A list containing the CSD matrix as the first element. If smoothing is applied, the</p>
<blockquote>
<div><p>second element is the smoothed CSD matrix. The CSD matrix dimensions are layers x time
points.</p>
</div></blockquote>
<p>Notes:
- The function requires the ‘neo’, ‘quantities’ (pq), ‘numpy’ (np), ‘elephant’, and</p>
<blockquote>
<div><p>‘scipy.interpolate.interp1d’ libraries.</p>
</div></blockquote>
<ul class="simple">
<li><p>The CSD is calculated using the Standard CSD method provided by the ‘elephant’ package.</p></li>
<li><p>Smoothing is applied across layers and is independent for each time point.</p></li>
<li><p>The returned CSD matrix has the same number of time points as the input signal but can have a
different number
of layers if smoothing is applied.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.model_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">model_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mri_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fnames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'EBB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coregister_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/laminar.html#model_comparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.laminar.model_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare model fits using different meshes by computing the free energy.</p>
<p>This function runs source reconstruction algorithms (either Empirical Bayesian Beamformer or
Multiple Sparse Priors) on a set of meshes and compares their model fits using the free energy
and cross validation error metrics. It allows for separate configuration of coregistration and
inversion parameters through distinct keyword argument dictionaries.</p>
<p>Parameters:
nas (list): NASion fiducial coordinates.
lpa (list): Left PreAuricular fiducial coordinates.
rpa (list): Right PreAuricular fiducial coordinates.
mri_fname (str): Filename of the MRI data.
mesh_fnames (list): List of filenames for different meshes.
data_fname (str): Filename of the MEG/EEG data.
method (str, optional): Source reconstruction method, either ‘EBB’ or ‘MSP’. Default is ‘EBB’.
viz (boolean, optional): Whether to display SPM visualizations. Default is True.
spm_instance (spm_standalone, optional): Instance of standalone SPM software. Default is None.
coregister_kwargs (dict, optional): Keyword arguments specifically for the coregister function.
invert_kwargs (dict, optional): Keyword arguments specifically for the invert function.</p>
<p>Returns:
tuple: A tuple containing two numpy arrays: the first with the free energy values corresponding</p>
<blockquote>
<div><p>to each mesh, and the second with the cross-validation error for each mesh.</p>
</div></blockquote>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>Free energy is used as a measure of model fit, with higher values indicating better fit.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.roi_power_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">roi_power_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">woi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_woi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc_thresh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/laminar.html#roi_power_comparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.laminar.roi_power_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and compares power changes in pial and white matter layers to define
regions of interest (ROI) based on significant power shifts.</p>
<p>This function calculates power changes in the pial and white matter layers during a specified
window of interest (WOI) and a baseline window. It identifies ROIs by comparing these changes
against a percentile threshold and performs a relative comparison of power changes between
the layers to assess laminar differences.</p>
<p>Parameters:
data_fname (str): Filename of the data file containing source time series.
woi (tuple): Window of interest, specified as a start and end time (in milliseconds).
baseline_woi (tuple): Baseline window of interest for comparison, specified as start and end</p>
<blockquote>
<div><p>time (in milliseconds).</p>
</div></blockquote>
<p>mesh (nibabel.gifti.GiftiImage): Gifti surface mesh.
n_layers (int): Number of layers in the cortical model.
perc_thresh (float): Percentile threshold for determining significant changes in power.
mu_matrix (ndarray, optional): Lead field matrix (source x sensor). Default is None.
chunk_size (int): Number of vertices to load source time series from at ones. If None, will</p>
<blockquote>
<div><p>load all at the same time. Default is None.</p>
</div></blockquote>
<p>Returns:
tuple: Contains laminar t-statistic, laminar p-value, degrees of freedom and indices of</p>
<blockquote>
<div><p>vertices considered as ROIs.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.laminar.sliding_window_model_comparison">
<span class="sig-prename descclassname"><span class="pre">lameg.laminar.</span></span><span class="sig-name descname"><span class="pre">sliding_window_model_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mri_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_fnames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coregister_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/laminar.html#sliding_window_model_comparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.laminar.sliding_window_model_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare model fits across different meshes using a sliding window approach.</p>
<p>This function runs source reconstruction using the Multiple Sparse Priors (MSP) method in
sliding time windows on a set of meshes. It compares the model fits for each mesh by computing
the free energy in each window.</p>
<p>Parameters:
prior (float): Index of the vertex to be used as a prior.
nas (list): NASion fiducial coordinates.
lpa (list): Left PreAuricular fiducial coordinates.
rpa (list): Right PreAuricular fiducial coordinates.
mri_fname (str): Filename of the MRI data.
mesh_fnames (list): List of filenames for different meshes.
data_fname (str): Filename of the MEG/EEG data.
viz (boolean, optional): Whether or not to show SPM visualization. Default is True
spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.
coregister_kwargs (dict, optional): Keyword arguments specifically for the coregister function.
invert_kwargs (dict, optional): Keyword arguments specifically for the invert_sliding_window</p>
<blockquote>
<div><p>function.</p>
</div></blockquote>
<p>Returns:
tuple: A tuple containing a list of free energy values for each mesh and the windows of</p>
<blockquote>
<div><p>interest (wois).</p>
</div></blockquote>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM
instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
<li><p>Free energy is used as a measure of model fit, with higher values indicating better fit.</p></li>
<li><p>The prior index is adjusted by adding 1 to align with MATLAB’s 1-based indexing.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.simulate">
<span id="lameg-simulate-module"></span><h2>lameg.simulate module<a class="headerlink" href="#module-lameg.simulate" title="Permalink to this heading">¶</a></h2>
<p>This module facilitates the simulation of MEG/EEG data using MATLAB’s computing environment and the
Statistical Parametric Mapping (SPM) toolbox. It provides functionalities to simulate both current
density and dipole-based MEG/EEG data under varying conditions and configurations.</p>
<p>Key Features:
- Current Density Simulation: Allows for the simulation of current density data based on</p>
<blockquote>
<div><p>user-defined parameters such as vertices, signals, dipole moments, and patch sizes. Includes the
ability to specify the signal-to-noise ratio and window of interest for the simulations.</p>
</div></blockquote>
<ul class="simple">
<li><p>Dipole Simulation: Facilitates the simulation of dipole-based data, providing options to
configure dipole orientations, moments, and noise levels. It supports the simulation of unique
signals per trial and can average data across trials if needed.</p></li>
<li><p>Integration with MATLAB and SPM: Utilizes MATLAB functions and SPM routines to perform the
simulations.</p></li>
</ul>
<p>The module’s functions accept various inputs to define the simulation conditions and output
simulated MEG/EEG datasets that can be used for further analysis or testing. Both types of
simulations are designed to be flexible, supporting multiple vertices, signal configurations, and
analysis scenarios.</p>
<p>Each function within the module is capable of starting an instance of standalone SPM, provided via
the spm_instance parameter, to handle computations directly within the SPM environment. If no
instance is provided, the functions will initiate a new one and close it upon completion unless
managed externally.</p>
<p>Examples of use:
- Simulating data with specific noise levels and analyzing the impact of noise on signal processing</p>
<blockquote>
<div><p>algorithms.</p>
</div></blockquote>
<ul class="simple">
<li><p>Generating datasets with known properties to test the efficacy of dipole fitting routines or
source localization methods.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.run_current_density_simulation">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">run_current_density_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_signals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_moments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_patch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/simulate.html#run_current_density_simulation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.simulate.run_current_density_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate current density data based on specified parameters.</p>
<p>This function interfaces with MATLAB to generate simulated MEG/EEG data. It creates simulations
based on specified vertices, signals, dipole moments, and patch sizes, incorporating a defined
signal-to-noise ratio (SNR). White noise is added at the sensor level to yield the given SNR.</p>
<p>Parameters:
data_file (str): Filename or path of the MEG/EEG data file used as a template for simulation.
prefix (str): Prefix for the output simulated data filename.
sim_vertices (list or int): Indices of vertices where simulations are centered. Can be a single</p>
<blockquote>
<div><p>integer or a list.</p>
</div></blockquote>
<p>sim_signals (ndarray): Array of simulated signals.
dipole_moments (list or float): Dipole moments for the simulation. Can be a single float or a</p>
<blockquote>
<div><p>list.</p>
</div></blockquote>
<dl class="simple">
<dt>sim_patch_sizes (list or int): Sizes of patches around each vertex for the simulation. Can be a</dt><dd><p>single integer or a list.</p>
</dd>
</dl>
<p>snr (float): Signal-to-noise ratio for the simulation.
sim_woi (list, optional): Window of interest for the simulation as [start, end]. Default is</p>
<blockquote>
<div><p>[-np.inf, np.inf].</p>
</div></blockquote>
<p>spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p>Returns:
str: Filename of the generated simulated data.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.simulate.run_dipole_simulation">
<span class="sig-prename descclassname"><span class="pre">lameg.simulate.</span></span><span class="sig-name descname"><span class="pre">run_dipole_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_signals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_orientations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipole_moments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_patch_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_woi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_trials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/simulate.html#run_dipole_simulation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.simulate.run_dipole_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate dipole-based MEG/EEG data based on specified parameters.</p>
<p>This function interfaces with MATLAB to generate simulated MEG/EEG data with specific dipole
configurations. It creates simulations based on specified vertices, signals, dipole
orientations, moments, and patch sizes, incorporating a defined signal-to-noise ratio (SNR).
White noise is added at the sensor level to yield the given SNR.</p>
<p>Parameters:
data_file (str): Filename or path of the MEG/EEG data file used as a template for simulation.
prefix (str): Prefix for the output simulated data filename.
sim_vertices (list or int): Indices of vertices where simulations are centered. Can be a single</p>
<blockquote>
<div><p>integer or a list.</p>
</div></blockquote>
<dl class="simple">
<dt>sim_signals (ndarray): Array of simulated signals. Either dipoles x time (signal will be used</dt><dd><p>for each trial), or dipoles x time x trials (unique signal for each
trial)</p>
</dd>
</dl>
<p>dipole_orientations (ndarray): Array of dipole orientations for the simulation.
dipole_moments (list or float): Dipole moments for the simulation. Can be a single float or a</p>
<blockquote>
<div><p>list.</p>
</div></blockquote>
<dl class="simple">
<dt>sim_patch_sizes (list or int): Sizes of patches around each vertex for the simulation. Can be a</dt><dd><p>single integer or a list.</p>
</dd>
</dl>
<p>snr (float): Signal-to-noise ratio for the simulation.
sim_woi (list, optional): Window of interest for the simulation as [start, end]. Default is</p>
<blockquote>
<div><p>[-np.inf, np.inf].</p>
</div></blockquote>
<dl class="simple">
<dt>average_trials (bool, optional): Whether to average the simulated data over trials. Default is</dt><dd><p>False.</p>
</dd>
</dl>
<p>spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p>Returns:
str: Filename of the generated simulated data.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.surf">
<span id="lameg-surf-module"></span><h2>lameg.surf module<a class="headerlink" href="#module-lameg.surf" title="Permalink to this heading">¶</a></h2>
<p>This module provides a set of tools for handling and manipulating surface mesh data, primarily
used within neuroimaging and computer graphics contexts. The functionalities include computing mesh
normals, interpolating mesh data, handling non-manifold edges, creating and manipulating GIFTI
surface files, and downsampling meshes using the VTK library.</p>
<p>The functions within the module leverage external libraries such as nibabel for neuroimaging data
management, numpy for numerical operations, scipy for scientific computing tasks like Delaunay
triangulation, and the VTK toolkit for complex mesh processing tasks such as mesh decimation.</p>
<p>Key functionalities include:
- Normalization of vectors to unit length.
- Calculation of normals for mesh surfaces using both Delaunay triangulation and custom methods.
- Creation of GIFTI images from mesh data.
- Removal of specified vertices from a mesh and updating the mesh topology accordingly.
- Identification and handling of non-manifold edges to ensure mesh manifoldness.
- Interpolation of data from a downsampled mesh back to its original high-resolution mesh.
- Downsampling of meshes using VTK’s decimation algorithms.
- Combination and adjustment of multiple surface meshes into a single mesh.</p>
<p>The module supports processing of both individual and multiple surfaces, ensuring that operations
like downsampling, normal computation, and vertex manipulation are optimized for performance and
applicability in both research and clinical environments.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gifti_img</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.combine_surfaces">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">combine_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surfaces</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#combine_surfaces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.combine_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multiple surface meshes into a single surface mesh.</p>
<p>This function takes a list of Gifti surface meshes and combines them into a single surface
mesh. It concatenates the vertices, faces, and normals (if present) from each surface. The
faces are re-indexed appropriately to maintain the correct references to the combined vertex
array.</p>
<p>Parameters:
surfaces (list of nibabel.gifti.GiftiImage): List of Gifti surface meshes to be combined.</p>
<p>Returns:
nibabel.gifti.GiftiImage: A single combined Gifti surface mesh.</p>
<p>Notes:
- The vertices, faces, and normals (if present) from each surface are concatenated.
- The faces are re-indexed to reference the correct vertices in the combined vertex array.
- If normals are present in any of the input surfaces, they are also combined.</p>
<p>Raises:
ValueError: If the vertex or face arrays do not have the expected dimensions.</p>
<p>Example:
&gt;&gt;&gt; import nibabel as nib
&gt;&gt;&gt; surfaces = [nib.load(‘path/to/surface1.gii’), nib.load(‘path/to/surface2.gii’)]
&gt;&gt;&gt; combined_surf = combine_surfaces(surfaces)
&gt;&gt;&gt; nib.save(combined_surf, ‘path/to/combined_surface.gii’)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.compute_dipole_orientations">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">compute_dipole_orientations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#compute_dipole_orientations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.compute_dipole_orientations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute dipole orientations for cortical layers using different methods.</p>
<p>Parameters:
method (str): Method for computing dipole orientations (‘link_vector’, ‘ds_surf_norm’,</p>
<blockquote>
<div><p>‘orig_surf_norm’, or ‘cps’).
link_vector: vectors connecting pial vertices to corresponding white matter</p>
<blockquote>
<div><p>vertices</p>
</div></blockquote>
<p>ds_surf_norm: surface normal vectors computed from the downsampled surface
orig_surf_norm: surface normal vectors computed from the original</p>
<blockquote>
<div><p>(non-downsampled) surface</p>
</div></blockquote>
<dl class="simple">
<dt>cps: cortical patch statistics - mean surface normal vectors from connected</dt><dd><p>vertices in the original (non-downsampled) surface</p>
</dd>
</dl>
</div></blockquote>
<p>layer_names (list): Names of the cortical layers.
surf_dir (str): Directory where the surface files are stored.
fixed (bool, optional): Flag to ensure that orientation of corresponding vertices across</p>
<blockquote>
<div><p>layers is the same (True by default). If true, for ds_surf_norm,
orig_surf_norm, and cps, orientations computed from the pial surface
are used for all layers.</p>
</div></blockquote>
<p>Returns:
numpy.ndarray: An array of dipole orientations for each vertex in each layer.</p>
<p>Raises:
ValueError: If the number of vertices in pial and white surfaces do not match.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.create_layer_mesh">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">create_layer_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemispheres</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs_subject_dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#create_layer_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.create_layer_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Create or retrieve a specified cortical layer mesh file name or path based on the provided
layer proportional thickness or identifier.</p>
<p>Parameters:
layer (float or int): Specifies the cortical layer. The value 1 corresponds to the ‘pial’</p>
<blockquote>
<div><p>surface, values between 0 and 1 (exclusive) correspond to intermediate
layers (specified as a decimal), and the value 0 corresponds to the
‘white’ surface.</p>
</div></blockquote>
<dl class="simple">
<dt>hemispheres (list of str): A list of hemisphere identifiers (e.g., [‘lh’, ‘rh’]) for which</dt><dd><p>meshes should be created or retrieved.</p>
</dd>
<dt>fs_subject_dir (str): Path to the subject directory within the FreeSurfer environment. This</dt><dd><p>directory should include a ‘surf’ directory where mesh files are stored.</p>
</dd>
</dl>
<p>Returns:
str or None: Returns a string representing the mesh layer (‘pial’, ‘white’, or a specific</p>
<blockquote>
<div><p>intermediate layer as a formatted string). Returns None if the input layer does
not match any recognized pattern (e.g., a negative number or a number greater
than 1).</p>
</div></blockquote>
<p>Behavior:
For intermediate layers (0 &lt; layer &lt; 1), the function will check for the existence of the mesh
file corresponding to each hemisphere. If it does not exist, it uses ‘mris_expand’ to generate
it using the white matter surface file. If the layer exactly matches 0 or 1, it returns the
corresponding standard FreeSurfer mesh identifier (‘white’ or ‘pial’).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.create_surf_gifti">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">create_surf_gifti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#create_surf_gifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.create_surf_gifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Gifti image object from surface mesh data.</p>
<p>This function creates a GiftiImage object from the provided vertices, faces, and optional
normals. The vertices and faces are required, while normals are optional. If normals are
provided, they are added to the Gifti image. The function returns the GiftiImage object.</p>
<p>Parameters:
vertices (numpy.ndarray): Array of vertices. Each row represents a vertex with its x, y, z</p>
<blockquote>
<div><p>coordinates.</p>
</div></blockquote>
<dl class="simple">
<dt>faces (numpy.ndarray): Array of faces. Each row represents a face with three integers</dt><dd><p>corresponding to vertex indices.</p>
</dd>
<dt>normals (numpy.ndarray, optional): Array of vertex normals. Each row represents a normal vector</dt><dd><p>corresponding to a vertex.</p>
</dd>
</dl>
<p>Returns:
nibabel.gifti.GiftiImage: The GiftiImage object created from the provided mesh data.</p>
<p>Notes:
- Vertex, face, and normal arrays should be NumPy arrays.
- Vertices and normals should be in float32 format, and faces should be in int32 format.</p>
<p>Example:
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import nibabel as nib
&gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])
&gt;&gt;&gt; faces = np.array([[0, 1, 2], [0, 2, 3]])
&gt;&gt;&gt; normals = np.array([[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]])
&gt;&gt;&gt; gifti_img = create_surf_gifti(vertices, faces, normals)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.downsample_multiple_surfaces">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">downsample_multiple_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_surfs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#downsample_multiple_surfaces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.downsample_multiple_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Downampled multiple surface meshes using the VTK decimation algorithm.</p>
<p>This function takes a list of input surface meshes (in Gifti format) and applies a dowsampling
process to each surface. The downsampling is performed using VTK’s vtkDecimatePro algorithm.
The first surface in the list is downsampled, and its vertex mapping is then applied to all
other surfaces in the list. The function returns a list of downsampled surface meshes.</p>
<p>Parameters:
in_surfs (list of nibabel.gifti.GiftiImage): Input Gifti surface meshes to be downsampled.
ratio (float): The reduction ratio for the downsampling process. For example, a ratio of 0.1</p>
<blockquote>
<div><p>implies that the mesh will be reduced to 90% of its original size.</p>
</div></blockquote>
<p>Returns:
list of nibabel.gifti.GiftiImage: List of downsampled Gifti surface meshes.</p>
<p>Notes:
- The function prints the percentage of vertices retained in the first surface after</p>
<blockquote>
<div><p>downsampling.</p>
</div></blockquote>
<ul class="simple">
<li><p>If normals are present in the input surfaces, they are also downsampled and mapped to the
new surfaces.</p></li>
<li><p>The resulting surfaces maintain the original topology and are suitable for visualization and
further processing.</p></li>
</ul>
<p>Example:
&gt;&gt;&gt; import nibabel as nib
&gt;&gt;&gt; in_surfs = [nib.load(‘path/to/input_surf1.gii’), nib.load(‘path/to/input_surf2.gii’)]
&gt;&gt;&gt; ratio = 0.1
&gt;&gt;&gt; out_surfs = downsample_multiple_surfaces(in_surfs, ds_factor)
&gt;&gt;&gt; for i, ds_surf in enumerate(out_surfs):
…     nib.save(ds_surf, f’path/to/output_surf{i+1}.gii’)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.downsample_single_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">downsample_single_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#downsample_single_surface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.downsample_single_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample a Gifti surface using the VTK library.</p>
<p>This function takes a Gifti surface defined by its vertices and faces, and downsamples it using
VTK’s vtkDecimatePro algorithm. The reduction ratio determines the degree of downsampling.
The function returns the downsampled Gifti surface.</p>
<p>Parameters:
gifti_surf (nibabel.gifti.GiftiImage): The Gifti surface object from which vertices will be</p>
<blockquote>
<div><p>removed.</p>
</div></blockquote>
<dl class="simple">
<dt>reduction_ratio (float): The proportion of the mesh to remove. For example, a reduction ratio</dt><dd><p>of 0.1 retains 90% of the original mesh.</p>
</dd>
</dl>
<p>Returns:
nibabel.gifti.GiftiImage: A new GiftiImage object with the downsampled surface.</p>
<p>Notes:
- The input faces array should be triangulated, i.e., each face should consist of exactly three</p>
<blockquote>
<div><p>vertex indices.</p>
</div></blockquote>
<ul class="simple">
<li><p>The VTK library is used for mesh decimation, which must be installed and properly configured.</p></li>
<li><p>The returned GiftiImage object is a new object; the original <em class="xref py py-obj">gifti_surf</em> object is not
modified in place.</p></li>
</ul>
<p>Example:
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; gifti_surf = nib.load(‘path_to_gifti_file.gii’)
&gt;&gt;&gt; new_gifti_surf = downsample_single_surface(gifti_surf, 0.1)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.find_non_manifold_edges">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">find_non_manifold_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#find_non_manifold_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.find_non_manifold_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Identifies non-manifold edges in a given mesh represented by its faces.</p>
<p>A non-manifold edge is defined as an edge that is shared by more than two faces. This function
processes an array of faces, each face represented by a tuple of vertex indices, and identifies
edges that meet the non-manifold criteria.</p>
<p>Parameters:
faces (np.ndarray): An array where each row represents a face as a tuple of three vertex</p>
<blockquote>
<div><p>indices.</p>
</div></blockquote>
<p>Returns:
dict: A dictionary where keys are tuples representing non-manifold edges (vertices indices are</p>
<blockquote>
<div><p>sorted), and values are lists of face indices that share the edge.</p>
</div></blockquote>
<p>The function uses a defaultdict to collect face indices for each edge encountered in the mesh.
It then filters out edges that are associated with more than two faces, identifying them as
non-manifold.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.fix_non_manifold_edges">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">fix_non_manifold_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#fix_non_manifold_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.fix_non_manifold_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes faces associated with non-manifold edges from a mesh defined by vertices and faces.</p>
<p>Non-manifold edges are edges that are shared by more than two faces, which can cause issues
in various mesh processing tasks such as mesh simplification, smoothing, or 3D printing. This
function identifies such edges and removes all faces associated with them to ensure
manifoldness of the mesh.</p>
<p>Parameters:
vertices (np.ndarray): An array of vertices, where each row represents a vertex as [x, y, z]</p>
<blockquote>
<div><p>coordinates.</p>
</div></blockquote>
<dl class="simple">
<dt>faces (np.ndarray): An array of faces, where each row represents a face as indices into the</dt><dd><p>vertices array.</p>
</dd>
</dl>
<p>Returns:
tuple: A tuple containing two elements:</p>
<blockquote>
<div><ul class="simple">
<li><p>np.ndarray: The unchanged array of vertices.</p></li>
<li><dl class="simple">
<dt>np.ndarray: The modified array of faces, with faces associated with non-manifold edges</dt><dd><p>removed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Examples:
&gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])
&gt;&gt;&gt; faces = np.array([[0, 1, 2], [0, 2, 3], [1, 2, 3]])
&gt;&gt;&gt; new_vertices, new_faces = fix_non_manifold_edges(vertices, faces)
&gt;&gt;&gt; new_faces
array([[0, 1, 2], [0, 2, 3]])  # Assuming face [1, 2, 3] was associated with a non-manifold</p>
<blockquote>
<div><p># edge</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.interpolate_data">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">interpolate_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsampled_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsampled_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#interpolate_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.interpolate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates vertex data from a downsampled mesh back to the original mesh using nearest
neighbor matching and optional smoothing based on an adjacency matrix. Both meshes are
expected to be nibabel Gifti objects.</p>
<p>Parameters:
original_mesh (GiftiImage): The original high-resolution mesh as a nibabel Gifti object from</p>
<blockquote>
<div><p>which ‘downsampled_mesh’ is derived.</p>
</div></blockquote>
<dl class="simple">
<dt>downsampled_mesh (GiftiImage): The downsampled version of the original mesh as a nibabel Gifti</dt><dd><p>object.</p>
</dd>
</dl>
<p>downsampled_data (array): Data associated with the vertices of ‘downsampled_mesh’.
adjacency_matrix (sparse matrix, optional): A vertex-by-vertex adjacency matrix of the original</p>
<blockquote>
<div><p>mesh. If None, it will be computed from the
‘original_mesh’.</p>
</div></blockquote>
<dl class="simple">
<dt>max_iterations (int, optional): The maximum number of iterations to perform for smoothing the</dt><dd><p>interpolated data.</p>
</dd>
</dl>
<p>Returns:
np.ndarray: An array of interpolated data for each vertex in the ‘original_mesh’. The data is</p>
<blockquote>
<div><p>initially interpolated using nearest neighbors and can be further refined through
iterative smoothing.</p>
</div></blockquote>
<p>The function first finds the nearest vertex in the ‘downsampled_mesh’ for each vertex in the
‘original_mesh’ using a KD-tree. It directly assigns corresponding data values where a close
match is found. The function iteratively adjusts data values at vertices without direct matches
by averaging over neighbors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.iterative_downsample_single_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">iterative_downsample_single_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#iterative_downsample_single_surface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.iterative_downsample_single_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratively downsample a single surface mesh to a target number of vertices.</p>
<p>This function reduces the number of vertices in a surface mesh (in GIFTI format) to a specified
fraction of its original size. Downsampling is performed iteratively until the target number of
vertices is reached or closely approximated.</p>
<p>Parameters:
gifti_surf (nibabel.gifti.GiftiImage): The surface mesh to be downsampled, provided as a GIFTI</p>
<blockquote>
<div><p>image object.</p>
</div></blockquote>
<dl class="simple">
<dt>ds_factor (float, optional): The downsampling factor representing the target fraction of the</dt><dd><p>original number of vertices. Default is 0.1.</p>
</dd>
</dl>
<p>Returns:
nibabel.gifti.GiftiImage: The downsampled surface mesh as a GIFTI image object.</p>
<p>Notes:
- The downsampling process is iterative. In each iteration, the mesh is downsampled by a factor</p>
<blockquote>
<div><p>calculated to approach the target number of vertices.</p>
</div></blockquote>
<ul class="simple">
<li><p>If the calculated downsampling factor in an iteration equals or exceeds 1, the process is
terminated to prevent upsampling or infinite loops.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.mesh_adjacency">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">mesh_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#mesh_adjacency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.mesh_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the adjacency matrix of a triangle mesh.</p>
<p>Parameters:
faces - a numpy array of shape [f, 3] representing the mesh faces</p>
<p>Returns:
adjacency - adjacency matrix as a sparse [v, v] array, where v is the number of vertices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.mesh_normals">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">mesh_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#mesh_normals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.mesh_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the normals of a mesh.</p>
<p>Parameters:
vertices (ndarray): Array of vertices of the mesh. Each row represents a vertex.
faces (ndarray): Array of faces of the mesh. Each row represents a face with indices to the</p>
<blockquote>
<div><p>vertices array.</p>
</div></blockquote>
<p>unit (bool, optional): If True, the normals are normalized to unit length. Default is False.</p>
<p>Returns:
tuple: A tuple containing two ndarrays:</p>
<blockquote>
<div><ul class="simple">
<li><p>vertex_normal: Normal vectors for each vertex.</p></li>
<li><p>face_normal: Normal vectors for each face.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.postprocess_freesurfer_surfaces">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">postprocess_freesurfer_surfaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_surfaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'link_vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#postprocess_freesurfer_surfaces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.postprocess_freesurfer_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Process and combine FreeSurfer surface meshes for a subject.</p>
<p>This function processes FreeSurfer surface meshes for a given subject by creating intermediate
surfaces, adjusting for RAS offset, removing deep vertices, combining hemispheres,
downsampling, and computing link vectors. The resulting surfaces are combined and saved to a
specified output file.</p>
<p>Parameters:
subj_id (str): Subject ID corresponding to the FreeSurfer subject directory.
out_dir (str): Output directory where the processed files will be saved.
out_fname (str): Filename for the final combined surface mesh.
n_surfaces (int, optional): Number of intermediate surfaces to create between white and pial</p>
<blockquote>
<div><p>surfaces.</p>
</div></blockquote>
<p>ds_factor (float, optional): Downsampling factor for surface decimation.
orientation (str, optional): Method to compute orientation vectors (‘link_vector’ for</p>
<blockquote>
<div><p>pial-white link, ‘ds_surf_norm’ for downsampled surface normals,
‘orig_surf_norm’ for original surface normals, and ‘cps’ for
cortical patch statistics).</p>
</div></blockquote>
<dl class="simple">
<dt>fix_orientation (bool, optional): Flag to ensure that orientation of corresponding vertices</dt><dd><p>across layers is the same (True by default)</p>
</dd>
<dt>remove_deep (bool, optional): Flag to remove vertices located in deep regions (labeled as</dt><dd><p>‘unknown’).</p>
</dd>
<dt>n_jobs (int, optional): Number of parallel processes to run. -1 for all available cores (-1 by</dt><dd><p>default)</p>
</dd>
</dl>
<p>Notes:
- This function assumes the FreeSurfer ‘SUBJECTS_DIR’ environment variable is set.
- Surfaces are processed in Gifti format and combined into a single surface mesh.</p>
<p>Example:
&gt;&gt;&gt; postprocess_freesurfer_surfaces(‘subject1’, ‘/path/to/output’, ‘combined_surface.gii’)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.remove_unconnected_vertices">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">remove_unconnected_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#remove_unconnected_vertices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.remove_unconnected_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes vertices that are not connected to any faces from a Gifti surface object.</p>
<p>Parameters:
gifti_surf (nibabel.gifti.GiftiImage): The Gifti surface object to be processed.</p>
<p>Returns:
nibabel.gifti.GiftiImage: A new GiftiImage object with unconnected vertices removed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.remove_vertices">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">remove_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gifti_surf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices_to_remove</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#remove_vertices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.remove_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove specified vertices from a Gifti surface and update the faces accordingly.</p>
<p>This function modifies a Gifti surface by removing the specified vertices. It also updates
the faces of the surface so that they only reference the remaining vertices. If normals
are present in the surface, they are also updated to correspond to the new set of vertices.</p>
<p>Parameters:
gifti_surf (nibabel.gifti.GiftiImage): The Gifti surface object from which vertices will be</p>
<blockquote>
<div><p>removed.</p>
</div></blockquote>
<p>vertices_to_remove (array_like): An array of vertex indices to be removed from the surface.</p>
<p>Returns:
nibabel.gifti.GiftiImage: A new GiftiImage object with the specified vertices removed and faces</p>
<blockquote>
<div><p>updated.</p>
</div></blockquote>
<p>Notes:
- The function assumes that the GiftiImage object contains at least two data arrays: one for</p>
<blockquote>
<div><p>vertices and one for faces. If normals are present, they are also updated.</p>
</div></blockquote>
<ul class="simple">
<li><p>Vertex indices in <em class="xref py py-obj">vertices_to_remove</em> should be zero-based (following Python’s indexing
convention).</p></li>
<li><p>The returned GiftiImage object is a new object; the original <em class="xref py py-obj">gifti_surf</em> object is not
modified in place.</p></li>
</ul>
<p>Example:
&gt;&gt;&gt; import nibabel as nib
&gt;&gt;&gt; gifti_surf = nib.load(‘path_to_gifti_file.gii’)
&gt;&gt;&gt; vertices_to_remove = np.array([0, 2, 5])  # Indices of vertices to remove
&gt;&gt;&gt; new_gifti_surf = remove_vertices(gifti_surf, vertices_to_remove)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.surf.split_fv">
<span class="sig-prename descclassname"><span class="pre">lameg.surf.</span></span><span class="sig-name descname"><span class="pre">split_fv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/surf.html#split_fv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.surf.split_fv" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits faces and vertices into connected pieces based on the connectivity of the faces.</p>
<p>Parameters:
faces (np.array): A 2D numpy array of faces, where each row represents a face and each element</p>
<blockquote>
<div><p>is an index to a vertex in vertices.</p>
</div></blockquote>
<p>vertices (np.array): A 2D numpy array of vertices, where each row represents a vertex.</p>
<p>Returns:
list of dicts: A list where each element is a dictionary with keys ‘faces’ and ‘vertices’. Each</p>
<blockquote>
<div><p>dictionary represents a separately connected patch of the mesh.</p>
</div></blockquote>
<p>Examples:
&gt;&gt;&gt; faces = np.array([[1, 2, 3], [1, 3, 4], [5, 6, 1], [7, 8, 9], [11, 10, 4]])
&gt;&gt;&gt; vertices = np.array([[2, 4], [2, 8], [8, 4], [8, 0], [0, 4], [2, 6], [2, 2], [4, 2],</p>
<blockquote>
<div><p>[4, 0], [5, 2], [5, 0]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">split_patches</span> <span class="o">=</span> <span class="n">split_fv</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note: Faces and vertices should be defined such that faces sharing a vertex reference the same</dt><dd><p>vertex number. This function does not explicitly test for duplicate vertices at the same
location.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-lameg.util">
<span id="lameg-util-module"></span><h2>lameg.util module<a class="headerlink" href="#module-lameg.util" title="Permalink to this heading">¶</a></h2>
<p>This module provides tools for interfacing with SPM (Statistical Parametric Mapping) software,
managing MEG sensor data, and working with neuroimaging data in various formats such as NIfTI,
GIFTI, and MATLAB files. It includes functions for batch processing in SPM, converting data
formats, loading and processing sensor data, and working with anatomical structures through
cortical mesh analysis.</p>
<p>Key functionalities include:
- Context management for SPM operations.
- Batch processing for neuroimaging tasks.
- Loading MEG sensor data and managing related file operations.
- Utility functions for anatomical and spatial data transformations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.batch">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#batch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a batch processing job in SPM (Statistical Parametric Mapping) using MATLAB.</p>
<p>This function prepares a configuration for an SPM batch job, saves it to a temporary MATLAB
file, and executes it within an SPM instance. The function is capable of running any batch
configuration passed to it as long as it adheres to SPM’s batch configuration structure.
After processing, it cleans up by deleting the temporary file used for the job.</p>
<p>Parameters:
cfg (dict): A dictionary containing the configuration settings for the SPM job. The dictionary</p>
<blockquote>
<div><p>should follow the structure required by SPM’s matlabbatch system.</p>
</div></blockquote>
<dl class="simple">
<dt>viz (bool, optional): If True, the SPM GUI will display progress and results, allowing user</dt><dd><p>interaction. If False, the process runs entirely in the background.
Defaults to True.</p>
</dd>
<dt>spm_instance (optional): An instance of an SPM session. If None, a new SPM session is created</dt><dd><p>and used for the job. Defaults to None.</p>
</dd>
</dl>
<p>Returns:
None: This function does not return any value but executes the MATLAB SPM commands specified</p>
<blockquote>
<div><p>in the configuration.</p>
</div></blockquote>
<p>Examples:
To run an SPM job with a given configuration, you might call the function as follows:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>python
cfg = {</p>
<blockquote>
<div><p>‘spm.stats.fmri_spec.dir’: [‘/path/to/output’],
‘spm.stats.fmri_spec.timing.units’: ‘secs’,
‘spm.stats.fmri_spec.sess’: {</p>
<blockquote>
<div><p>‘scans’: [‘scan1.nii’, ‘scan2.nii’],
‘cond’: {</p>
<blockquote>
<div><p>‘name’: ‘ExampleCondition’,
‘onset’: [10, 30],
‘duration’: [1, 1],</p>
</div></blockquote>
<p>},
‘multi’: {‘regress’: {‘name’: ‘movement’, ‘val’: [1, 0, 1, 0]}}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
batch(cfg, viz=False)
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Notes:
- The temporary MATLAB file is created in the system’s default temp directory.
- This function assumes that an SPM and MATLAB environment is properly set up and accessible</p>
<blockquote>
<div><p>through the provided <em class="xref py py-obj">spm_instance</em> or through a default SPM environment.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.big_brain_proportional_layer_boundaries">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">big_brain_proportional_layer_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#big_brain_proportional_layer_boundaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.big_brain_proportional_layer_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the proportional layer boundaries (6 values between 0 and 1) from
fsaverage converted Big Brain atlas, included in the laMEG.</p>
<p>Function uses the included fsaverage converted Big Brain cortical thickness atlas to calculate
normalised distances between cortical layer (from layer 1 to layer 6) boundaries (values
between 0 and 1). To speed up the computation, the results are stored in the numpy dictionary.</p>
<p>Parameters:
overwrite (bool): overwrite the existing file</p>
<p>Returns:
bb_data (dict): dictionary (keys: “lh”, “rh”) with arrays containing layer boundaries for each</p>
<blockquote>
<div><p>vertex in the hemisphere</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.calc_prop">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">calc_prop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#calc_prop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.calc_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>from independent thickness to overall proportion, while respecting the zeros</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.check_many">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">check_many</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multiple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#check_many"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.check_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks for a presence of strings in a target strings.</p>
<p>Parameters:
multiple (list): strings to be found in target string
target (str): target string
func (str): “all” or “any”, use the fuction to search for any or all strings in the filename.</p>
<p>Notes:
- this function works really well with if statement for list comprehension</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.convert_fsaverage_to_native">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">convert_fsaverage_to_native</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#convert_fsaverage_to_native"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.convert_fsaverage_to_native" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a vertex index from fsaverage to a subject’s native surface space.</p>
<p>This function takes a vertex index from the fsaverage template surface and finds the
corresponding vertex index in a subject’s native surface space. It loads the fsaverage
spherical surface, identifies the coordinates of the given vertex index, and then finds the
nearest corresponding vertex on the subject’s registered spherical surface. If the hemisphere
is right, it adjusts the index by adding the number of vertices in the left hemisphere pial
surface so that it matches the combined hemishere mesh. It returns the adjusted vertex index in
the subject’s native space.</p>
<p>Parameters:
subj_id (str): The subject identifier for which the conversion is being performed.
hemi (str): Hemisphere specifier (‘lh’ for left hemisphere, ‘rh’ for right hemisphere).
vert_idx (int): Index of the vertex in the fsaverage surface to be converted.</p>
<p>Returns:
int: Index of the vertex on the subject’s native surface that corresponds to the input vertex</p>
<blockquote>
<div><p>index.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.convert_native_to_fsaverage">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">convert_native_to_fsaverage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_surf_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_coord</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#convert_native_to_fsaverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.convert_native_to_fsaverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert coordinates from a subject’s native surface space to the fsaverage surface space.</p>
<p>This function maps a vertex coordinate from a subject’s native combined pial surface to the
corresponding vertex index in the fsaverage template space. It does this by determining which
hemisphere the vertex belongs to based on the closest match in the left and right hemispheres’
pial surfaces. It then finds the nearest vertex in the subject’s registered spherical surface,
maps this to the nearest vertex in the fsaverage spherical surface, and returns the index of
this fsaverage vertex.</p>
<p>Parameters:
subj_id (str): The subject identifier for which the conversion is being performed.
subj_surf_dir (str): The path containing the laMEG-processed subject surfaces
subj_coord (array-like): The x, y, z coordinates on the subject’s combined hemisphere pial</p>
<blockquote>
<div><p>surface to be converted.</p>
</div></blockquote>
<p>Returns:
str: The hemisphere the vertex is found in (‘lh’ for left hemisphere, ‘rh’ for right</p>
<blockquote>
<div><p>hemisphere).</p>
</div></blockquote>
<dl class="simple">
<dt>int: Index of the vertex on the fsaverage spherical surface that corresponds to the input</dt><dd><p>coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.ctf_fif_spm_conversion">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">ctf_fif_spm_conversion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mne_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res4_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoched</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spm_'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spm_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#ctf_fif_spm_conversion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.ctf_fif_spm_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <a href="#id9"><span class="problematic" id="id10">*</span></a>.fif file to SPM data format.</p>
<p>Parameters:
mne_file (str or pathlib.Path or os.Path): path to the “<em>-raw.fif” or “</em>-epo.fif” file
res4_file (str or pathlib.Path or os.Path): location of the sensor position data. <a href="#id11"><span class="problematic" id="id12">*</span></a>.res4 for</p>
<blockquote>
<div><p>CTF</p>
</div></blockquote>
<p>output_path (str or pathlib.Path or os.Path): location of the converted file
epoched (bool): Specify if the data is epoched (True) or not (False)
prefix (str): a string appended to the output_name after conversion. Default: “<a href="#id15"><span class="problematic" id="id16">spm_</span></a>”
spm_instance (spm_standalone, optional): Instance of standalone SPM. Default is None.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <em class="xref py py-obj">spm_instance</em> is not provided, the function will start a new standalone SPM instance.</p></li>
<li><p>The function will automatically close the standalone SPM instance if it was started
within the function.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_bigbrain_layer_boundaries">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_bigbrain_layer_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_surf_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subj_coord</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#get_bigbrain_layer_boundaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.get_bigbrain_layer_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cortical layer boundaries based on Big Brain atlas for a specified coordinate in the
subject’s downsampled combined space.</p>
<p>Function maps a vertex coordinate from a subject’s native combined pial surface to the
corresponding vertex index in the fsaverage template space, in a specific hemisphere. Then,
the proportional layer boundaries (6 values between 0 and 1) from fsaverage converted Big
Brain atlas are returned (from layer 1 to layer 6). To get the subjects prpportional values,
those values have to be multiplied by the observed cortical thickness.</p>
<p>Parameters:
subj_id (str): The subject identifier for which the conversion is being performed.
subj_surf_dir (str): The path containing the laMEG-processed subject surfaces
subj_coord (array-like): The x, y, z coordinates on the subject’s combined hemisphere pial</p>
<blockquote>
<div><p>surface to be converted.</p>
</div></blockquote>
<p>Returns:
vert_bb_prop (array-like): proportional layer boundaries (6 values between 0 and 1) from</p>
<blockquote>
<div><p>fsaverage converted Big Brain atlas</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_directories">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_directories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#get_directories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.get_directories" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of directories in the path (or all subdirectories) containing
specified strings.</p>
<p>Parameters:
target path (str or pathlib.Path or os.Path): the most shallow searched directory
depth (str): “all” or “one”, depth of search (recurrent or shallow)</p>
<p>Notes:
- returns a list of pathlib.Path objects</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_fiducial_coords">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_fiducial_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subj_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#get_fiducial_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.get_fiducial_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches fiducial coordinates from a tab-separated values (TSV) file for a given subject ID.</p>
<p>Parameters:
subj_id (str): The subject ID to look for in the file.
fname (str): Path to the TSV file.</p>
<p>Returns:
tuple: A tuple containing the NAS, LPA, and RPA coordinates as lists of floats.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_files">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#get_files"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.get_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the files with specific extension, prefix and name containing
specific strings. Either all files in the directory or in this directory.</p>
<p>Parameters:
target path (str or pathlib.Path or os.Path): the most shallow searched directory
suffix (str): file extension in “<a href="#id13"><span class="problematic" id="id14">*</span></a>.ext” format
strings (list of str): list of strings searched in the file name
prefix (str): limit the output list to the file manes starting with prefix
check (str): “all” or “any”, use the fuction to search for any or all strings in the filename.
depth (str): “all” or “one”, depth of search (recurrent or shallow)</p>
<p>Notes:
- returns a list of pathlib.Path objects</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.get_surface_names">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">get_surface_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation_method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#get_surface_names"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.get_surface_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a list of filenames for each mesh layer in a multi-layer mesh setup.</p>
<p>Parameters:
- n_layers (int): The number of layers in the mesh.
- surf_path (str): The file path where the mesh files are located.
- orientation_method (str): The method used for orientation in the naming of mesh files.</p>
<p>Returns:
- list: A list of strings, where each string is the full file path to a mesh layer file. The</p>
<blockquote>
<div><p>list order corresponds to the layers’ order, starting from the outermost layer (pial
surface) to the innermost layer (white matter surface).</p>
</div></blockquote>
<p>This function assumes a specific naming convention for the mesh files. The outermost layer is
named as ‘pial’, the innermost as ‘white’, and the intermediate layers are named based on their
relative position between 1 (pial) and 0 (white), with the position formatted to three decimal
places.
Each filename also includes an orientation method specifier.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.load_meg_sensor_data">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">load_meg_sensor_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#load_meg_sensor_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.load_meg_sensor_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load sensor data from a MEG dataset.</p>
<p>Parameters:
data_fname (str): Filename or path of the MEG/EEG data file.</p>
<p>Returns:
ndarray: An array containing the MEG sensor data (channels x time x trial).
ndarray: An array containing the MEG data timestamps
list: A list of channel names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.make_directory">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">make_directory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extended_dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#make_directory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.make_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a directory along with the intermediate directories.</p>
<p>root_path (str or pathlib.Path or os.Path): the root directory
extended_dir(str or list): directory or directories to create within root_path</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.spm_context">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">spm_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#spm_context"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.spm_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for handling standalone SPM instances.</p>
<p>Parameters:
spm (spm_standalone, optional): An existing standalone instance. Default is None.</p>
<p>Yields:
spm_standalone: A standalone SPM instance for use within the context.</p>
<p>Notes:
- If ‘spm’ is None, the function starts a new standalone SPM instance.
- The new standalone SPM instance will be closed automatically upon exiting the context.
- If ‘spm’ is provided, it will be used as is and not closed automatically.
- This function is intended for use in a ‘with’ statement to ensure proper management of</p>
<blockquote>
<div><p>standalone SPM resources.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.util.ttest_rel_corrected">
<span class="sig-prename descclassname"><span class="pre">lameg.util.</span></span><span class="sig-name descname"><span class="pre">ttest_rel_corrected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/util.html#ttest_rel_corrected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.util.ttest_rel_corrected" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a corrected paired t-test on a sample of data.</p>
<p>This function handles missing data (NaNs) and applies a variance correction to the t-test
calculation.
It computes the t-statistic and corresponding p-value for the hypothesis test.</p>
<p>Parameters:
data (array_like): A 2-D array containing the sample data. NaN values are allowed and are</p>
<blockquote>
<div><p>handled appropriately.</p>
</div></blockquote>
<dl class="simple">
<dt>correction (float, optional): The correction value to be added to the variance to avoid</dt><dd><p>division by zero issues. If set to 0 (default), an automatic
correction of 0.01 * max(variance) is applied.</p>
</dd>
<dt>tail (int, optional): Specifies the type of t-test to be performed.</dt><dd><p>0 for a two-tailed test (default), 1 for a right one-tailed test, -1 for
a left one-tailed test.</p>
</dd>
</dl>
<p>axis (int, optional): Axis along which to perform the t-test. Default is 0.</p>
<p>Returns:
tuple: A tuple containing the t-statistic (float), degrees of freedom (int), and the p-value</p>
<blockquote>
<div><p>(float) for the test.</p>
</div></blockquote>
<p>Notes:
- The function handles NaNs by computing the sample size, mean, and variance ignoring NaNs.
- The degrees of freedom (deg_of_freedom) for the t-test is computed as</p>
<blockquote>
<div><p>maximum(sample size - 1, 0).</p>
</div></blockquote>
<ul class="simple">
<li><p>The standard error of the mean (ser) is adjusted with the variance correction.</p></li>
<li><p>The p-value is computed based on the specified tail type of the t-test.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-lameg.viz">
<span id="lameg-viz-module"></span><h2>lameg.viz module<a class="headerlink" href="#module-lameg.viz" title="Permalink to this heading">¶</a></h2>
<p>This module provides tools for converting and visualizing numerical data into color-coded formats.
It includes functions for mapping data to RGB and hexadecimal color values, performing color
normalization, and rendering 3D surface visualizations using K3D. Additional utilities are included
for plotting Current Source Density (CSD) data and handling color transformations.</p>
<p>Functions:
- data_to_rgb: Converts numerical data into RGB or RGBA color arrays based on a specified colormap</p>
<blockquote>
<div><p>and normalization.</p>
</div></blockquote>
<ul class="simple">
<li><p>rgbtoint: Converts RGB color lists to a single 32-bit integer color representation.</p></li>
<li><p>color_map: Maps numerical data to hexadecimal color values suitable for use in visualizations.</p></li>
<li><p>show_surface: Renders 3D surfaces with optional vertex coloring and interactive features using
K3D.</p></li>
<li><p>plot_csd: Plots Current Source Density (CSD) data as a 2D image over a specified time range.</p></li>
</ul>
<p>Utilities:
- The module supports various color normalizations including linear, logarithmic, and diverging</p>
<blockquote>
<div><p>scales.</p>
</div></blockquote>
<ul class="simple">
<li><p>Includes handling of edge cases and data-specific adjustments to enhance the quality of visual
outputs.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.color_map">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">color_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TS'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/viz.html#color_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.viz.color_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a data mapped to the color map in the hexadecimal format,
and a colormap to use for e.g. a colorbar.</p>
<p>Parameters:
data (iterable): 1d numerical data
n_bins (int): amount of bins in the histogram
vmin (float): lowest value on the histogram range
vmax (float): highest value on the histogram range
vcenter (float): centre of the histogram range (default=0 for zero-centred color mapping)
norm (str): type of normalisation (“TS”, “N”, “LOG”)</p>
<p>Notes:
- function creates a normalisation based on the “norm” argument
- creates a suitable colormap
- maps data values based on the histogram bins
- returns RGB values for each data point
- converts percent based RGB to decimal
- converts RGB to hexadecimal in a fromat appropriate for the visualisation function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.data_to_rgb">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">data_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TS'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/viz.html#data_to_rgb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.viz.data_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns RGB values of a data mapped to the normalised matplotlib colormap.
(optionally) Returns a colormap to use for e.g. a colorbar.</p>
<p>Parameters:
data (iterable): 1d numerical data
n_bins (int): amount of bins in the histogram
vmin (float): lowest value on the histogram range
vmax (float): highest value on the histogram range
vcenter (float): centre of the histogram range (default=0 for zero-centred color mapping)
ret_map (bool): return a colormap object
norm (str): type of normalisation (“TS”, “N”, “LOG”)</p>
<p>Notes:
- function creates a normalisation based on the “norm” argument
- creates a suitable colormap
- maps data values based on the histogram bins
- returns RGB values for each data point</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.plot_csd">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">plot_csd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RdBu_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin_vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/viz.html#plot_csd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.viz.plot_csd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the computed Current Source Density (CSD) data.</p>
<p>This function takes a CSD matrix and plots it over a specified time range. It offers options
for color normalization, colormap selection, and including a colorbar. Optionally, it can
return plot details.</p>
<p>Parameters:
csd (numpy.ndarray): The CSD matrix to be plotted, with dimensions corresponding to</p>
<blockquote>
<div><p>layers x time points.</p>
</div></blockquote>
<dl class="simple">
<dt>times (numpy.ndarray): A 1D array of time points corresponding to the columns of the CSD</dt><dd><p>matrix.</p>
</dd>
</dl>
<p>ax (matplotlib.axes.Axes): The matplotlib axes object where the CSD data will be plotted.
colorbar (bool, optional): Flag to indicate whether a colorbar should be added to the plot.</p>
<blockquote>
<div><p>Default is True.</p>
</div></blockquote>
<p>cmap (str, optional): The colormap used for plotting the CSD data. Default is “RdBu_r”.
vmin_vmax (tuple or str, optional): A tuple specifying the (vmin, vmax) range for color</p>
<blockquote>
<div><p>normalization. If “norm”, a standard normalization is used.
If None, the range is set to the maximum absolute value in
the CSD matrix. Default is None.</p>
</div></blockquote>
<p>n_layers (int): Number of layers in the CSD</p>
<p>Returns:
csd_imshow: The imshow object of the plot.</p>
<p>Notes:
- This function requires ‘numpy’, ‘matplotlib.colors’, and ‘matplotlib.pyplot’ libraries.
- The ‘TwoSlopeNorm’ from ‘matplotlib.colors’ is used for diverging color normalization.
- The aspect ratio of the plot is automatically set to ‘auto’ for appropriate time-layer</p>
<blockquote>
<div><p>representation.</p>
</div></blockquote>
<ul class="simple">
<li><p>Layer labels are set from 1 to 11, assuming a total of 11 layers.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.rgbtoint">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">rgbtoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/viz.html#rgbtoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.viz.rgbtoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 32bit representation of the color as an integer.</p>
<p>Parameters:
rgb (array): accepts integer [R, G, B] array</p>
<p>Notes:
- function requires integer RGB (values 0-255)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lameg.viz.show_surface">
<span class="sig-prename descclassname"><span class="pre">lameg.viz.</span></span><span class="sig-name descname"><span class="pre">show_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">menu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lameg/viz.html#show_surface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lameg.viz.show_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a 3D surface with optional data overlay. The rendering is persistent and does not
require an active kernel.</p>
<p>Parameters:
- surface (nibabel.gifti.GiftiImage): The Gifti surface mesh to be rendered.
- color (array, optional): Basic color of the surface in the absence of data. Specified as a</p>
<blockquote>
<div><p>decimal RGB array. Default is [166, 166, 166].</p>
</div></blockquote>
<ul class="simple">
<li><p>grid (bool, optional): Toggles the rendering of a grid. Default is False.</p></li>
<li><dl class="simple">
<dt>menu (bool, optional): Toggles the display of a menu with options such as lighting</dt><dd><p>adjustments. Default is False.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>vertex_colors (array, optional): An array of vertex colors specified as hexadecimal 32-bit</dt><dd><p>color values. Each color corresponds to a vertex on the
surface. Default is None.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>info (bool, optional): If True, prints information about the surface, such as the number of</dt><dd><p>vertices. Default is False.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>camera_view (array, optional): Specifies a camera view for the rendering. If None, an</dt><dd><p>automatic camera view is set. Default is None.</p>
</dd>
</dl>
</li>
<li><p>height (int, optional): Height of the widget in pixels. Default is 512.</p></li>
<li><dl class="simple">
<dt>opacity (float, optional): Sets the opacity of the surface, with 1.0 being fully opaque and</dt><dd><p>0.0 being fully transparent. Default is 1.0.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:
- plot: A k3d plot object containing the rendered surface.</p>
<p>This function utilizes the k3d library for rendering the surface. It supports customization of
surface color, opacity, and additional features like grid and menu display. The <code class="xref py py-obj docutils literal notranslate"><span class="pre">colors</span></code>
parameter allows for vertex-level color customization.</p>
</dd></dl>

</section>
<section id="module-lameg">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lameg" title="Permalink to this heading">¶</a></h2>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2024, DANC lab.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>