
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_tutorials/tutorial_06_csd.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_tutorials_tutorial_06_csd.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_tutorials_tutorial_06_csd.py:


Laminar CSD analysis
====================
This tutorial demonstrates how to perform laminar inference using a CSD analysis of event-related source signals. A temporal Gaussian function is simulated at a particular cortical location in various layers. Source reconstruction is performed on the whole time window using the Empirical Bayesian Beamformer on the simulated sensor data using a forward model based on the multilayer mesh, thus providing an estimate of source activity on each layer. A laminar CSD is run on the laminar signals at the location with the peak variance.

.. GENERATED FROM PYTHON SOURCE LINES 7-11

Setting up the simulations
--------------------------

Simulations are based on an existing dataset, which is used to define the sampling rate, number of trials, duration of each trial, and the channel layout.

.. GENERATED FROM PYTHON SOURCE LINES 11-45

.. code-block:: default


    import os
    import shutil
    import numpy as np
    import k3d
    import matplotlib.pyplot as plt
    import tempfile

    from lameg.invert import invert_ebb, coregister, load_source_time_series
    from lameg.laminar import compute_csd
    from lameg.simulate import run_dipole_simulation
    from lameg.surf import LayerSurfaceSet
    from lameg.util import get_fiducial_coords
    from lameg.viz import show_surface, color_map, plot_csd, rgbtoint
    import spm_standalone

    # Subject information for data to base the simulations on
    subj_id = 'sub-104'
    ses_id = 'ses-01'

    # Fiducial coil coordinates
    fid_coords = get_fiducial_coords(subj_id, '../test_data/participants.tsv')

    # Data file to base simulations on
    data_file = os.path.join(
        '../test_data',
        subj_id,
        'meg',
        ses_id,
        f'spm/pspm-converted_autoreject-{subj_id}-{ses_id}-001-btn_trial-epo.mat'
    )

    spm = spm_standalone.initialize()


.. GENERATED FROM PYTHON SOURCE LINES 46-47

The simulations and source reconstructions will be based on a forward model using the multilayer mesh

.. GENERATED FROM PYTHON SOURCE LINES 47-52

.. code-block:: default


    surf_set = LayerSurfaceSet(subj_id, 15)

    verts_per_surf = surf_set.get_vertices_per_layer()


.. GENERATED FROM PYTHON SOURCE LINES 53-54

We're going to copy the data file to a temporary directory and direct all output there.

.. GENERATED FROM PYTHON SOURCE LINES 54-75

.. code-block:: default


    # Extract base name and path of data file
    data_path, data_file_name = os.path.split(data_file)
    data_base = os.path.splitext(data_file_name)[0]

    # Where to put simulated data
    tmp_dir = tempfile.mkdtemp()

    # Copy data files to tmp directory
    shutil.copy(
        os.path.join(data_path, f'{data_base}.mat'), 
        os.path.join(tmp_dir, f'{data_base}.mat')
    )
    shutil.copy(
        os.path.join(data_path, f'{data_base}.dat'), 
        os.path.join(tmp_dir, f'{data_base}.dat')
    )

    # Construct base file name for simulations
    base_fname = os.path.join(tmp_dir, f'{data_base}.mat')


.. GENERATED FROM PYTHON SOURCE LINES 76-77

Invert the subject's data using the multilayer mesh. This step only has to be done once - this is just to compute the forward model that will be used in the simulations

.. GENERATED FROM PYTHON SOURCE LINES 77-100

.. code-block:: default


    # Patch size to use for inversion (in this case it matches the simulated patch size)
    patch_size = 5
    # Number of temporal modes to use for EBB inversion
    n_temp_modes = 4

    # Coregister data to multilayer mesh
    coregister(
        fid_coords,
        base_fname,
        surf_set,
        spm_instance=spm
    )

    # Run inversion
    [_,_] = invert_ebb(
        base_fname,
        surf_set,
        patch_size=patch_size, 
        n_temp_modes=n_temp_modes,
        spm_instance=spm
    )


.. GENERATED FROM PYTHON SOURCE LINES 101-104

Simulating a signal on a superficial surface
--------------------------------------------
We're going to simulate 200ms of a Gaussian with a dipole moment of 5nAm and a width of 25ms

.. GENERATED FROM PYTHON SOURCE LINES 104-120

.. code-block:: default


    # Strength of simulated activity (nAm)
    dipole_moment = 5
    # Temporal width of the simulated Gaussian
    signal_width=.025 # 25ms
    # Sampling rate (must match the data file)
    s_rate = 600

    # Generate 200ms of a Gaussian at a sampling rate of 600Hz (to match the data file)
    time=np.linspace(0,.2,121)
    zero_time=time[int((len(time)-1)/2+1)]
    sim_signal=np.exp(-((time-zero_time)**2)/(2*signal_width**2)).reshape(1,-1)
    plt.plot(time,dipole_moment*sim_signal[0,:])
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude (nAm)')


.. GENERATED FROM PYTHON SOURCE LINES 121-124

.. image:: ../_static/tutorial_06_sim_signal.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 126-127

We need to pick a location (mesh vertex) to simulate at

.. GENERATED FROM PYTHON SOURCE LINES 127-143

.. code-block:: default


    # Vertex to simulate activity at
    sim_vertex=24581

    inflated_ds_mesh = surf_set.load('inflated', stage='ds')
    coord = inflated_ds_mesh.darrays[0].data[sim_vertex,:]
    cam_view = [335, 9.5, 51,
                60, 37, 17,
                0, 0, 1]
    plot = show_surface(
        surf_set,
        marker_coords=coord,
        marker_size=5,
        camera_view=cam_view
    )


.. GENERATED FROM PYTHON SOURCE LINES 144-147

.. image:: ../_static/tutorial_06_sim_location.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 149-150

We'll simulate a 5mm patch of activity with -5 dB SNR at the sensor level. The desired level of SNR is achieved by adding white noise to the projected sensor signals

.. GENERATED FROM PYTHON SOURCE LINES 150-175

.. code-block:: default


    # Simulate at a vertex on the pial surface
    pial_vertex = sim_vertex
    multilayer_mesh = surf_set.load(stage='ds', orientation='link_vector', fixed=True)
    sim_unit_norm = multilayer_mesh.darrays[2].data[pial_vertex,:]
    prefix = f'sim_{sim_vertex}_pial_'

    # Size of simulated patch of activity (mm)
    sim_patch_size = 5
    # SNR of simulated data (dB)
    SNR = -5

    # Generate simulated data
    pial_sim_fname = run_dipole_simulation(
        base_fname, 
        prefix, 
        pial_vertex, 
        sim_signal, 
        sim_unit_norm, 
        dipole_moment, 
        sim_patch_size, 
        SNR,
        spm_instance=spm
    ) 


.. GENERATED FROM PYTHON SOURCE LINES 176-179

Inversion
---------
Now we'll run a source reconstruction using the multilayer mesh, select the vertex to examine, extract the source signals at each layer in that location, and compute a laminar CSD

.. GENERATED FROM PYTHON SOURCE LINES 179-202

.. code-block:: default


    [_,_,MU] = invert_ebb(
        pial_sim_fname,
        surf_set,
        patch_size=patch_size,
        n_temp_modes=n_temp_modes,
        return_mu_matrix=True,
        spm_instance=spm
    )

    pial_layer_vertices = np.arange(verts_per_surf)
    pial_layer_ts, time, _ = load_source_time_series(
        pial_sim_fname,
        mu_matrix=MU,
        vertices=pial_layer_vertices
    )

    # Layer peak
    m_layer_max = np.max(np.mean(pial_layer_ts,axis=-1),-1)
    peak = np.argmax(m_layer_max)

    print(f'Simulated vertex={sim_vertex}, Prior vertex={peak}')


.. GENERATED FROM PYTHON SOURCE LINES 203-204

We can see that the peak is very close to the location we simulated at

.. GENERATED FROM PYTHON SOURCE LINES 204-239

.. code-block:: default


    # Interpolate for display on the original inflated surface
    interpolated_data = surf_set.interpolate_layer_data('pial', m_layer_max, from_stage='ds', to_stage='combined')

    inflated_ds_mesh = surf_set.load('inflated', stage='ds')
    coord = inflated_ds_mesh.darrays[0].data[peak, :]

    # Plot colors and camera view
    max_abs = np.max(np.abs(interpolated_data))
    c_range = [-max_abs, max_abs]
    cam_view = [335, 9.5, 51,
                60, 37, 17,
                0, 0, 1]

    # Plot peak
    colors, _ = color_map(
        interpolated_data,
        "RdYlBu_r",
        c_range[0],
        c_range[1]
    )
    thresh_colors = np.ones((colors.shape[0], 4)) * 255
    thresh_colors[:, :3] = colors
    thresh_colors[interpolated_data < np.percentile(interpolated_data, 99.9), 3] = 0

    plot = show_surface(
        surf_set,
        vertex_colors=thresh_colors,
        info=True,
        camera_view=cam_view,
        marker_coords=coord,
        marker_size=5,
        marker_color=[0, 0, 255]
    )


.. GENERATED FROM PYTHON SOURCE LINES 240-243

.. image:: ../_static/tutorial_06_localizer.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 246-247

We need the indices of the vertex at each layer for this location, and the distances between them

.. GENERATED FROM PYTHON SOURCE LINES 247-253

.. code-block:: default


    layer_verts = [l*int(verts_per_surf)+peak for l in range(surf_set.n_layers)]
    layer_coords = multilayer_mesh.darrays[0].data[layer_verts,:]
    layer_dists = np.sqrt(np.sum(np.diff(layer_coords,axis=0)**2,axis=1))
    print(layer_dists)


.. GENERATED FROM PYTHON SOURCE LINES 254-255

Now we can compute and plot the laminar CSD

.. GENERATED FROM PYTHON SOURCE LINES 255-285

.. code-block:: default


    # Get source time series for each layer
    layer_ts, time, _ = load_source_time_series(pial_sim_fname, vertices=layer_verts)

    # Average over trials and compute CSD and smoothed CSD
    mean_layer_ts = np.mean(layer_ts, axis=-1)
    [csd, smooth_csd] = compute_csd(mean_layer_ts, np.sum(layer_dists), s_rate, smoothing='cubic')

    col_r = plt.cm.cool(np.linspace(0, 1, num=surf_set.n_layers))
    plt.figure(figsize=(15, 4))
    plt.subplot(1, 3, 1)
    for l in range(surf_set.n_layers):
        plt.plot(time, mean_layer_ts[l, :], label=f'{l}', color=col_r[l, :])
    plt.legend(loc='upper left')
    plt.xlabel('Time (ms)')
    plt.ylabel('Source (nAm)')

    plt.subplot(1, 3, 2)
    for l in range(surf_set.n_layers):
        plt.plot(time, csd[l, :], label=f'{l}', color=col_r[l, :])
    plt.legend(loc='upper left')
    plt.xlabel('Time (ms)')
    plt.ylabel('CSD')

    ax = plt.subplot(1, 3, 3)
    plot_csd(smooth_csd, time, ax, n_layers=surf_set.n_layers)
    plt.xlabel('Time (ms)')
    plt.ylabel('Layer')
    plt.tight_layout()


.. GENERATED FROM PYTHON SOURCE LINES 286-289

.. image:: ../_static/tutorial_06_pial_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 292-295

White matter surface simulation with laminar CSD
------------------------------------------------
Let's simulate the same pattern of activity, in the same location, but on the white matter surface.

.. GENERATED FROM PYTHON SOURCE LINES 295-368

.. code-block:: default


    # Simulate at the corresponding vertex on the white matter surface
    white_vertex = (surf_set.n_layers - 1) * int(verts_per_surf) + sim_vertex
    prefix = f'sim_{sim_vertex}_white_'

    # Generate simulated data
    white_sim_fname = run_dipole_simulation(
        base_fname,
        prefix,
        white_vertex,
        sim_signal,
        sim_unit_norm,
        dipole_moment,
        sim_patch_size,
        SNR,
        spm_instance=spm
    )

    [_, _, MU] = invert_ebb(
        white_sim_fname,
        surf_set,
        patch_size=patch_size,
        n_temp_modes=n_temp_modes,
        return_mu_matrix=True,
        spm_instance=spm
    )

    pial_layer_ts, time, _ = load_source_time_series(
        white_sim_fname,
        mu_matrix=MU,
        vertices=pial_layer_vertices
    )

    # Layer peak
    m_layer_max = np.max(np.mean(pial_layer_ts, axis=-1), -1)
    peak = np.argmax(m_layer_max)

    print(f'Simulated vertex={sim_vertex}, Prior vertex={peak}')

    layer_verts = [l * int(verts_per_surf) + peak for l in range(surf_set.n_layers)]
    layer_coords = multilayer_mesh.darrays[0].data[layer_verts, :]
    layer_dists = np.sqrt(np.sum(np.diff(layer_coords, axis=0) ** 2, axis=1))
    print(layer_dists)

    # Get source time series for each layer
    layer_ts, time, _ = load_source_time_series(white_sim_fname, mu_matrix=MU, vertices=layer_verts)

    # Average over trials and compute CSD and smoothed CSD
    mean_layer_ts = np.mean(layer_ts, axis=-1)
    [csd, smooth_csd] = compute_csd(mean_layer_ts, np.sum(layer_dists), s_rate, smoothing='cubic')

    col_r = plt.cm.cool(np.linspace(0, 1, num=surf_set.n_layers))
    plt.figure(figsize=(15, 4))
    plt.subplot(1, 3, 1)
    for l in range(surf_set.n_layers):
        plt.plot(time, mean_layer_ts[l, :], label=f'{l}', color=col_r[l, :])
    plt.legend(loc='upper left')
    plt.xlabel('Time (ms)')
    plt.ylabel('Source (nAm)')

    plt.subplot(1, 3, 2)
    for l in range(surf_set.n_layers):
        plt.plot(time, csd[l, :], label=f'{l}', color=col_r[l, :])
    plt.legend(loc='upper left')
    plt.xlabel('Time (ms)')
    plt.ylabel('CSD')

    ax = plt.subplot(1, 3, 3)
    plot_csd(smooth_csd, time, ax, n_layers=surf_set.n_layers)
    plt.xlabel('Time (ms)')
    plt.ylabel('Layer')
    plt.tight_layout()


.. GENERATED FROM PYTHON SOURCE LINES 369-372

.. image:: ../_static/tutorial_06_white_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 375-378

Simulation in each layer
------------------------
Let's now simulate on each layer, and for each simulation, run the laminar CSD. We'll turn off SPM visualization here.

.. GENERATED FROM PYTHON SOURCE LINES 378-455

.. code-block:: default


    # Now simulate at the corresponding vertex on each layer, and for each simulation compute CSD
    layer_csds = []
    for l in range(surf_set.n_layers):
        print(f'Simulating in layer {l}')
        prefix = f'sim_{sim_vertex}_{l}_'
        l_vertex = l * int(verts_per_surf) + sim_vertex

        l_sim_fname = run_dipole_simulation(
            base_fname,
            prefix,
            l_vertex,
            sim_signal,
            sim_unit_norm,
            dipole_moment,
            sim_patch_size,
            SNR,
            spm_instance=spm
        )

        [_, _, MU] = invert_ebb(
            l_sim_fname,
            surf_set,
            patch_size=patch_size,
            n_temp_modes=n_temp_modes,
            viz=False,
            return_mu_matrix=True,
            spm_instance=spm
        )

        pial_layer_ts, time, _ = load_source_time_series(
            l_sim_fname,
            mu_matrix=MU,
            vertices=pial_layer_vertices
        )

        # Layer peak
        m_layer_max = np.max(np.mean(pial_layer_ts, axis=-1), -1)
        peak = np.argmax(m_layer_max)

        print(f'Simulated vertex={sim_vertex}, Prior vertex={peak}')

        layer_verts = [l * int(verts_per_surf) + peak for l in range(surf_set.n_layers)]
        layer_coords = multilayer_mesh.darrays[0].data[layer_verts, :]
        layer_dists = np.sqrt(np.sum(np.diff(layer_coords, axis=0) ** 2, axis=1))
        print(layer_dists)

        # Get source time series for each layer
        layer_ts, time, _ = load_source_time_series(l_sim_fname, mu_matrix=MU, vertices=layer_verts)

        mean_layer_ts = np.mean(layer_ts, axis=-1)
        [csd, smooth_csd] = compute_csd(mean_layer_ts, np.sum(layer_dists), 600, smoothing='cubic')

        col_r = plt.cm.cool(np.linspace(0, 1, num=surf_set.n_layers))
        plt.figure(figsize=(15, 4))
        plt.subplot(1, 3, 1)
        for l_idx in range(surf_set.n_layers):
            plt.plot(time, mean_layer_ts[l_idx, :], label=f'{l_idx}', color=col_r[l_idx, :])
        plt.legend(loc='upper left')
        plt.xlabel('Time (ms)')
        plt.ylabel('Source (nAm)')

        plt.subplot(1, 3, 2)
        for l_idx in range(surf_set.n_layers):
            plt.plot(time, csd[l_idx, :], label=f'{l_idx}', color=col_r[l_idx, :])
        plt.legend(loc='upper left')
        plt.xlabel('Time (ms)')
        plt.ylabel('CSD')

        ax = plt.subplot(1, 3, 3)
        plot_csd(smooth_csd, time, ax, n_layers=surf_set.n_layers)
        plt.xlabel('Time (ms)')
        plt.ylabel('Layer')
        plt.tight_layout()

        layer_csds.append(smooth_csd)


.. GENERATED FROM PYTHON SOURCE LINES 456-459

.. image:: ../_static/tutorial_06_pial_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 461-464

.. image:: ../_static/tutorial_06_1_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 466-469

.. image:: ../_static/tutorial_06_2_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 471-474

.. image:: ../_static/tutorial_06_3_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 476-479

.. image:: ../_static/tutorial_06_4_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 481-484

.. image:: ../_static/tutorial_06_5_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 486-489

.. image:: ../_static/tutorial_06_6_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 491-494

.. image:: ../_static/tutorial_06_7_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 496-499

.. image:: ../_static/tutorial_06_8_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 501-504

.. image:: ../_static/tutorial_06_9_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 506-509

.. image:: ../_static/tutorial_06_10_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 511-514

.. image:: ../_static/tutorial_06_11_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 516-519

.. image:: ../_static/tutorial_06_12_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 521-524

.. image:: ../_static/tutorial_06_13_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 526-529

.. image:: ../_static/tutorial_06_white_sim_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 531-532

For each simulation, we can plot a slice of the CSD through layers around a central time window. The layer model where the CSD signal crosses from negative to positive should correspond to the layer that the activity was simulated in.

.. GENERATED FROM PYTHON SOURCE LINES 532-566

.. code-block:: default


    scale_factor=500/surf_set.n_layers
    csd_patterns = []
    peaks = []
    for layer_csd in layer_csds:
        t_idx = np.where((time>=-0.05) & (time<=0.05))[0]
        csd_pattern = np.mean(layer_csd[:,t_idx],axis=1)
        peak = np.argmax(np.abs(csd_pattern))
        #cross_before = np.argmax(0-csd_pattern[:peak]))
        peaks.append(np.argmax(np.abs(csd_pattern))/scale_factor)
        csd_patterns.append(csd_pattern)

    col_r = plt.cm.cool(np.linspace(0,1, num=surf_set.n_layers))
    plt.figure(figsize=(10,4))

    # For each simulation, plot the CV error of each layer model relative to that of the worst
    # model for that simulation
    plt.subplot(1,2,1)
    for l in range(surf_set.n_layers):
        plt.plot(np.arange(len(csd_patterns[l]))/scale_factor,csd_patterns[l], label=f'{l}', color=col_r[l,:])
    plt.legend()
    plt.xlabel('Eval layer')
    plt.ylabel('CSD')

    # For each simulation, find which layer model had the lowest CV error
    plt.subplot(1,2,2)
    plt.plot(np.arange(surf_set.n_layers),peaks)
    plt.xlim([-0.5,surf_set.n_layers-.5])
    plt.ylim([-0.5,surf_set.n_layers-.5])
    plt.plot([0,surf_set.n_layers-1],[0,surf_set.n_layers-1],'k--')
    plt.xlabel('Sim layer')
    plt.ylabel('Peak CSD')
    plt.tight_layout()


.. GENERATED FROM PYTHON SOURCE LINES 567-570

.. image:: ../_static/tutorial_06_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 573-589

.. code-block:: default

    csd_patterns=np.array(csd_patterns)
    # Transpose for visualization
    im=plt.imshow(csd_patterns.T,aspect='auto', cmap='Spectral_r',extent=[0, surf_set.n_layers, surf_set.n_layers, 0])

    # Find the indices of the max value in each column
    max_indices = np.argmax(csd_patterns, axis=1)

    # Plot an 'X' at the center of the square for each column's maximum
    for idx, max_idx in enumerate(max_indices):
        plt.text(idx, max_idx/scale_factor, 'X', fontsize=12, ha='center', va='center', color='black', weight='bold')

    plt.xlabel('Simulated layer', fontsize=14)
    plt.ylabel('Evaluated layer', fontsize=14)
    cb=plt.colorbar(im)
    cb.set_label('CSD', fontsize=14)


.. GENERATED FROM PYTHON SOURCE LINES 590-593

.. image:: ../_static/tutorial_06_results_matrix.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 595-598

Beta burst CSD
--------------
That was a simulation of a source in a single layer. Let's try a beta burst simulation, with simultaneous sources in deep and superficial layers (see [Bonaiuto et al., 2021, Laminar dynamics of high amplitude beta bursts in human motor cortex](https://doi.org/10.1016/j.neuroimage.2021.118479))

.. GENERATED FROM PYTHON SOURCE LINES 598-621

.. code-block:: default


    # Strength of each simulated source (nAm)
    dipole_moment = [8, 6]
    # Temporal width of the simulated superficial signal
    superficial_width = .01 # 10ms
    # Temporal width of the simulated deep signal
    deep_width = .025 # 25ms

    # Sampling rate (must match the data file)
    s_rate = 600

    # Generate 200ms of a Gaussian at a sampling rate of 600Hz (to match the data file)
    time = np.linspace(0,.2,121)
    zero_time = time[int((len(time)-1)/2+1)]
    superficial_signal = np.exp(-((time-zero_time)**2)/(2*superficial_width**2))
    deep_signal = np.exp(-((time-zero_time)**2)/(2*deep_width**2))

    plt.plot(time,superficial_signal*dipole_moment[0], 'b', label='superficial')
    plt.plot(time,deep_signal*dipole_moment[1], 'r', label='deep')
    plt.legend()
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude (nAm)')


.. GENERATED FROM PYTHON SOURCE LINES 622-625

.. image:: ../_static/tutorial_06_burst_sim_signal.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 627-628

We need to pick a location (mesh vertex) to simulate at. The superficial signal will be simulated as a dipole at the corresponding vertex on the pial surface, and the deep signal on the white matter surface. The dipole orientations will be in opposite directions (with the superficial one pointing toward the deep one, and vice versa). This will yield a cumulative dipole moment with a beta burst-like shape

.. GENERATED FROM PYTHON SOURCE LINES 628-684

.. code-block:: default


    # Location to simulate activity at
    sim_vertex=24581
    # Corresponding pial and white matter vertices
    pial_vertex = sim_vertex
    white_vertex = (surf_set.n_layers-1)*int(verts_per_surf)+sim_vertex
    pial_coord = multilayer_mesh.darrays[0].data[pial_vertex,:]
    white_coord = multilayer_mesh.darrays[0].data[white_vertex,:]

    # Orientation of the simulated superficial dipole
    pial_ori=multilayer_mesh.darrays[2].data[pial_vertex,:]
    # Orientation of the simulated deep dipole
    white_ori=-1*multilayer_mesh.darrays[2].data[white_vertex,:]

    col_r = plt.cm.cool(np.linspace(0,1, num=surf_set.n_layers))

    pial_mesh = surf_set.load(layer_name='pial', stage='combined')
    white_mesh = surf_set.load(layer_name='white', stage='combined')

    cam_view = [85.5, -10.5, 32,
                0.5, 17, 43,
                0, 0, 1]

    plot = k3d.plot(
        grid_visible=False, menu_visibility=False, camera_auto_fit=False
    )

    pial_vertices, pial_faces, _ = pial_mesh.agg_data()
    pial_k3d_mesh = k3d.mesh(pial_vertices, pial_faces, side="double", color=rgbtoint(col_r[0,:3]*255), opacity=0.5)
    plot += pial_k3d_mesh

    white_vertices, white_faces, _ = white_mesh.agg_data()
    white_k3d_mesh = k3d.mesh(white_vertices, white_faces, side="double", color=rgbtoint(col_r[-1,:3]*255), opacity=1)
    plot += white_k3d_mesh

    pts = k3d.points(
        np.vstack([pial_coord, white_coord]),
        point_size=1,
        color=rgbtoint([0,0,0])
    )
    plot += pts

    dipole_vectors = k3d.vectors(
        np.vstack([pial_coord, white_coord]),
        vectors=np.vstack([pial_ori, white_ori])*2.3,
        head_size=5,
        line_width=0.1,
        colors=[rgbtoint([0,0,255]), rgbtoint([0,0,255]),
                rgbtoint([255,0,0]), rgbtoint([255,0,0])]
    )
    plot += dipole_vectors

    plot.camera=cam_view

    plot.display()


.. GENERATED FROM PYTHON SOURCE LINES 685-688

.. image:: ../_static/tutorial_06_burst_orientation.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 690-691

We'll simulate a 5mm patch of activity with -10 dB SNR at the sensor level. The desired level of SNR is achieved by adding white noise to the projected sensor signals

.. GENERATED FROM PYTHON SOURCE LINES 691-713

.. code-block:: default


    # Simulate a beta burst as two sources: one deep and one superficial
    prefix=f'sim_{sim_vertex}_burst_'

    # Size of simulated sources (mm)
    sim_dipfwhm=[5, 5] # mm
    # SNR of simulated data (dB)
    SNR=-10

    # Generate simulated data
    burst_sim_fname=run_dipole_simulation(
        base_fname, 
        prefix, 
        [pial_vertex, white_vertex],
        np.vstack([superficial_signal, deep_signal]),
        np.vstack([pial_ori, white_ori]),
        dipole_moment, 
        sim_dipfwhm, 
        SNR,
        spm_instance=spm
    )


.. GENERATED FROM PYTHON SOURCE LINES 714-715

Now we'll run a source reconstruction using the multilayer mesh, select the vertex to examine, extract the source signals at each layer in that location, and compute a laminar CSD

.. GENERATED FROM PYTHON SOURCE LINES 715-772

.. code-block:: default


    [_, _, MU] = invert_ebb(
        burst_sim_fname,
        surf_set,
        patch_size=patch_size,
        n_temp_modes=n_temp_modes,
        return_mu_matrix=True,
        spm_instance=spm
    )

    pial_layer_vertices = np.arange(verts_per_surf)
    pial_layer_ts, time, _ = load_source_time_series(
        burst_sim_fname,
        mu_matrix=MU,
        vertices=pial_layer_vertices
    )

    # Layer peak
    m_layer_max = np.max(np.mean(pial_layer_ts, axis=-1), -1)
    peak = np.argmax(m_layer_max)

    print(f'Simulated vertex={sim_vertex}, Prior vertex={peak}')

    layer_verts = [l * int(verts_per_surf) + peak for l in range(surf_set.n_layers)]
    layer_coords = multilayer_mesh.darrays[0].data[layer_verts, :]
    layer_dists = np.sqrt(np.sum(np.diff(layer_coords, axis=0) ** 2, axis=1))
    print(layer_dists)

    # Get source time series for each layer
    layer_ts, time, _ = load_source_time_series(burst_sim_fname, mu_matrix=MU, vertices=layer_verts)

    # Average over trials and compute CSD and smoothed CSD
    mean_layer_ts = np.mean(layer_ts, axis=-1)
    [csd, smooth_csd] = compute_csd(mean_layer_ts, np.sum(layer_dists), s_rate, smoothing='cubic')

    col_r = plt.cm.cool(np.linspace(0, 1, num=surf_set.n_layers))
    plt.figure(figsize=(15, 4))
    plt.subplot(1, 3, 1)
    for l in range(surf_set.n_layers):
        plt.plot(mean_layer_ts[l, :], label=f'{l}', color=col_r[l, :])
    plt.legend(loc='upper left')
    plt.xlabel('Time (ms)')
    plt.ylabel('Source (nAm)')

    plt.subplot(1, 3, 2)
    for l in range(surf_set.n_layers):
        plt.plot(csd[l, :], label=f'{l}', color=col_r[l, :])
    plt.legend(loc='upper left')
    plt.xlabel('Time (ms)')
    plt.ylabel('CSD')

    ax = plt.subplot(1, 3, 3)
    plot_csd(smooth_csd, time, ax)
    plt.xlabel('Time (ms)')
    plt.ylabel('Layer')
    plt.tight_layout()


.. GENERATED FROM PYTHON SOURCE LINES 773-776

.. image:: ../_static/tutorial_06_burst_results.png
   :width: 800
   :alt:

.. GENERATED FROM PYTHON SOURCE LINES 778-783

.. code-block:: default

    spm.terminate()

    # Delete simulation files
    shutil.rmtree(tmp_dir)



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.000 seconds)


.. _sphx_glr_download_auto_tutorials_tutorial_06_csd.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tutorial_06_csd.py <tutorial_06_csd.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tutorial_06_csd.ipynb <tutorial_06_csd.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
