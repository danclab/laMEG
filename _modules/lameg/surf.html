<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lameg.surf &mdash; laMEG 0.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            laMEG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">lameg</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">laMEG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">lameg.surf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lameg.surf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides a set of tools for handling and manipulating surface mesh data, primarily</span>
<span class="sd">used within neuroimaging and computer graphics contexts. The functionalities include computing mesh</span>
<span class="sd">normals, interpolating mesh data, handling non-manifold edges, creating and manipulating GIFTI</span>
<span class="sd">surface files, and downsampling meshes using the VTK library.</span>

<span class="sd">The functions within the module leverage external libraries such as nibabel for neuroimaging data</span>
<span class="sd">management, numpy for numerical operations, scipy for scientific computing tasks like Delaunay</span>
<span class="sd">triangulation, and the VTK toolkit for complex mesh processing tasks such as mesh decimation.</span>

<span class="sd">Key functionalities include:</span>
<span class="sd">- Normalization of vectors to unit length.</span>
<span class="sd">- Calculation of normals for mesh surfaces using both Delaunay triangulation and custom methods.</span>
<span class="sd">- Creation of GIFTI images from mesh data.</span>
<span class="sd">- Removal of specified vertices from a mesh and updating the mesh topology accordingly.</span>
<span class="sd">- Identification and handling of non-manifold edges to ensure mesh manifoldness.</span>
<span class="sd">- Interpolation of data from a downsampled mesh back to its original high-resolution mesh.</span>
<span class="sd">- Downsampling of meshes using VTK&#39;s decimation algorithms.</span>
<span class="sd">- Combination and adjustment of multiple surface meshes into a single mesh.</span>

<span class="sd">The module supports processing of both individual and multiple surfaces, ensuring that operations</span>
<span class="sd">like downsampling, normal computation, and vertex manipulation are optimized for performance and</span>
<span class="sd">applicability in both research and clinical environments.</span>

<span class="sd">Example:</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import nibabel as nib</span>
<span class="sd">    &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; faces = np.array([[0, 1, 2], [0, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; normals = np.array([[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; gifti_img = create_surf_gifti(vertices, faces, normals)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=C0302</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span><span class="p">,</span> <span class="n">cKDTree</span> <span class="c1"># pylint: disable=E0611</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">find</span><span class="p">,</span> <span class="n">csr_matrix</span>

<span class="c1"># pylint: disable=E0611</span>
<span class="kn">from</span> <span class="nn">vtkmodules.vtkCommonCore</span> <span class="kn">import</span> <span class="n">vtkPoints</span>
<span class="kn">from</span> <span class="nn">vtkmodules.vtkCommonDataModel</span> <span class="kn">import</span> <span class="n">vtkPolyData</span><span class="p">,</span> <span class="n">vtkCellArray</span>
<span class="kn">from</span> <span class="nn">vtkmodules.vtkFiltersCore</span> <span class="kn">import</span> <span class="n">vtkDecimatePro</span>
<span class="kn">from</span> <span class="nn">vtkmodules.util.numpy_support</span> <span class="kn">import</span> <span class="n">vtk_to_numpy</span>


<span class="k">def</span> <span class="nf">_normit</span><span class="p">(</span><span class="n">vectors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize a numpy array of vectors.</span>

<span class="sd">    This function normalizes each row in the array vectors to have a unit length. If the length of</span>
<span class="sd">    a vector is below a certain threshold (machine epsilon), it is set to 1 to avoid division by</span>
<span class="sd">    zero.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    vectors (ndarray): Array of vectors to be normalized. Each row represents a vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">    ndarray: Normalized array of vectors where each row has unit length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vectors</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">norm_n</span><span class="p">[</span><span class="n">norm_n</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">vectors</span> <span class="o">/</span> <span class="n">norm_n</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


<div class="viewcode-block" id="mesh_normals"><a class="viewcode-back" href="../../lameg.html#lameg.surf.mesh_normals">[docs]</a><span class="k">def</span> <span class="nf">mesh_normals</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the normals of a mesh.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    vertices (ndarray): Array of vertices of the mesh. Each row represents a vertex.</span>
<span class="sd">    faces (ndarray): Array of faces of the mesh. Each row represents a face with indices to the</span>
<span class="sd">                     vertices array.</span>
<span class="sd">    unit (bool, optional): If True, the normals are normalized to unit length. Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">    tuple: A tuple containing two ndarrays:</span>
<span class="sd">           - vertex_normal: Normal vectors for each vertex.</span>
<span class="sd">           - face_normal: Normal vectors for each face.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">face_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:],</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
    <span class="p">)</span>
    <span class="n">face_normal</span> <span class="o">=</span> <span class="n">_normit</span><span class="p">(</span><span class="n">face_normal</span><span class="p">)</span>

    <span class="n">vertex_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">vertex_normal</span><span class="p">[</span><span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">face_normal</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">centered_vertices</span> <span class="o">=</span> <span class="n">vertices</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">centered_vertices</span> <span class="o">*</span> <span class="n">vertex_normal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span> <span class="o">&gt;</span> \
            <span class="nb">len</span><span class="p">(</span><span class="n">centered_vertices</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">vertex_normal</span> <span class="o">=</span> <span class="o">-</span><span class="n">vertex_normal</span>
        <span class="n">face_normal</span> <span class="o">=</span> <span class="o">-</span><span class="n">face_normal</span>

    <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
        <span class="n">vertex_normal</span> <span class="o">=</span> <span class="n">_normit</span><span class="p">(</span><span class="n">vertex_normal</span><span class="p">)</span>
        <span class="n">face_normal</span> <span class="o">=</span> <span class="n">_normit</span><span class="p">(</span><span class="n">face_normal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vertex_normal</span><span class="p">,</span> <span class="n">face_normal</span></div>


<div class="viewcode-block" id="create_surf_gifti"><a class="viewcode-back" href="../../lameg.html#lameg.surf.create_surf_gifti">[docs]</a><span class="k">def</span> <span class="nf">create_surf_gifti</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a Gifti image object from surface mesh data.</span>

<span class="sd">    This function creates a GiftiImage object from the provided vertices, faces, and optional</span>
<span class="sd">    normals. The vertices and faces are required, while normals are optional. If normals are</span>
<span class="sd">    provided, they are added to the Gifti image. The function returns the GiftiImage object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    vertices (numpy.ndarray): Array of vertices. Each row represents a vertex with its x, y, z</span>
<span class="sd">                              coordinates.</span>
<span class="sd">    faces (numpy.ndarray): Array of faces. Each row represents a face with three integers</span>
<span class="sd">                           corresponding to vertex indices.</span>
<span class="sd">    normals (numpy.ndarray, optional): Array of vertex normals. Each row represents a normal vector</span>
<span class="sd">                                       corresponding to a vertex.</span>

<span class="sd">    Returns:</span>
<span class="sd">    nibabel.gifti.GiftiImage: The GiftiImage object created from the provided mesh data.</span>

<span class="sd">    Notes:</span>
<span class="sd">    - Vertex, face, and normal arrays should be NumPy arrays.</span>
<span class="sd">    - Vertices and normals should be in float32 format, and faces should be in int32 format.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import nibabel as nib</span>
<span class="sd">    &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; faces = np.array([[0, 1, 2], [0, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; normals = np.array([[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; gifti_img = create_surf_gifti(vertices, faces, normals)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create new gifti object</span>
    <span class="n">new_gifti</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiImage</span><span class="p">()</span>

    <span class="c1"># Cast vertices and faces to the appropriate data types</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Add the vertices and faces to the gifti object</span>
    <span class="n">new_gifti</span><span class="o">.</span><span class="n">add_gifti_data_array</span><span class="p">(</span>
        <span class="n">nib</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiDataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span>
            <span class="n">intent</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_POINTSET&#39;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">new_gifti</span><span class="o">.</span><span class="n">add_gifti_data_array</span><span class="p">(</span>
        <span class="n">nib</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiDataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span>
            <span class="n">intent</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_TRIANGLE&#39;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># If normals are provided and not empty, cast them to float32 and add them to the Gifti image</span>
    <span class="k">if</span> <span class="n">normals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">new_gifti</span><span class="o">.</span><span class="n">add_gifti_data_array</span><span class="p">(</span>
            <span class="n">nib</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiDataArray</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">normals</span><span class="p">,</span>
                <span class="n">intent</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">]</span>
            <span class="p">))</span>

    <span class="k">return</span> <span class="n">new_gifti</span></div>


<div class="viewcode-block" id="remove_unconnected_vertices"><a class="viewcode-back" href="../../lameg.html#lameg.surf.remove_unconnected_vertices">[docs]</a><span class="k">def</span> <span class="nf">remove_unconnected_vertices</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes vertices that are not connected to any faces from a Gifti surface object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    gifti_surf (nibabel.gifti.GiftiImage): The Gifti surface object to be processed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    nibabel.gifti.GiftiImage: A new GiftiImage object with unconnected vertices removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the pointset (vertices) and triangle array (faces) from the Gifti surface</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># Find all unique vertex indices that are used in faces</span>
    <span class="n">connected_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="c1"># Determine which vertices are not connected to any faces</span>
    <span class="n">all_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">unconnected_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_vertices</span><span class="p">,</span> <span class="n">connected_vertices</span><span class="p">)</span>

    <span class="c1"># Remove unconnected vertices using the provided remove_vertices function</span>
    <span class="n">cleaned_gifti_surf</span> <span class="o">=</span> <span class="n">remove_vertices</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">,</span> <span class="n">unconnected_vertices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cleaned_gifti_surf</span></div>


<div class="viewcode-block" id="remove_vertices"><a class="viewcode-back" href="../../lameg.html#lameg.surf.remove_vertices">[docs]</a><span class="k">def</span> <span class="nf">remove_vertices</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">,</span> <span class="n">vertices_to_remove</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove specified vertices from a Gifti surface and update the faces accordingly.</span>

<span class="sd">    This function modifies a Gifti surface by removing the specified vertices. It also updates</span>
<span class="sd">    the faces of the surface so that they only reference the remaining vertices. If normals</span>
<span class="sd">    are present in the surface, they are also updated to correspond to the new set of vertices.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    gifti_surf (nibabel.gifti.GiftiImage): The Gifti surface object from which vertices will be</span>
<span class="sd">                                           removed.</span>
<span class="sd">    vertices_to_remove (array_like): An array of vertex indices to be removed from the surface.</span>

<span class="sd">    Returns:</span>
<span class="sd">    nibabel.gifti.GiftiImage: A new GiftiImage object with the specified vertices removed and faces</span>
<span class="sd">                              updated.</span>

<span class="sd">    Notes:</span>
<span class="sd">    - The function assumes that the GiftiImage object contains at least two data arrays: one for</span>
<span class="sd">      vertices and one for faces. If normals are present, they are also updated.</span>
<span class="sd">    - Vertex indices in `vertices_to_remove` should be zero-based (following Python&#39;s indexing</span>
<span class="sd">      convention).</span>
<span class="sd">    - The returned GiftiImage object is a new object; the original `gifti_surf` object is not</span>
<span class="sd">      modified in place.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; import nibabel as nib</span>
<span class="sd">    &gt;&gt;&gt; gifti_surf = nib.load(&#39;path_to_gifti_file.gii&#39;)</span>
<span class="sd">    &gt;&gt;&gt; vertices_to_remove = np.array([0, 2, 5])  # Indices of vertices to remove</span>
<span class="sd">    &gt;&gt;&gt; new_gifti_surf = remove_vertices(gifti_surf, vertices_to_remove)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Extract vertices and faces from the gifti object</span>
    <span class="n">vertices_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">da</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span>
                     <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_POINTSET&#39;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">faces_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">da</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span>
                  <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_TRIANGLE&#39;</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices_data</span><span class="o">.</span><span class="n">data</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">faces_data</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># Determine vertices to keep</span>
    <span class="n">vertices_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">vertices_to_remove</span><span class="p">)</span>

    <span class="c1"># Create new array of vertices</span>
    <span class="n">new_vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vertices_to_keep</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Find which faces to keep - ones that point to kept vertices</span>
    <span class="k">if</span> <span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">face_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vertices_to_keep</span><span class="p">)</span>
        <span class="n">face_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vertices_to_keep</span><span class="p">)</span>
        <span class="n">face_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">vertices_to_keep</span><span class="p">)</span>
        <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_x</span> <span class="o">&amp;</span> <span class="n">face_y</span> <span class="o">&amp;</span> <span class="n">face_z</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Re-index faces</span>
        <span class="n">x_faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">faces_to_keep</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">vertices_to_keep</span><span class="p">,</span> <span class="n">x_faces</span><span class="p">)</span>
        <span class="n">new_faces</span> <span class="o">=</span> <span class="n">idxs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_faces</span> <span class="o">=</span> <span class="n">faces</span>

    <span class="c1"># Create new gifti object</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">normals_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">da</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span>
                    <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">normals_data</span><span class="p">:</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">normals_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">vertices_to_keep</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">new_gifti</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span><span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_faces</span><span class="p">,</span> <span class="n">normals</span><span class="o">=</span><span class="n">normals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_gifti</span></div>


<div class="viewcode-block" id="find_non_manifold_edges"><a class="viewcode-back" href="../../lameg.html#lameg.surf.find_non_manifold_edges">[docs]</a><span class="k">def</span> <span class="nf">find_non_manifold_edges</span><span class="p">(</span><span class="n">faces</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies non-manifold edges in a given mesh represented by its faces.</span>

<span class="sd">    A non-manifold edge is defined as an edge that is shared by more than two faces. This function</span>
<span class="sd">    processes an array of faces, each face represented by a tuple of vertex indices, and identifies</span>
<span class="sd">    edges that meet the non-manifold criteria.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    faces (np.ndarray): An array where each row represents a face as a tuple of three vertex</span>
<span class="sd">                        indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">    dict: A dictionary where keys are tuples representing non-manifold edges (vertices indices are</span>
<span class="sd">          sorted), and values are lists of face indices that share the edge.</span>

<span class="sd">    The function uses a defaultdict to collect face indices for each edge encountered in the mesh.</span>
<span class="sd">    It then filters out edges that are associated with more than two faces, identifying them as</span>
<span class="sd">    non-manifold.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge_faces</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">vertex_1</span><span class="p">,</span> <span class="n">vertex_2</span><span class="p">,</span> <span class="n">vertex_3</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">vertex_1</span><span class="p">,</span> <span class="n">vertex_2</span><span class="p">),</span> <span class="p">(</span><span class="n">vertex_2</span><span class="p">,</span> <span class="n">vertex_3</span><span class="p">),</span> <span class="p">(</span><span class="n">vertex_3</span><span class="p">,</span> <span class="n">vertex_1</span><span class="p">)]:</span>
            <span class="n">edge_faces</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">edge</span><span class="p">))]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">non_manifold_edges</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge</span><span class="p">:</span> <span class="n">fcs</span> <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">fcs</span> <span class="ow">in</span> <span class="n">edge_faces</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">non_manifold_edges</span></div>


<div class="viewcode-block" id="fix_non_manifold_edges"><a class="viewcode-back" href="../../lameg.html#lameg.surf.fix_non_manifold_edges">[docs]</a><span class="k">def</span> <span class="nf">fix_non_manifold_edges</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes faces associated with non-manifold edges from a mesh defined by vertices and faces.</span>

<span class="sd">    Non-manifold edges are edges that are shared by more than two faces, which can cause issues</span>
<span class="sd">    in various mesh processing tasks such as mesh simplification, smoothing, or 3D printing. This</span>
<span class="sd">    function identifies such edges and removes all faces associated with them to ensure</span>
<span class="sd">    manifoldness of the mesh.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    vertices (np.ndarray): An array of vertices, where each row represents a vertex as [x, y, z]</span>
<span class="sd">                           coordinates.</span>
<span class="sd">    faces (np.ndarray): An array of faces, where each row represents a face as indices into the</span>
<span class="sd">                        vertices array.</span>

<span class="sd">    Returns:</span>
<span class="sd">    tuple: A tuple containing two elements:</span>
<span class="sd">        - np.ndarray: The unchanged array of vertices.</span>
<span class="sd">        - np.ndarray: The modified array of faces, with faces associated with non-manifold edges</span>
<span class="sd">                      removed.</span>

<span class="sd">    Examples:</span>
<span class="sd">    &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; faces = np.array([[0, 1, 2], [0, 2, 3], [1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; new_vertices, new_faces = fix_non_manifold_edges(vertices, faces)</span>
<span class="sd">    &gt;&gt;&gt; new_faces</span>
<span class="sd">    array([[0, 1, 2], [0, 2, 3]])  # Assuming face [1, 2, 3] was associated with a non-manifold</span>
<span class="sd">                                   # edge</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">non_manifold_edges</span> <span class="o">=</span> <span class="n">find_non_manifold_edges</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>
    <span class="n">conflicting_faces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">faces_list</span> <span class="ow">in</span> <span class="n">non_manifold_edges</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">conflicting_faces</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">faces_list</span><span class="p">)</span>

    <span class="c1"># Create a new face list excluding the conflicting faces</span>
    <span class="n">new_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">face</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conflicting_faces</span><span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">new_faces</span></div>


<div class="viewcode-block" id="downsample_single_surface"><a class="viewcode-back" href="../../lameg.html#lameg.surf.downsample_single_surface">[docs]</a><span class="k">def</span> <span class="nf">downsample_single_surface</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">,</span> <span class="n">ds_factor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downsample a Gifti surface using the VTK library.</span>

<span class="sd">    This function takes a Gifti surface defined by its vertices and faces, and downsamples it using</span>
<span class="sd">    VTK&#39;s vtkDecimatePro algorithm. The reduction ratio determines the degree of downsampling.</span>
<span class="sd">    The function returns the downsampled Gifti surface.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    gifti_surf (nibabel.gifti.GiftiImage): The Gifti surface object from which vertices will be</span>
<span class="sd">                                           removed.</span>
<span class="sd">    reduction_ratio (float): The proportion of the mesh to remove. For example, a reduction ratio</span>
<span class="sd">                             of 0.1 retains 90% of the original mesh.</span>

<span class="sd">    Returns:</span>
<span class="sd">    nibabel.gifti.GiftiImage: A new GiftiImage object with the downsampled surface.</span>

<span class="sd">    Notes:</span>
<span class="sd">    - The input faces array should be triangulated, i.e., each face should consist of exactly three</span>
<span class="sd">      vertex indices.</span>
<span class="sd">    - The VTK library is used for mesh decimation, which must be installed and properly configured.</span>
<span class="sd">    - The returned GiftiImage object is a new object; the original `gifti_surf` object is not</span>
<span class="sd">      modified in place.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; gifti_surf = nib.load(&#39;path_to_gifti_file.gii&#39;)</span>
<span class="sd">    &gt;&gt;&gt; new_gifti_surf = downsample_single_surface(gifti_surf, 0.1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vertices</span> <span class="o">=</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># Convert vertices and faces to a VTK PolyData object</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">vtkPoints</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
        <span class="n">points</span><span class="o">.</span><span class="n">InsertNextPoint</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

    <span class="n">cells</span> <span class="o">=</span> <span class="n">vtkCellArray</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
        <span class="n">cells</span><span class="o">.</span><span class="n">InsertNextCell</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
            <span class="n">cells</span><span class="o">.</span><span class="n">InsertCellPoint</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

    <span class="n">polydata</span> <span class="o">=</span> <span class="n">vtkPolyData</span><span class="p">()</span>
    <span class="n">polydata</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">polydata</span><span class="o">.</span><span class="n">SetPolys</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

    <span class="c1"># Apply vtkDecimatePro for decimation</span>
    <span class="n">decimate</span> <span class="o">=</span> <span class="n">vtkDecimatePro</span><span class="p">()</span>
    <span class="n">decimate</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">polydata</span><span class="p">)</span>
    <span class="n">decimate</span><span class="o">.</span><span class="n">SetTargetReduction</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ds_factor</span><span class="p">)</span>
    <span class="n">decimate</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>

    <span class="c1"># Extract the decimated mesh</span>
    <span class="n">decimated_polydata</span> <span class="o">=</span> <span class="n">decimate</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>

    <span class="c1"># Convert back to numpy arrays</span>
    <span class="n">reduced_vertices</span> <span class="o">=</span> <span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">decimated_polydata</span><span class="o">.</span><span class="n">GetPoints</span><span class="p">()</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span>

    <span class="c1"># Extract and reshape the face data</span>
    <span class="n">face_data</span> <span class="o">=</span> <span class="n">vtk_to_numpy</span><span class="p">(</span><span class="n">decimated_polydata</span><span class="o">.</span><span class="n">GetPolys</span><span class="p">()</span><span class="o">.</span><span class="n">GetData</span><span class="p">())</span>
    <span class="c1"># Assuming the mesh is triangulated, every fourth item is the size (3), followed by three</span>
    <span class="c1"># vertex indices</span>
    <span class="n">reduced_faces</span> <span class="o">=</span> <span class="n">face_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="c1"># Find the original vertices closest to the downsampled vertices</span>
    <span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">orig_vert_idx</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">reduced_vertices</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">reduced_normals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> \
            <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">]</span> <span class="ow">and</span> \
            <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">reduced_normals</span> <span class="o">=</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">orig_vert_idx</span><span class="p">]</span>

    <span class="n">new_gifti_surf</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span><span class="n">reduced_vertices</span><span class="p">,</span> <span class="n">reduced_faces</span><span class="p">,</span> <span class="n">normals</span><span class="o">=</span><span class="n">reduced_normals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_gifti_surf</span></div>


<div class="viewcode-block" id="iterative_downsample_single_surface"><a class="viewcode-back" href="../../lameg.html#lameg.surf.iterative_downsample_single_surface">[docs]</a><span class="k">def</span> <span class="nf">iterative_downsample_single_surface</span><span class="p">(</span><span class="n">gifti_surf</span><span class="p">,</span> <span class="n">ds_factor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Iteratively downsample a single surface mesh to a target number of vertices.</span>

<span class="sd">   This function reduces the number of vertices in a surface mesh (in GIFTI format) to a specified</span>
<span class="sd">   fraction of its original size. Downsampling is performed iteratively until the target number of</span>
<span class="sd">   vertices is reached or closely approximated.</span>

<span class="sd">   Parameters:</span>
<span class="sd">   gifti_surf (nibabel.gifti.GiftiImage): The surface mesh to be downsampled, provided as a GIFTI</span>
<span class="sd">                                          image object.</span>
<span class="sd">   ds_factor (float, optional): The downsampling factor representing the target fraction of the</span>
<span class="sd">                                original number of vertices. Default is 0.1.</span>

<span class="sd">   Returns:</span>
<span class="sd">   nibabel.gifti.GiftiImage: The downsampled surface mesh as a GIFTI image object.</span>

<span class="sd">   Notes:</span>
<span class="sd">   - The downsampling process is iterative. In each iteration, the mesh is downsampled by a factor</span>
<span class="sd">     calculated to approach the target number of vertices.</span>
<span class="sd">   - If the calculated downsampling factor in an iteration equals or exceeds 1, the process is</span>
<span class="sd">     terminated to prevent upsampling or infinite loops.</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="n">current_surf</span> <span class="o">=</span> <span class="n">gifti_surf</span>
    <span class="n">current_vertices</span> <span class="o">=</span> <span class="n">gifti_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">target_vertices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">current_vertices</span> <span class="o">*</span> <span class="n">ds_factor</span><span class="p">)</span>
    <span class="n">current_ds_factor</span> <span class="o">=</span> <span class="n">target_vertices</span> <span class="o">/</span> <span class="n">current_vertices</span>

    <span class="k">while</span> <span class="n">current_vertices</span> <span class="o">&gt;</span> <span class="n">target_vertices</span><span class="p">:</span>
        <span class="c1"># Downsample the mesh</span>
        <span class="n">current_surf</span> <span class="o">=</span> <span class="n">downsample_single_surface</span><span class="p">(</span><span class="n">current_surf</span><span class="p">,</span> <span class="n">ds_factor</span><span class="o">=</span><span class="n">current_ds_factor</span><span class="p">)</span>

        <span class="c1"># Update the current vertices</span>
        <span class="n">current_vertices</span> <span class="o">=</span> <span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">current_ds_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_vertices</span> <span class="o">/</span> <span class="n">current_vertices</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.25</span>
        <span class="k">if</span> <span class="n">current_ds_factor</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Remove non-manifold edges</span>
    <span class="n">ds_vertices</span> <span class="o">=</span> <span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">ds_faces</span> <span class="o">=</span> <span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">nonmani_vertices</span><span class="p">,</span> <span class="n">nonmani_faces</span> <span class="o">=</span> <span class="n">fix_non_manifold_edges</span><span class="p">(</span><span class="n">ds_vertices</span><span class="p">,</span> <span class="n">ds_faces</span><span class="p">)</span>

    <span class="n">normals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> \
            <span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">]</span> <span class="ow">and</span> \
            <span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">current_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="n">current_surf</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span><span class="n">nonmani_vertices</span><span class="p">,</span> <span class="n">nonmani_faces</span><span class="p">,</span> <span class="n">normals</span><span class="o">=</span><span class="n">normals</span><span class="p">)</span>

    <span class="c1"># Remove unconnected vertices</span>
    <span class="n">current_surf</span> <span class="o">=</span> <span class="n">remove_unconnected_vertices</span><span class="p">(</span><span class="n">current_surf</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">current_surf</span></div>


<div class="viewcode-block" id="downsample_multiple_surfaces"><a class="viewcode-back" href="../../lameg.html#lameg.surf.downsample_multiple_surfaces">[docs]</a><span class="k">def</span> <span class="nf">downsample_multiple_surfaces</span><span class="p">(</span><span class="n">in_surfs</span><span class="p">,</span> <span class="n">ds_factor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downampled multiple surface meshes using the VTK decimation algorithm.</span>

<span class="sd">    This function takes a list of input surface meshes (in Gifti format) and applies a dowsampling</span>
<span class="sd">    process to each surface. The downsampling is performed using VTK&#39;s vtkDecimatePro algorithm.</span>
<span class="sd">    The first surface in the list is downsampled, and its vertex mapping is then applied to all</span>
<span class="sd">    other surfaces in the list. The function returns a list of downsampled surface meshes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    in_surfs (list of nibabel.gifti.GiftiImage): Input Gifti surface meshes to be downsampled.</span>
<span class="sd">    ratio (float): The reduction ratio for the downsampling process. For example, a ratio of 0.1</span>
<span class="sd">                   implies that the mesh will be reduced to 90% of its original size.</span>

<span class="sd">    Returns:</span>
<span class="sd">    list of nibabel.gifti.GiftiImage: List of downsampled Gifti surface meshes.</span>

<span class="sd">    Notes:</span>
<span class="sd">    - The function prints the percentage of vertices retained in the first surface after</span>
<span class="sd">      downsampling.</span>
<span class="sd">    - If normals are present in the input surfaces, they are also downsampled and mapped to the</span>
<span class="sd">      new surfaces.</span>
<span class="sd">    - The resulting surfaces maintain the original topology and are suitable for visualization and</span>
<span class="sd">      further processing.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; import nibabel as nib</span>
<span class="sd">    &gt;&gt;&gt; in_surfs = [nib.load(&#39;path/to/input_surf1.gii&#39;), nib.load(&#39;path/to/input_surf2.gii&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; ratio = 0.1</span>
<span class="sd">    &gt;&gt;&gt; out_surfs = downsample_multiple_surfaces(in_surfs, ds_factor)</span>
<span class="sd">    &gt;&gt;&gt; for i, ds_surf in enumerate(out_surfs):</span>
<span class="sd">    ...     nib.save(ds_surf, f&#39;path/to/output_surf{i+1}.gii&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_surfs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">primary_surf</span> <span class="o">=</span> <span class="n">in_surfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ds_primary_surf</span> <span class="o">=</span> <span class="n">iterative_downsample_single_surface</span><span class="p">(</span><span class="n">primary_surf</span><span class="p">,</span> <span class="n">ds_factor</span><span class="o">=</span><span class="n">ds_factor</span><span class="p">)</span>
    <span class="n">reduced_vertices</span> <span class="o">=</span> <span class="n">ds_primary_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">reduced_faces</span> <span class="o">=</span> <span class="n">ds_primary_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># Find the original vertices closest to the downsampled vertices</span>
    <span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">primary_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># Calculate the percentage of vertices retained</span>
    <span class="n">decim_orig_dist</span><span class="p">,</span> <span class="n">orig_vert_idx</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">reduced_vertices</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">decim_orig_dist</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">}</span><span class="s2">% of the vertices in the decimated surface &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;belong to the original surface.&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Save the downsampled primary surface with normals</span>
    <span class="n">out_surfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds_primary_surf</span><span class="p">)</span>

    <span class="c1"># Process other surfaces</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_surfs</span><span class="p">)):</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">in_surfs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">reduced_normals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> \
                <span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">]</span> <span class="ow">and</span> \
                <span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">reduced_normals</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">orig_vert_idx</span><span class="p">]</span>

        <span class="n">surf_verts</span><span class="o">=</span><span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">orig_vert_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">nonmani_vertices</span><span class="p">,</span> <span class="n">nonmani_faces</span> <span class="o">=</span> <span class="n">fix_non_manifold_edges</span><span class="p">(</span><span class="n">surf_verts</span><span class="p">,</span> <span class="n">reduced_faces</span><span class="p">)</span>

        <span class="n">ds_surf</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span><span class="n">nonmani_vertices</span><span class="p">,</span> <span class="n">nonmani_faces</span><span class="p">,</span> <span class="n">normals</span><span class="o">=</span><span class="n">reduced_normals</span><span class="p">)</span>

        <span class="n">out_surfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds_surf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out_surfs</span></div>


<div class="viewcode-block" id="combine_surfaces"><a class="viewcode-back" href="../../lameg.html#lameg.surf.combine_surfaces">[docs]</a><span class="k">def</span> <span class="nf">combine_surfaces</span><span class="p">(</span><span class="n">surfaces</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine multiple surface meshes into a single surface mesh.</span>

<span class="sd">    This function takes a list of Gifti surface meshes and combines them into a single surface</span>
<span class="sd">    mesh. It concatenates the vertices, faces, and normals (if present) from each surface. The</span>
<span class="sd">    faces are re-indexed appropriately to maintain the correct references to the combined vertex</span>
<span class="sd">    array.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    surfaces (list of nibabel.gifti.GiftiImage): List of Gifti surface meshes to be combined.</span>

<span class="sd">    Returns:</span>
<span class="sd">    nibabel.gifti.GiftiImage: A single combined Gifti surface mesh.</span>

<span class="sd">    Notes:</span>
<span class="sd">    - The vertices, faces, and normals (if present) from each surface are concatenated.</span>
<span class="sd">    - The faces are re-indexed to reference the correct vertices in the combined vertex array.</span>
<span class="sd">    - If normals are present in any of the input surfaces, they are also combined.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If the vertex or face arrays do not have the expected dimensions.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; import nibabel as nib</span>
<span class="sd">    &gt;&gt;&gt; surfaces = [nib.load(&#39;path/to/surface1.gii&#39;), nib.load(&#39;path/to/surface2.gii&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; combined_surf = combine_surfaces(surfaces)</span>
<span class="sd">    &gt;&gt;&gt; nib.save(combined_surf, &#39;path/to/combined_surface.gii&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">combined_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">combined_faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">combined_normals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">face_offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="n">surfaces</span><span class="p">:</span>

        <span class="c1"># Extract vertices and faces</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">darrays</span>
             <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_POINTSET&#39;</span><span class="p">]])</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">darrays</span>
             <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_TRIANGLE&#39;</span><span class="p">]])</span>

        <span class="c1"># Check for normals</span>
        <span class="n">normal_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">darrays</span>
                         <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">]]</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">normal_arrays</span><span class="p">)</span> <span class="k">if</span> <span class="n">normal_arrays</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="n">combined_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">combined_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">faces</span> <span class="o">+</span> <span class="n">face_offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normals</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">combined_normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span>

        <span class="n">face_offset</span> <span class="o">+=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Combine the arrays</span>
    <span class="n">combined_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">combined_vertices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">combined_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">combined_faces</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">combined_normals</span><span class="p">:</span>
        <span class="n">combined_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">combined_normals</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">combined_surf</span> <span class="o">=</span> <span class="n">create_surf_gifti</span><span class="p">(</span>
        <span class="n">combined_vertices</span><span class="p">,</span>
        <span class="n">combined_faces</span><span class="p">,</span>
        <span class="n">normals</span><span class="o">=</span><span class="n">combined_normals</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">combined_surf</span></div>


<span class="c1"># pylint: disable=R0912</span>
<div class="viewcode-block" id="compute_dipole_orientations"><a class="viewcode-back" href="../../lameg.html#lameg.surf.compute_dipole_orientations">[docs]</a><span class="k">def</span> <span class="nf">compute_dipole_orientations</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">layer_names</span><span class="p">,</span> <span class="n">surf_dir</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute dipole orientations for cortical layers using different methods.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    method (str): Method for computing dipole orientations (&#39;link_vector&#39;, &#39;ds_surf_norm&#39;,</span>
<span class="sd">                  &#39;orig_surf_norm&#39;, or &#39;cps&#39;).</span>
<span class="sd">                  link_vector: vectors connecting pial vertices to corresponding white matter </span>
<span class="sd">                               vertices</span>
<span class="sd">                  ds_surf_norm: surface normal vectors computed from the downsampled surface</span>
<span class="sd">                  orig_surf_norm: surface normal vectors computed from the original</span>
<span class="sd">                                  (non-downsampled) surface</span>
<span class="sd">                  cps: cortical patch statistics - mean surface normal vectors from connected</span>
<span class="sd">                       vertices in the original (non-downsampled) surface</span>
<span class="sd">    layer_names (list): Names of the cortical layers.</span>
<span class="sd">    surf_dir (str): Directory where the surface files are stored.</span>
<span class="sd">    fixed (bool, optional): Flag to ensure that orientation of corresponding vertices across</span>
<span class="sd">                            layers is the same (True by default). If true, for ds_surf_norm,</span>
<span class="sd">                            orig_surf_norm, and cps, orientations computed from the pial surface</span>
<span class="sd">                            are used for all layers.</span>

<span class="sd">    Returns:</span>
<span class="sd">    numpy.ndarray: An array of dipole orientations for each vertex in each layer.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ValueError: If the number of vertices in pial and white surfaces do not match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">orientations</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;link_vector&#39;</span><span class="p">:</span>
        <span class="c1"># Method: Use link vectors between pial and white surfaces as dipole orientations</span>
        <span class="c1"># Load downsampled pial and white surfaces</span>
        <span class="n">pial_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="s1">&#39;pial.ds.gii&#39;</span><span class="p">))</span>
        <span class="n">white_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="s1">&#39;white.ds.gii&#39;</span><span class="p">))</span>

        <span class="c1"># Extract vertices</span>
        <span class="n">pial_vertices</span> <span class="o">=</span> <span class="n">pial_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">white_vertices</span> <span class="o">=</span> <span class="n">white_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Ensure same number of vertices in pial and white surfaces</span>
        <span class="k">if</span> <span class="n">pial_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">white_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pial and white surfaces must have the same number of vertices&quot;</span><span class="p">)</span>

        <span class="c1"># Compute link vectors</span>
        <span class="n">link_vectors</span> <span class="o">=</span> <span class="n">white_vertices</span> <span class="o">-</span> <span class="n">pial_vertices</span>
        <span class="n">link_vectors</span> <span class="o">=</span> <span class="n">_normit</span><span class="p">(</span><span class="n">link_vectors</span><span class="p">)</span>

        <span class="c1"># Replicate link vectors for each layer</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">link_vectors</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer_names</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ds_surf_norm&#39;</span><span class="p">:</span>
        <span class="c1"># Method: Use normals of the downsampled surfaces</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l_idx</span><span class="p">,</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">:</span>
                <span class="n">in_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.ds.gii&#39;</span><span class="p">)</span>
                <span class="n">surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_surf_path</span><span class="p">)</span>
                <span class="n">vtx_norms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mesh_normals</span><span class="p">(</span>
                    <span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">unit</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="n">orientations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vtx_norms</span><span class="p">)</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orientations</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;orig_surf_norm&#39;</span><span class="p">:</span>
        <span class="c1"># Method: Use normals of the original surfaces, mapped to downsampled surfaces</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l_idx</span><span class="p">,</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">:</span>
                <span class="n">in_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
                <span class="n">orig_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_surf_path</span><span class="p">)</span>
                <span class="n">ds_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.ds.gii&#39;</span><span class="p">)</span>
                <span class="n">ds_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ds_surf_path</span><span class="p">)</span>
                <span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">orig_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">orig_vert_idx</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">ds_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">vtx_norms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mesh_normals</span><span class="p">(</span>
                    <span class="n">orig_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">orig_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">unit</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="n">orientations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vtx_norms</span><span class="p">[</span><span class="n">orig_vert_idx</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orientations</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cps&#39;</span><span class="p">:</span>
        <span class="c1"># Method: Use cortical patch statistics for normals</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l_idx</span><span class="p">,</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">:</span>
                <span class="n">in_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
                <span class="n">orig_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_surf_path</span><span class="p">)</span>
                <span class="n">ds_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">surf_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.ds.gii&#39;</span><span class="p">)</span>
                <span class="n">ds_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ds_surf_path</span><span class="p">)</span>
                <span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">ds_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ds_vert_idx</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">orig_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">orig_vtx_norms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mesh_normals</span><span class="p">(</span>
                    <span class="n">orig_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">orig_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">unit</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">vtx_norms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mesh_normals</span><span class="p">(</span>
                    <span class="n">ds_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">ds_surf</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">unit</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">v_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vtx_norms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">orig_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ds_vert_idx</span> <span class="o">==</span> <span class="n">v_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_idxs</span><span class="p">):</span>
                        <span class="n">vtx_norms</span><span class="p">[</span><span class="n">v_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">orig_vtx_norms</span><span class="p">[</span><span class="n">orig_idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">vtx_norms</span> <span class="o">=</span> <span class="n">_normit</span><span class="p">(</span><span class="n">vtx_norms</span><span class="p">)</span>
            <span class="n">orientations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vtx_norms</span><span class="p">)</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orientations</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">orientations</span></div>


<div class="viewcode-block" id="create_layer_mesh"><a class="viewcode-back" href="../../lameg.html#lameg.surf.create_layer_mesh">[docs]</a><span class="k">def</span> <span class="nf">create_layer_mesh</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">hemispheres</span><span class="p">,</span> <span class="n">fs_subject_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create or retrieve a specified cortical layer mesh file name or path based on the provided</span>
<span class="sd">    layer proportional thickness or identifier.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    layer (float or int): Specifies the cortical layer. The value 1 corresponds to the &#39;pial&#39;</span>
<span class="sd">                          surface, values between 0 and 1 (exclusive) correspond to intermediate</span>
<span class="sd">                          layers (specified as a decimal), and the value 0 corresponds to the</span>
<span class="sd">                          &#39;white&#39; surface.</span>
<span class="sd">    hemispheres (list of str): A list of hemisphere identifiers (e.g., [&#39;lh&#39;, &#39;rh&#39;]) for which</span>
<span class="sd">                               meshes should be created or retrieved.</span>
<span class="sd">    fs_subject_dir (str): Path to the subject directory within the FreeSurfer environment. This</span>
<span class="sd">                          directory should include a &#39;surf&#39; directory where mesh files are stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    str or None: Returns a string representing the mesh layer (&#39;pial&#39;, &#39;white&#39;, or a specific</span>
<span class="sd">                 intermediate layer as a formatted string). Returns None if the input layer does</span>
<span class="sd">                 not match any recognized pattern (e.g., a negative number or a number greater</span>
<span class="sd">                 than 1).</span>

<span class="sd">    Behavior:</span>
<span class="sd">    For intermediate layers (0 &lt; layer &lt; 1), the function will check for the existence of the mesh</span>
<span class="sd">    file corresponding to each hemisphere. If it does not exist, it uses &#39;mris_expand&#39; to generate</span>
<span class="sd">    it using the white matter surface file. If the layer exactly matches 0 or 1, it returns the</span>
<span class="sd">    corresponding standard FreeSurfer mesh identifier (&#39;white&#39; or &#39;pial&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">layer</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;pial&#39;</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">layer</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">layer_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">hemi</span> <span class="ow">in</span> <span class="n">hemispheres</span><span class="p">:</span>
            <span class="n">wm_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fs_subject_dir</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">hemi</span><span class="si">}</span><span class="s1">.white&#39;</span><span class="p">)</span>
            <span class="n">out_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fs_subject_dir</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">hemi</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out_file</span><span class="p">):</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mris_expand&#39;</span><span class="p">,</span> <span class="s1">&#39;-thickness&#39;</span><span class="p">,</span> <span class="n">wm_file</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">out_file</span><span class="p">]</span>
                <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">layer_name</span>
    <span class="k">if</span> <span class="n">layer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;white&#39;</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<span class="c1"># pylint: disable=R0912,R0915</span>
<div class="viewcode-block" id="postprocess_freesurfer_surfaces"><a class="viewcode-back" href="../../lameg.html#lameg.surf.postprocess_freesurfer_surfaces">[docs]</a><span class="k">def</span> <span class="nf">postprocess_freesurfer_surfaces</span><span class="p">(</span><span class="n">subj_id</span><span class="p">,</span>
                                    <span class="n">out_dir</span><span class="p">,</span>
                                    <span class="n">out_fname</span><span class="p">,</span>
                                    <span class="n">n_surfaces</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
                                    <span class="n">ds_factor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                                    <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;link_vector&#39;</span><span class="p">,</span>
                                    <span class="n">fix_orientation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">remove_deep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process and combine FreeSurfer surface meshes for a subject.</span>

<span class="sd">    This function processes FreeSurfer surface meshes for a given subject by creating intermediate</span>
<span class="sd">    surfaces, adjusting for RAS offset, removing deep vertices, combining hemispheres,</span>
<span class="sd">    downsampling, and computing link vectors. The resulting surfaces are combined and saved to a</span>
<span class="sd">    specified output file.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    subj_id (str): Subject ID corresponding to the FreeSurfer subject directory.</span>
<span class="sd">    out_dir (str): Output directory where the processed files will be saved.</span>
<span class="sd">    out_fname (str): Filename for the final combined surface mesh.</span>
<span class="sd">    n_surfaces (int, optional): Number of intermediate surfaces to create between white and pial</span>
<span class="sd">                                surfaces.</span>
<span class="sd">    ds_factor (float, optional): Downsampling factor for surface decimation.</span>
<span class="sd">    orientation (str, optional): Method to compute orientation vectors (&#39;link_vector&#39; for</span>
<span class="sd">                                 pial-white link, &#39;ds_surf_norm&#39; for downsampled surface normals,</span>
<span class="sd">                                 &#39;orig_surf_norm&#39; for original surface normals, and &#39;cps&#39; for</span>
<span class="sd">                                 cortical patch statistics).</span>
<span class="sd">    fix_orientation (bool, optional): Flag to ensure that orientation of corresponding vertices</span>
<span class="sd">                                      across layers is the same (True by default)</span>
<span class="sd">    remove_deep (bool, optional): Flag to remove vertices located in deep regions (labeled as</span>
<span class="sd">                                  &#39;unknown&#39;).</span>
<span class="sd">    n_jobs (int, optional): Number of parallel processes to run. -1 for all available cores (-1 by</span>
<span class="sd">                            default)</span>

<span class="sd">    Notes:</span>
<span class="sd">    - This function assumes the FreeSurfer &#39;SUBJECTS_DIR&#39; environment variable is set.</span>
<span class="sd">    - Surfaces are processed in Gifti format and combined into a single surface mesh.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; postprocess_freesurfer_surfaces(&#39;subject1&#39;, &#39;/path/to/output&#39;, &#39;combined_surface.gii&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hemispheres</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;lh&#39;</span><span class="p">,</span> <span class="s1">&#39;rh&#39;</span><span class="p">]</span>
    <span class="n">fs_subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;SUBJECTS_DIR&#39;</span><span class="p">)</span>

    <span class="n">fs_subject_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fs_subjects_dir</span><span class="p">,</span> <span class="n">subj_id</span><span class="p">)</span>

    <span class="n">layers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_surfaces</span><span class="p">)</span>

    <span class="c1">## Create intermediate surfaces if needed</span>
    <span class="n">layer_names</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;loky&#39;</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">create_layer_mesh</span><span class="p">)(</span><span class="n">layer</span><span class="p">,</span> <span class="n">hemispheres</span><span class="p">,</span> <span class="n">fs_subject_dir</span><span class="p">)</span> <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers</span>
    <span class="p">)</span>

    <span class="c1">## Compute RAS offset</span>
    <span class="c1"># Define the path to the MRI file</span>
    <span class="n">ras_off_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fs_subject_dir</span><span class="p">,</span> <span class="s1">&#39;mri&#39;</span><span class="p">,</span> <span class="s1">&#39;orig.mgz&#39;</span><span class="p">)</span>

    <span class="c1"># Execute the shell command to get RAS offset</span>
    <span class="n">command</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;mri_info --cras </span><span class="si">{</span><span class="n">ras_off_file</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">with</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span>
            <span class="n">command</span><span class="p">,</span>
            <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">process</span><span class="p">:</span>
        <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>

    <span class="c1"># Parse the output</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">ras_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>

    <span class="c1"># Print the result</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ras_offset</span><span class="p">)</span>

    <span class="c1">## Convert to gifti, adjust for RAS offset, and remove deep vertices</span>
    <span class="n">surfaces_to_process</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">layer_names</span><span class="p">)</span>
    <span class="n">surfaces_to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;inflated&#39;</span><span class="p">)</span>

    <span class="c1"># pylint: disable=R1702</span>
    <span class="k">for</span> <span class="n">surface_name</span> <span class="ow">in</span> <span class="n">surfaces_to_process</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">hemi</span> <span class="ow">in</span> <span class="n">hemispheres</span><span class="p">:</span>
            <span class="c1"># Construct the original and new file names</span>
            <span class="n">orig_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fs_subject_dir</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">hemi</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">hemi</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
            <span class="n">rm_deep_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">hemi</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.nodeep.gii&#39;</span><span class="p">)</span>

            <span class="c1"># Convert the surface file to Gifti format</span>
            <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s1">&#39;mris_convert&#39;</span><span class="p">,</span> <span class="n">orig_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Load the Gifti file</span>
            <span class="n">surf_g</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

            <span class="c1"># Set transformation matrix to identity</span>
            <span class="n">surf_g</span><span class="o">.</span><span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

            <span class="c1"># Adjust for RAS offset</span>
            <span class="n">n_vertices</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">data_array</span> <span class="ow">in</span> <span class="n">surf_g</span><span class="o">.</span><span class="n">darrays</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">intent</span> <span class="o">==</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_POINTSET&#39;</span><span class="p">]:</span>
                    <span class="n">data_array</span><span class="o">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">ras_offset</span>
                    <span class="n">n_vertices</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surf_g</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

            <span class="n">annotation</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fs_subject_dir</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">hemi</span><span class="si">}</span><span class="s1">.aparc.annot&#39;</span><span class="p">)</span>
            <span class="n">label</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">freesurfer</span><span class="o">.</span><span class="n">read_annot</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

            <span class="c1"># Remove vertices created by cutting the hemispheres</span>
            <span class="k">if</span> <span class="n">remove_deep</span><span class="p">:</span>
                <span class="n">vertices_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">vtx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">vtx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">region</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="n">vtx</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;unknown&#39;</span><span class="p">:</span>
                            <span class="n">vertices_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vtx</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vertices_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vtx</span><span class="p">)</span>
                <span class="n">surf_g</span> <span class="o">=</span> <span class="n">remove_vertices</span><span class="p">(</span><span class="n">surf_g</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices_to_remove</span><span class="p">))</span>

            <span class="c1"># Save the modified Gifti file</span>
            <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surf_g</span><span class="p">,</span> <span class="n">rm_deep_name</span><span class="p">)</span>

    <span class="c1">## Combine hemispheres</span>
    <span class="k">for</span> <span class="n">surface_name</span> <span class="ow">in</span> <span class="n">surfaces_to_process</span><span class="p">:</span>
        <span class="c1"># Load left and right hemisphere surfaces</span>
        <span class="n">lh_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;lh.</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.nodeep.gii&#39;</span><span class="p">)</span>
        <span class="n">l_hemi</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">lh_fname</span><span class="p">)</span>
        <span class="n">rh_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;rh.</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.nodeep.gii&#39;</span><span class="p">)</span>
        <span class="n">r_hemi</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">rh_fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">surface_name</span> <span class="o">==</span> <span class="s1">&#39;inflated&#39;</span><span class="p">:</span>
            <span class="n">lh_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">l_hemi</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">l_hemi</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">r_hemi</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_hemi</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                           <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">l_hemi</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> \
                                           <span class="p">(</span><span class="mf">.5</span><span class="o">*</span><span class="n">lh_width</span><span class="p">)</span>

        <span class="c1"># Combine the surfaces</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">combine_surfaces</span><span class="p">([</span><span class="n">l_hemi</span><span class="p">,</span> <span class="n">r_hemi</span><span class="p">])</span>
        <span class="n">combined_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
        <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">combined_fname</span><span class="p">)</span>

    <span class="c1">## Downsample surfaces at the same time</span>
    <span class="c1"># Get list of surfaces</span>
    <span class="n">in_surfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">surface_name</span> <span class="ow">in</span> <span class="n">surfaces_to_process</span><span class="p">:</span>
        <span class="n">in_surf_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
        <span class="n">in_surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_surf_fname</span><span class="p">)</span>
        <span class="n">in_surfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_surf</span><span class="p">)</span>

    <span class="c1"># Downsample multiple surfaces</span>
    <span class="n">out_surfs</span> <span class="o">=</span> <span class="n">downsample_multiple_surfaces</span><span class="p">(</span><span class="n">in_surfs</span><span class="p">,</span> <span class="n">ds_factor</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">surface_name</span><span class="p">,</span> <span class="n">out_surf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">surfaces_to_process</span><span class="p">,</span> <span class="n">out_surfs</span><span class="p">):</span>
        <span class="n">out_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">surface_name</span><span class="si">}</span><span class="s1">.ds.gii&#39;</span><span class="p">)</span>
        <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">out_surf</span><span class="p">,</span> <span class="n">out_surf_path</span><span class="p">)</span>

    <span class="c1">## Compute dipole orientations</span>
    <span class="n">orientations</span> <span class="o">=</span> <span class="n">compute_dipole_orientations</span><span class="p">(</span>
        <span class="n">orientation</span><span class="p">,</span>
        <span class="n">layer_names</span><span class="p">,</span>
        <span class="n">out_dir</span><span class="p">,</span>
        <span class="n">fixed</span><span class="o">=</span><span class="n">fix_orientation</span>
    <span class="p">)</span>

    <span class="n">base_fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;ds.</span><span class="si">{</span><span class="n">orientation</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="n">fix_orientation</span><span class="p">:</span>
        <span class="n">base_fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">base_fname</span><span class="si">}</span><span class="s1">.fixed&#39;</span>
    <span class="k">for</span> <span class="n">l_idx</span><span class="p">,</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_names</span><span class="p">):</span>
        <span class="n">in_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.ds.gii&#39;</span><span class="p">)</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_surf_path</span><span class="p">)</span>

        <span class="c1"># Set these link vectors as the normals for the downsampled surface</span>
        <span class="n">ori_array</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">gifti</span><span class="o">.</span><span class="n">GiftiDataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">orientations</span><span class="p">[</span><span class="n">l_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                                           <span class="n">intent</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">intent_codes</span><span class="p">[</span><span class="s1">&#39;NIFTI_INTENT_VECTOR&#39;</span><span class="p">])</span>
        <span class="n">surf</span><span class="o">.</span><span class="n">add_gifti_data_array</span><span class="p">(</span><span class="n">ori_array</span><span class="p">)</span>

        <span class="c1"># Save the modified downsampled surface with link vectors as normals</span>
        <span class="n">out_surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">base_fname</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
        <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">out_surf_path</span><span class="p">)</span>

    <span class="c1">## Combine layers</span>
    <span class="n">all_surfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">layer_name</span> <span class="ow">in</span> <span class="n">layer_names</span><span class="p">:</span>
        <span class="n">surf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">base_fname</span><span class="si">}</span><span class="s1">.gii&#39;</span><span class="p">)</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">surf_path</span><span class="p">)</span>
        <span class="n">all_surfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>

    <span class="n">combined</span> <span class="o">=</span> <span class="n">combine_surfaces</span><span class="p">(</span><span class="n">all_surfs</span><span class="p">)</span>
    <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">out_fname</span><span class="p">))</span></div>


<div class="viewcode-block" id="mesh_adjacency"><a class="viewcode-back" href="../../lameg.html#lameg.surf.mesh_adjacency">[docs]</a><span class="k">def</span> <span class="nf">mesh_adjacency</span><span class="p">(</span><span class="n">faces</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the adjacency matrix of a triangle mesh.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    faces - a numpy array of shape [f, 3] representing the mesh faces</span>

<span class="sd">    Returns:</span>
<span class="sd">    adjacency - adjacency matrix as a sparse [v, v] array, where v is the number of vertices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">n_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>  <span class="c1"># Assuming max vertex index represents the number of vertices</span>

    <span class="c1"># Flatten the indices to create row and column indices for the adjacency matrix</span>
    <span class="n">row_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                             <span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]])</span>
    <span class="n">col_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># Create a sparse matrix from row and column indices</span>
    <span class="n">adjacency</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">row_indices</span><span class="p">),</span> <span class="p">(</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">col_indices</span><span class="p">)),</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Ensure the adjacency matrix is binary</span>
    <span class="n">adjacency</span> <span class="o">=</span> <span class="p">(</span><span class="n">adjacency</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adjacency</span></div>


<div class="viewcode-block" id="interpolate_data"><a class="viewcode-back" href="../../lameg.html#lameg.surf.interpolate_data">[docs]</a><span class="k">def</span> <span class="nf">interpolate_data</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span> <span class="n">downsampled_mesh</span><span class="p">,</span> <span class="n">downsampled_data</span><span class="p">,</span> <span class="n">adjacency_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates vertex data from a downsampled mesh back to the original mesh using nearest</span>
<span class="sd">    neighbor matching and optional smoothing based on an adjacency matrix. Both meshes are</span>
<span class="sd">    expected to be nibabel Gifti objects.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    original_mesh (GiftiImage): The original high-resolution mesh as a nibabel Gifti object from</span>
<span class="sd">                                which &#39;downsampled_mesh&#39; is derived.</span>
<span class="sd">    downsampled_mesh (GiftiImage): The downsampled version of the original mesh as a nibabel Gifti</span>
<span class="sd">                                   object.</span>
<span class="sd">    downsampled_data (array): Data associated with the vertices of &#39;downsampled_mesh&#39;.</span>
<span class="sd">    adjacency_matrix (sparse matrix, optional): A vertex-by-vertex adjacency matrix of the original</span>
<span class="sd">                                                mesh. If None, it will be computed from the</span>
<span class="sd">                                                &#39;original_mesh&#39;.</span>
<span class="sd">    max_iterations (int, optional): The maximum number of iterations to perform for smoothing the</span>
<span class="sd">                                    interpolated data.</span>

<span class="sd">    Returns:</span>
<span class="sd">    np.ndarray: An array of interpolated data for each vertex in the &#39;original_mesh&#39;. The data is</span>
<span class="sd">                initially interpolated using nearest neighbors and can be further refined through</span>
<span class="sd">                iterative smoothing.</span>

<span class="sd">    The function first finds the nearest vertex in the &#39;downsampled_mesh&#39; for each vertex in the</span>
<span class="sd">    &#39;original_mesh&#39; using a KD-tree. It directly assigns corresponding data values where a close</span>
<span class="sd">    match is found. The function iteratively adjusts data values at vertices without direct matches</span>
<span class="sd">    by averaging over neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">adjacency_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">mesh_adjacency</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="n">original_vertices</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">downsampled_vertices</span> <span class="o">=</span> <span class="n">downsampled_mesh</span><span class="o">.</span><span class="n">darrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># Build a KD-tree for the downsampled vertices</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">downsampled_vertices</span><span class="p">)</span>

    <span class="c1"># Preallocate the vertex data array</span>
    <span class="n">vertex_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_vertices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># Find the nearest neighbor in the downsampled mesh for each vertex in the original mesh</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">original_vertices</span><span class="p">,</span> <span class="n">distance_upper_bound</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

    <span class="c1"># Set the vertex data for vertices that match (distance is zero or very close)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>  <span class="c1"># Adjust this threshold as needed</span>
            <span class="n">vertex_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">downsampled_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vertex_data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&lt;</span> <span class="n">max_iterations</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vertex_data</span><span class="p">))[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">valid_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vertex_data</span><span class="p">[</span><span class="n">neighbors</span><span class="p">])]</span>

            <span class="k">if</span> <span class="n">valid_neighbors</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">([</span><span class="n">original_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">original_vertices</span><span class="p">[</span><span class="n">valid_neighbors</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">distances</span>
                <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">vertex_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">,</span> <span class="n">vertex_data</span><span class="p">[</span><span class="n">valid_neighbors</span><span class="p">])</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">vertex_data</span></div>


<div class="viewcode-block" id="split_fv"><a class="viewcode-back" href="../../lameg.html#lameg.surf.split_fv">[docs]</a><span class="k">def</span> <span class="nf">split_fv</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits faces and vertices into connected pieces based on the connectivity of the faces.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    faces (np.array): A 2D numpy array of faces, where each row represents a face and each element</span>
<span class="sd">                      is an index to a vertex in vertices.</span>
<span class="sd">    vertices (np.array): A 2D numpy array of vertices, where each row represents a vertex.</span>

<span class="sd">    Returns:</span>
<span class="sd">    list of dicts: A list where each element is a dictionary with keys &#39;faces&#39; and &#39;vertices&#39;. Each</span>
<span class="sd">                   dictionary represents a separately connected patch of the mesh.</span>

<span class="sd">    Examples:</span>
<span class="sd">    &gt;&gt;&gt; faces = np.array([[1, 2, 3], [1, 3, 4], [5, 6, 1], [7, 8, 9], [11, 10, 4]])</span>
<span class="sd">    &gt;&gt;&gt; vertices = np.array([[2, 4], [2, 8], [8, 4], [8, 0], [0, 4], [2, 6], [2, 2], [4, 2],</span>
<span class="sd">                             [4, 0], [5, 2], [5, 0]])</span>
<span class="sd">    &gt;&gt;&gt; split_patches = split_fv(faces, vertices)</span>

<span class="sd">    Note: Faces and vertices should be defined such that faces sharing a vertex reference the same</span>
<span class="sd">          vertex number. This function does not explicitly test for duplicate vertices at the same</span>
<span class="sd">          location.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">current_set</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">f_sets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">current_set</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">next_avail_face</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f_sets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">open_vertices</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">next_avail_face</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">open_vertices</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">avail_face_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f_sets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">is_member</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">avail_face_inds</span><span class="p">],</span> <span class="n">open_vertices</span><span class="p">)</span>
            <span class="n">avail_face_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_member</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f_sets</span><span class="p">[</span><span class="n">avail_face_inds</span><span class="p">[</span><span class="n">avail_face_sub</span><span class="p">]]</span> <span class="o">=</span> <span class="n">current_set</span>
            <span class="n">open_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">avail_face_inds</span><span class="p">[</span><span class="n">avail_face_sub</span><span class="p">]])</span>

    <span class="n">fv_out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">set_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">current_set</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">set_f</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">f_sets</span> <span class="o">==</span> <span class="n">set_num</span><span class="p">]</span>
        <span class="n">unique_vertices</span><span class="p">,</span> <span class="n">new_vertex_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_f</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fv_out</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;faces&#39;</span><span class="p">:</span> <span class="n">new_vertex_indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">set_f</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="p">[</span><span class="n">unique_vertices</span><span class="p">]</span>
        <span class="p">})</span>

    <span class="k">return</span> <span class="n">fv_out</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, DANC lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>